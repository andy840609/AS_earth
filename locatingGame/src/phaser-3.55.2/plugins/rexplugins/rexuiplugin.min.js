!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).rexuiplugin = e() }(void 0, function () { function P(t) { return (P = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function z(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function n(t, e) { for (var i = 0; i < e.length; i++) { var n = e[i]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n) } } function k(t, e, i) { return e && n(t.prototype, e), i && n(t, i), Object.defineProperty(t, "prototype", { writable: !1 }), t } function w(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && i(t, e) } function C(t) { return (C = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } function i(t, e) { return (i = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t })(t, e) } function j(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function T(n) { var s = function () { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () { })), !0 } catch (t) { return !1 } }(); return function () { var t, e = C(n); if (s) { var i = C(this).constructor; t = Reflect.construct(e, arguments, i) } else t = e.apply(this, arguments); return function (t, e) { if (e && ("object" == typeof e || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return j(t) }(this, t) } } function l(t, e) { for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = C(t));); return t } function O() { return (O = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (t, e, i) { var n = l(t, e); if (n) { var s = Object.getOwnPropertyDescriptor(n, e); return s.get ? s.get.call(arguments.length < 3 ? t : i) : s.value } }).apply(this, arguments) } function r(t, e, i, n) { return (r = "undefined" != typeof Reflect && Reflect.set ? Reflect.set : function (t, e, i, n) { var s, r, o, a, h = l(t, e); if (h) { if ((s = Object.getOwnPropertyDescriptor(h, e)).set) return s.set.call(n, i), !0; if (!s.writable) return !1 } if (s = Object.getOwnPropertyDescriptor(n, e)) { if (!s.writable) return !1; s.value = i, Object.defineProperty(n, e, s) } else a = i, (o = e) in (r = n) ? Object.defineProperty(r, o, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : r[o] = a; return !0 })(t, e, i, n) } function e(t, e, i, n, s) { if (!r(t, e, i, n || t) && s) throw new Error("failed to set property"); return i } function S(t) { return function (t) { if (Array.isArray(t)) return t }(t) || s(t) || o(t) || function () { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } function M(t) { return function (t) { if (Array.isArray(t)) return a(t) }(t) || s(t) || o(t) || function () { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } function s(t) { if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t) } function o(t, e) { if (t) { if ("string" == typeof t) return a(t, e); var i = Object.prototype.toString.call(t).slice(8, -1); return "Object" === i && t.constructor && (i = t.constructor.name), "Map" === i || "Set" === i ? Array.from(t) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? a(t, e) : void 0 } } function a(t, e) { (null == e || e > t.length) && (e = t.length); for (var i = 0, n = new Array(e); i < e; i++)n[i] = t[i]; return n } function E(t) { var e, i, n; if ("object" !== P(t) || null === t) return t; for (n in e = Array.isArray(t) ? [] : {}, t) i = t[n], e[n] = E(i); return e } function _() { } function h(t, g) { var e = function () { w(v, t); var p = T(v); function v(t, e, i, n, s, r, o, a, h, l) { var u; z(this, v), m(e) ? (e = b(l = e, "x", 0), i = b(l, "y", 0), n = b(l, "width", 1), s = b(l, "height", 1), r = b(l, "key", void 0), o = b(l, "baseFrame", void 0), a = b(l, "columns", void 0), h = b(l, "rows", void 0)) : m(n) ? (n = b(l = n, "width", 1), s = b(l, "height", 1), r = b(l, "key", void 0), o = b(l, "baseFrame", void 0), a = b(l, "columns", void 0), h = b(l, "rows", void 0)) : m(r) ? (r = b(l = r, "key", void 0), o = b(l, "baseFrame", void 0), a = b(l, "columns", void 0), h = b(l, "rows", void 0)) : m(o) ? (o = b(l = o, "baseFrame", void 0), a = b(l, "columns", void 0), h = b(l, "rows", void 0)) : Array.isArray(o) ? (l = h, h = a, a = o, o = b(l, "baseFrame", void 0)) : m(a) && (a = b(l = a, "columns", void 0), h = b(l, "rows", void 0)), (u = p.call(this, t)).type = g, u.setPosition(e, i).setSize(n, s).setOrigin(.5, .5), u.columns = {}, u.rows = {}, u.stretchMode = {}, u._tileSprite = void 0, u._image = void 0, u.setGetFrameNameCallback(b(l, "getFrameNameCallback", void 0)), u.setStretchMode(b(l, "stretchMode", 0)), u.setPreserveRatio(b(l, "preserveRatio", !0)); var c = b(l, "maxFixedPartScale", 1), d = b(l, "maxFixedPartScaleX", c), f = b(l, "maxFixedPartScaleY", void 0); return u.setMaxFixedPartScale(d, f), u.setTexture(r, o, a, h), u } return k(v, [{ key: "minWidth", get: function () { return this.columns.minWidth } }, { key: "minHeight", get: function () { return this.rows.minHeight } }, { key: "fixedPartScaleX", get: function () { return this.columns.scale } }, { key: "fixedPartScaleY", get: function () { return this.rows.scale } }, { key: "resize", value: function (t, e) { return this.width === t && this.height === e || (O(C(v.prototype), "resize", this).call(this, t, e), this.updateTexture()), this } }]), v }(); return Object.assign(e.prototype, y), e } function u(t, e, i) { return void 0 === i && (i = "image"), t[e] || (t[e] = t.scene.make[i]({ add: !1, origin: { x: 0, y: 0 } }), t.once("destroy", function () { t[e] && (t[e].destroy(), t[e] = void 0) })), t[e] } var c = function () { function i(t) { z(this, i), this.scene = t, this.displayList = t.sys.displayList, this.updateList = t.sys.updateList, t.events.once("destroy", this.destroy, this) } return k(i, [{ key: "destroy", value: function () { this.scene = null, this.displayList = null, this.updateList = null } }], [{ key: "register", value: function (t, e) { i.prototype[t] = e } }]), i }(), d = function (t, e, i) { return "__BASE" === i ? "".concat(t, ",").concat(e) : "".concat(i, "_").concat(t, ",").concat(e) }, f = Phaser.Utils.Objects.IsPlainObject, p = Phaser.Utils.Objects.GetValue, v = function (t) { return "string" == typeof t && (t = g[t]), t }, g = { scale: 0, repeat: 1 }, y = { _drawImage: _, _drawTileSprite: _, setGetFrameNameCallback: function (t) { return void 0 === t && (t = d), this.getFrameNameCallback = t, this }, setTexture: function (t, e, i, n) { Array.isArray(e) && (n = i, i = e, e = void 0), void 0 === e && (e = "__BASE"), i = E(i), n = E(n), this.textureKey = t, this.baseFrameName = e, this.columns.data = i, this.columns.count = i ? i.length : 0, this.columns.stretch = 0, this.columns.minWidth = 0, this.columns.scale = 1, this.rows.data = n, this.rows.count = n ? n.length : 0, this.rows.stretch = 0, this.rows.minHeight = 0, this.rows.scale = 1; var s = this.scene.sys.textures.get(t); if (!s) return this.clear(), this; if (!i || !n) return this.clear(), this; for (var r = s.frames[e], o = r.width, a = 0, h = 0, l = i.length; h < l; h++)void 0 === i[h] ? a++ : "number" == typeof i[h] ? o -= i[h] : o -= i[h].width; var u = o / a, c = r.height, d = 0; for (h = 0, l = n.length; h < l; h++)void 0 === n[h] ? d++ : "number" == typeof n[h] ? c -= n[h] : c -= n[h].width; for (var f, p, v, g, y, m = c / d, k = 0, b = 0, x = 0, C = n.length; x < C; x++) { void 0 === n[x] && (n[x] = m), "number" == typeof n[x] && (n[x] = { height: n[x], stretch: x % 2 }), v = (f = n[x]).height, this.rows.stretch += 0 | f.stretch, this.rows.minHeight += 0 < f.stretch ? 0 : v; h = k = 0; for (var w = i.length; h < w; h++) { if (void 0 === i[h] && (i[h] = u), "number" == typeof i[h] && (i[h] = { width: i[h], stretch: h % 2 }), g = (p = i[h]).width, 0 === x && (this.columns.stretch += 0 | p.stretch, this.columns.minWidth += 0 < p.stretch ? 0 : g), 1 <= g && 1 <= v) { var S = P(y = this.getFrameNameCallback(h, x, e)); "string" !== S && "number" !== S || s.add(y, 0, k + r.cutX, b + r.cutY, g, v) } k += g } b += v } return this.updateTexture(), this }, updateTexture: function () { if (this.clear(), void 0 === this.textureKey) return this; var t = this.scene.sys.textures.get(this.textureKey); if (!t) return this; var e, i, n, s, r, o, a, h = this.columns.minWidth * this.maxFixedPartScaleX, l = this.rows.minHeight * this.maxFixedPartScaleY, u = this.width - h, c = this.height - l, d = 0 <= u ? this.maxFixedPartScaleX : this.width / h, f = 0 <= c ? this.maxFixedPartScaleY : this.height / l; if (this.preserveRatio) { var p = Math.min(d, f); if (p < d) { var v = (d - p) * h; 0 <= u ? u += v : u = v, d = p } if (p < f) { var g = (f - p) * l; 0 <= c ? c += g : c = g, f = p } } this.columns.scale = d, this.rows.scale = f, e = 0 < u && 0 < this.columns.stretch ? u / this.columns.stretch : 0, i = 0 < c && 0 < this.rows.stretch ? c / this.rows.stretch : 0; for (var y = 0, m = 0, k = 0, b = this.rows.count; k < b; k++) { a = 0 === (r = this.rows.data[k]).stretch ? r.height * f : i * r.stretch; for (var x = y = 0, C = this.columns.count; x < C; x++)o = 0 === (s = this.columns.data[x]).stretch ? s.width * d : e * s.stretch, n = this.getFrameNameCallback(x, k, this.baseFrameName), t.has(n) && 0 < o && 0 < a && (0 === (0 === r.stretch && 0 === s.stretch || 0 === this.getStretchMode(x, k) ? 0 : 1) ? this._drawImage(this.textureKey, n, y, m, o, a) : this._drawTileSprite(this.textureKey, n, y, m, o, a)), y += o; m += a } }, setStretchMode: function (t) { return f(t) ? (this.stretchMode.edge = v(p(t, "edge", 0)), this.stretchMode.internal = v(p(t, "internal", 0))) : (t = v(t), this.stretchMode.edge = t, this.stretchMode.internal = t), this }, getStretchMode: function (t, e) { return function (t, e) { return 0 === t || t === this.columns.count - 1 || 0 === e || e === this.rows.count - 1 }.call(this, t, e) ? this.stretchMode.edge : this.stretchMode.internal }, setPreserveRatio: function (t) { return null == t && (t = !0), this.preserveRatio = t, this }, setMaxFixedPartScale: function (t, e) { return void 0 === e && (e = t), this.maxFixedPartScaleX = t, this.maxFixedPartScaleY = e, this } }, m = Phaser.Utils.Objects.IsPlainObject, b = Phaser.Utils.Objects.GetValue, t = { _drawImage: function (t, e, i, n, s, r) { var o = u(this, "_image", "image").setTexture(t, e).setDisplaySize(s, r); this.draw(o, i, n) }, _drawTileSprite: function (t, e, i, n, s, r) { var o = u(this, "_tileSprite", "tileSprite").setTexture(t, e).setSize(s, r); this.draw(o, i, n) } }, x = Phaser.GameObjects.RenderTexture, B = function () { w(e, h(x, "rexNinePatch")); var t = T(e); function e() { return z(this, e), t.apply(this, arguments) } return k(e) }(); Object.assign(B.prototype, t); function I(t) { return null == t || "" === t || 0 === t.length } function R(t, e, i, n) { if (void 0 === n && (n = "."), "object" === P(t)) { if (I(e)) { if (null == i) return; "object" === P(i) && (t = i) } else { "string" == typeof e && (e = e.split(n)); var s = e.pop(); (function (t, e, i) { var n = t; if (!I(e)) { var s; "string" == typeof e && (e = e.split(".")); for (var r = 0, o = e.length; r < o; r++) { var a; if (null == n[s = e[r]] || "object" !== P(n[s])) a = r !== o - 1 || void 0 === i ? {} : i, n[s] = a; n = n[s] } } return n })(t, e)[s] = i } return t } } c.register("ninePatch", function (t, e, i, n, s, r, o, a) { var h = new B(this.scene, t, e, i, n, s, r, o, a); return this.scene.add.existing(h), h }), R(window, "RexPlugins.UI.NinePatch", B); function A(t, e) { return this.texture = this.scene.sys.textures.get(t), this.frame = this.texture.get(e), this } function D(t, e) { if (this.width === t && this.height === e) return this; this.width = t, this.height = e, this.updateDisplayOrigin(); var i = this.input; return i && !i.customHitArea && (i.hitArea.width = t, i.hitArea.height = e), this } function L() { return this.poolManager && this.poolManager.freeMultiple(this.children.list), this.children.list.length = 0, this.lastAppendedChildren.length = 0, this.dirty = !0, this } var F = Phaser.GameObjects.GetCalcMatrix, Y = Phaser.Renderer.Canvas.SetTransform, W = { renderWebGL: function (t, e, i, n) { var s = e.getRenderList(); if (0 !== s.length) { i.addToRenderList(e); var r = t.pipelines.set(e.pipeline), o = e.frame.glTexture, a = r.setGameObject(e), h = i.roundPixels, l = F(e, i, n), u = r.calcMatrix.copyFrom(l.calc), c = e._displayOriginX, d = e._displayOriginY, f = i.alpha * e.alpha; t.pipelines.preBatch(e); for (var p = 0, v = s.length; p < v; p++)s[p].webglRender(r, u, f, c, d, o, a, h); t.pipelines.postBatch(e) } }, renderCanvas: function (t, e, i, n) { var s = t.currentContext, r = e.getRenderList(); if (0 !== r.length && Y(t, s, e, i, n)) { i.addToRenderList(e); var o = i.roundPixels, a = -e._displayOriginX, h = -e._displayOriginY; s.translate(a, h); for (var l = 0, u = r.length; l < u; l++)r[l].canvasRender(s, a, h, o); s.restore() } } }, V = Phaser.Utils.Array.Remove, X = { setTexture: A, resize: D, setSize: D, addChild: function (t) { var e; (this.lastAppendedChildren.length = 0, Array.isArray(t)) ? (this.children.add(t), (e = this.lastAppendedChildren).push.apply(e, M(t))) : (this.children.add(t), this.lastAppendedChildren.push(t)); return this }, removeChild: function (t) { return this.poolManager && this.poolManager.free(t), V(this.children.list, t), this.lastAppendedChildren.length = 0, this.dirty = !0, this }, removeChildren: L, clear: L, getLastAppendedChildren: function () { return this.lastAppendedChildren }, getChildren: function () { return this.children.list } }; Object.assign(X, { setTint: function (t) { return this.tint = t, this.tintFill = !1, this }, setTintFill: function (t) { return this.tint = t, this.tintFill = !0, this }, clearTint: function () { return this.setTint(16777215), this } }); var G = function () { function t() { z(this, t), this.items = [] } return k(t, [{ key: "destroy", value: function () { this.clear(), this.items = void 0 } }, { key: "pop", value: function () { return 0 < this.items.length ? this.items.pop() : null } }, { key: "push", value: function (t) { return this.items.push(t), this } }, { key: "pushMultiple", value: function (t) { return this.items.push.apply(this.items, t), t.length = 0, this } }, { key: "clear", value: function () { return this.items.length = 0, this } }]), t }(), U = Phaser.Utils.Objects.GetValue, H = {}, N = function () { function e(t) { z(this, e), this.pools = U(t, "pools", H) } return k(e, [{ key: "destroy", value: function () { this.pools = void 0 } }, { key: "free", value: function (t) { if (!this.pools) return this; var e = t.type; return this.pools.hasOwnProperty(e) || (this.pools[e] = new G), this.pools[e].push(t), t.onFree(), this } }, { key: "freeMultiple", value: function (t) { if (!this.pools) return this; for (var e = 0, i = t.length; e < i; e++)this.free(t[e]); return this } }, { key: "allocate", value: function (t) { return this.pools && this.pools.hasOwnProperty(t) ? this.pools[t].pop() : null } }]), e }(), J = Phaser.GameObjects.GameObject, K = Phaser.Utils.Objects.IsPlainObject, q = Phaser.Utils.Objects.GetValue, $ = Phaser.Structs.List, Z = Phaser.Utils.Array.StableSort, Q = function () { w(l, J); var h = T(l); function l(t, e, i, n, s, r) { var o; z(this, l), K(e) && (e = q(r = e, "x", 0), i = q(r, "y", 0), n = q(r, "texture"), s = q(r, "frame")), void 0 === e && (e = 0), void 0 === i && (i = 0), (o = h.call(this, t, "rexBlitter")).children = new $, o.renderList = [], o.displayListDirty = !1, o.lastAppendedChildren = []; var a = q(r, "reuseBob", !0); return o.poolManager = a ? new N(r) : void 0, o.setTexture(n, s).setPosition(e, i).setOrigin(0, 0).clearTint().initPipeline(), o } return k(l, [{ key: "preDestroy", value: function () { this.removeChildren(), this.children.destroy(), this.renderList.length = 0, this.poolManager && this.poolManager.destroy() } }, { key: "getRenderList", value: function () { if (this.displayListDirty) { this.renderList.length = 0; for (var t = !1, e = this.children.list, i = 0, n = e.length; i < n; i++) { var s = e[i]; tt(s) && (this.renderList.push(s), t = t || 0 !== s.depth) } t && Z(this.renderList, et), this.displayListDirty = !1 } return this.renderList } }]), l }(), tt = function (t) { return t.active && t.visible && 0 < t.alpha }, et = function (t, e) { return t._depth - e._depth }, it = Phaser.GameObjects.Components; Phaser.Class.mixin(Q, [it.Alpha, it.BlendMode, it.ComputedSize, it.Depth, it.GetBounds, it.Mask, it.Origin, it.Pipeline, it.ScrollFactor, it.Transform, it.Visible, W, X]); function nt(t, e, i) { if (t && "number" != typeof t) { if (t.hasOwnProperty(e)) return t[e]; if (-1 === e.indexOf(".")) return i; for (var n = e.split("."), s = t, r = i, o = 0; o < n.length; o++) { if (!s.hasOwnProperty(n[o])) { r = i; break } r = s[n[o]], s = s[n[o]] } return r } return i } function st(t) { if ("object" !== P(t) || null === t) return t; if (Array.isArray(t)) t.length = 0; else for (var e in t) delete t[e]; return t } function rt(t, e) { var i = Array.isArray(t); if (void 0 === e ? e = i ? [] : {} : st(e), i) { e.length = t.length; for (var n = 0, s = t.length; n < s; n++)e[n] = t[n] } else for (var r in t) e[r] = t[r]; return e } var ot = { enableData: function () { return void 0 === this.data && (this.data = {}), this }, getData: function (t, e) { return this.enableData(), void 0 === t ? this.data : nt(this.data, t, e) }, setData: function (t, e) { if (this.enableData(), 1 === arguments.length) { var i = t; for (t in i) this.data[t] = i[t] } else this.data[t] = e; return this }, incData: function (t, e, i) { return void 0 === i && (i = 0), this.enableData(), this.setData(t, this.getData(t, i) + e), this }, mulData: function (t, e, i) { return void 0 === i && (i = 0), this.enableData(), this.setData(t, this.getData(t, i) * e), this }, clearData: function () { return this.data && st(this.data), this } }, at = function () { function i(t, e) { z(this, i), this.type = e, this.data = void 0, this.setParent(t).reset().setActive() } return k(i, [{ key: "destroy", value: function () { this.parent && this.parent.removeChild(this) } }, { key: "setParent", value: function (t) { return this.parent = t, this } }, { key: "setDisplayListDirty", value: function (t) { return t && this.parent && (this.parent.displayListDirty = !0), this } }, { key: "active", get: function () { return this._active }, set: function (t) { this.setDisplayListDirty(this._active != t), this._active = t } }, { key: "setActive", value: function (t) { return void 0 === t && (t = !0), this.active = t, this } }, { key: "modifyPorperties", value: function () { return this } }, { key: "reset", value: function () { this.clearData() } }, { key: "onFree", value: function () { this.reset().setActive(!1).setParent() } }]), i }(); Object.assign(at.prototype, ot); var ht = Phaser.Math.DegToRad, lt = Phaser.Math.RadToDeg, ut = Phaser.Utils.Objects.GetValue, ct = function () { w(e, at); var t = T(e); function e() { return z(this, e), t.apply(this, arguments) } return k(e, [{ key: "visible", get: function () { return this._visible }, set: function (t) { this.setDisplayListDirty(this._visible != t), this._visible = t } }, { key: "setVisible", value: function (t) { return void 0 === t && (t = !0), this.visible = t, this } }, { key: "alpha", get: function () { return this._alpha }, set: function (t) { this.setDisplayListDirty(!!this._alpha != !!t), this._alpha = t } }, { key: "setAlpha", value: function (t) { return this.alpha = t, this } }, { key: "setX", value: function (t) { return this.x = t, this } }, { key: "setY", value: function (t) { return this.y = t, this } }, { key: "setPosition", value: function (t, e) { return this.x = t, this.y = e, this } }, { key: "setRotation", value: function (t) { return this.rotation = t, this } }, { key: "angle", get: function () { return lt(this.rotation) }, set: function (t) { this.rotation = ht(t) } }, { key: "setAngle", value: function (t) { return this.angle = t, this } }, { key: "setScaleX", value: function (t) { return this.scaleX = t, this } }, { key: "width", get: function () { return this._width }, set: function (t) { this._width = t } }, { key: "setWidth", value: function (t, e) { return void 0 === e && (e = !1), this.width = t, e && (this.scaleY = this.scaleX), this } }, { key: "setScaleY", value: function (t) { return this.scaleY = t, this } }, { key: "setScale", value: function (t, e) { return void 0 === e && (e = t), this.scaleX = t, this.scaleY = e, this } }, { key: "height", get: function () { return this._height }, set: function (t) { this._height = t } }, { key: "setHeight", value: function (t, e) { return void 0 === e && (e = !1), this.height = t, e && (this.scaleX = this.scaleY), this } }, { key: "displayWidth", get: function () { return this._width * this.scaleX }, set: function (t) { this.scaleX = t / this._width } }, { key: "setDisplayWidth", value: function (t, e) { return void 0 === e && (e = !1), this.displayWidth = t, e && (this.scaleY = this.scaleX), this } }, { key: "displayHeight", get: function () { return this._height * this.scaleY }, set: function (t) { this.scaleY = t / this._height } }, { key: "setDisplayHeight", value: function (t, e) { return void 0 === e && (e = !1), this.displayHeight = t, e && (this.scaleX = this.scaleY), this } }, { key: "setOriginX", value: function (t) { return this.originX = t, this._displayOriginX = this.width * t, this } }, { key: "setOriginY", value: function (t) { return this.originY = t, this._displayOriginY = this.height * t, this } }, { key: "setOrigin", value: function (t, e) { return void 0 === e && (e = t), this.setOriginX(t).setOriginY(e), this } }, { key: "depth", get: function () { return this._depth }, set: function (t) { this.setDisplayListDirty(this._depth != t), this._depth = t } }, { key: "setDepth", value: function (t) { return void 0 === t && (t = 0), this.depth = t, this } }, { key: "modifyPorperties", value: function (t) { if (!t) return this; t.hasOwnProperty("x") && this.setX(t.x), t.hasOwnProperty("y") && this.setY(t.y), t.hasOwnProperty("rotation") ? this.setRotation(t.rotation) : t.hasOwnProperty("angle") && this.setAngle(t.angle), t.hasOwnProperty("alpha") && this.setAlpha(t.alpha); var e = ut(t, "width", void 0), i = ut(t, "height", void 0), n = ut(t, "scale", void 0), s = ut(t, "scaleX", n), r = ut(t, "scaleY", n); void 0 !== e ? void 0 === i && void 0 === r ? this.setWidth(e, !0) : this.setWidth(e) : void 0 !== s ? this.setScaleX(s) : t.hasOwnProperty("displayWidth") && this.setDisplayWidth(t.displayWidth), void 0 !== i ? void 0 === e && void 0 === s ? this.setHeight(i, !0) : this.setHeight(i) : void 0 !== r ? this.setScaleY(r) : t.hasOwnProperty("displayHeight") && this.setDisplayHeight(t.displayHeight); var o = ut(t, "origin", void 0); return void 0 !== o ? this.setOrigin(o) : (t.hasOwnProperty("originX") && this.setOriginX(t.originX), t.hasOwnProperty("originY") && this.setOriginY(t.originY)), t.hasOwnProperty("depth") && this.setDepth(t.depth), this } }, { key: "reset", value: function () { return O(C(e.prototype), "reset", this).call(this), this.setVisible().setAlpha(1).setPosition(0, 0).setRotation(0).setScale(1, 1).setOrigin(0).setDepth(0), this } }, { key: "webglRender", value: function () { } }, { key: "canvasRender", value: function () { } }]), e }(), dt = Phaser.GameObjects.Components.TransformMatrix, ft = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha, pt = new dt, vt = Phaser.Utils.Objects.IsPlainObject, gt = function () { w(s, ct); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, t, "image")).setFrame(e), i } return k(s, [{ key: "width", get: function () { return this._width }, set: function () { } }, { key: "height", get: function () { return this._height }, set: function () { } }, { key: "setFrame", value: function (t) { return 0 < arguments.length && !vt(t) && (t = this.parent.texture.get(t)), this.frame = t, this._width = t ? t.width : 0, this._height = t ? t.height : 0, this } }, { key: "setFlipX", value: function (t) { return void 0 === t && (t = !0), this.flipX = t, this } }, { key: "setFlipY", value: function (t) { return void 0 === t && (t = !0), this.flipY = t, this } }, { key: "resetFlip", value: function () { return this.flipX = !1, this.flipY = !1, this } }, { key: "tint", get: function () { return void 0 === this._tint ? this.parent.tint : this._tint }, set: function (t) { this._tint = t } }, { key: "setTint", value: function (t) { return this.tint = t, this.tintFill = !1, this } }, { key: "setTintFill", value: function (t) { return this.tint = t, this.tintFill = !0, this } }, { key: "clearTint", value: function () { return this.setTint(16777215), this } }, { key: "resetTint", value: function () { return this.tint = void 0, this.tintFill = void 0, this } }, { key: "tintFill", get: function () { return void 0 === this._tintFill ? this.parent.tintFill : this._tintFill }, set: function (t) { this._tintFill = t } }, { key: "reset", value: function () { return O(C(s.prototype), "reset", this).call(this), this.resetFlip().resetTint().setFrame(), this } }, { key: "modifyPorperties", value: function (t) { return t && (t.hasOwnProperty("width") && (t.displayWidth = t.width, delete t.width), t.hasOwnProperty("height") && (t.displayHeight = t.height, delete t.height), t.hasOwnProperty("frame") && this.setFrame(t.frame), O(C(s.prototype), "modifyPorperties", this).call(this, t), t.hasOwnProperty("flipX") && this.setFlipX(t.flipX), t.hasOwnProperty("flipY") && this.setFlipY(t.flipY), t.hasOwnProperty("tint") && this.setTint(t.tint), t.hasOwnProperty("tintFill") && this.setTintFill(t.tintFill)), this } }]), s }(), yt = { webglRender: function (t, e, i, n, s, r, o, a) { var h = this._width, l = this._height, u = h * this.originX, c = l * this.originY, d = this.x - n, f = this.y - s, p = 1, v = 1; this.flipX && (d += h - 2 * u, p = -1), this.flipY && (f += l - 2 * c, v = -1), pt.applyITRS(d, f, this.rotation, this.scaleX * p, this.scaleY * v), e.multiply(pt, pt); var g = -u, y = -c, m = g + h, k = y + l, b = pt.getXRound(g, y, a), x = pt.getXRound(g, k, a), C = pt.getXRound(m, k, a), w = pt.getXRound(m, y, a), S = pt.getYRound(g, y, a), P = pt.getYRound(g, k, a), T = pt.getYRound(m, k, a), O = pt.getYRound(m, y, a), M = this.frame.u0, E = this.frame.v0, _ = this.frame.u1, B = this.frame.v1, I = ft(this.tint, this.alpha * i); t.batchQuad(this.parent, b, S, x, P, C, T, w, O, M, E, _, B, I, I, I, I, this.tintFill, r, o) }, canvasRender: function (t, e, i, n) { t.save(); var s = this._width, r = this._height, o = s * this.originX, a = r * this.originY, h = this.x - o, l = this.y - a, u = 1, c = 1; this.flipX && (h += s, u = -1), this.flipY && (l += r, c = -1), n && (h = Math.round(h), l = Math.round(l)), t.translate(h, l), t.rotate(this.rotation), t.scale(this.scaleX * u, this.scaleY * c); var d = this.frame; t.drawImage(d.source.image, d.cutX, d.cutY, s, r, 0, 0, s, r), t.restore() } }; Object.assign(gt.prototype, yt); function mt(t, e) { "string" == typeof e && (e = { frame: e }); var i = t.poolManager ? t.poolManager.allocate("image") : null; return null === i ? i = new gt(t) : i.setParent(t).setActive(), i.modifyPorperties(e), t.addChild(i), i } var kt = { _drawImage: function (t, e, i, n, s, r) { mt(this, { frame: e, x: i, y: n, width: s, height: r }) }, _drawTileSprite: function (t, e, i, n, s, r) { var o = this.texture.get(e), a = o.width, h = o.height, l = Math.floor(s / a), u = Math.floor(r / h); i += (s - l * a) / 2, n += (r - u * h) / 2; for (var c = 0; c < l; c++)for (var d = 0; d < u; d++)mt(this, { frame: e, x: i + c * a, y: n + d * h }) } }, bt = function () { w(s, h(Q, "rexNinePatch2")); var t = T(s); function s() { return z(this, s), t.apply(this, arguments) } return k(s, [{ key: "setTexture", value: function (t, e, i, n) { return A.call(this, t, "__BASE"), this.columns && O(C(s.prototype), "setTexture", this).call(this, t, e, i, n), this } }]), s }(); Object.assign(bt.prototype, kt), c.register("ninePatch2", function (t, e, i, n, s, r, o, a) { var h = new bt(this.scene, t, e, i, n, s, r, o, a); return this.scene.add.existing(h), h }), R(window, "RexPlugins.UI.NinePatch2", bt); function xt(t, e, i) { var n = i.length; if (2 <= n) { var s = i[n - 2], r = i[n - 1]; if (t === s && e === r) return i } return i.push(t, e), i } function Ct(t, e, i, n, s, r, o, a, h) { o && s < r ? r -= 360 : !o && r < s && (r += 360); var l = Bt(r - s) / a; s = Bt(s); for (var u = 0; u <= a; u++) { var c = s + l * u, d = t + i * Math.cos(c), f = e + n * Math.sin(c); xt(d, f, h) } return h } function wt(t, e, i, n, s, r) { for (var o = It.getTintAppendFloatAlpha(i.fillColor, i.fillAlpha * n), a = i.pathData, h = i.pathIndexes, l = 0; l < h.length; l += 3) { var u = 2 * h[l], c = 2 * h[l + 1], d = 2 * h[l + 2], f = a[0 + u] - s, p = a[1 + u] - r, v = a[0 + c] - s, g = a[1 + c] - r, y = a[0 + d] - s, m = a[1 + d] - r, k = e.getX(f, p), b = e.getY(f, p), x = e.getX(v, g), C = e.getY(v, g), w = e.getX(y, m), S = e.getY(y, m); t.batchTri(i, k, b, x, C, w, S, 0, 0, 1, 1, o, o, o, 2) } } function St(t, e, i, n, s) { var r = t.strokeTint, o = Rt.getTintAppendFloatAlpha(e.strokeColor, e.strokeAlpha * i); r.TL = o, r.TR = o, r.BL = o, r.BR = o; var a = e.pathData, h = a.length - 1, l = e.lineWidth, u = l / 2, c = a[0] - n, d = a[1] - s; e.closePath || (h -= 2); for (var f = 2; f < h; f += 2) { var p = a[f] - n, v = a[f + 1] - s; t.batchLine(c, d, p, v, u, u, l, f - 2, !!e.closePath && f === h - 1), c = p, d = v } } function Pt(t, e, i, n) { var s = i || e.fillColor, r = n || e.fillAlpha, o = (16711680 & s) >>> 16, a = (65280 & s) >>> 8, h = 255 & s; t.fillStyle = "rgba(" + o + "," + a + "," + h + "," + r + ")" } function Tt(t, e, i, n) { var s = i || e.strokeColor, r = n || e.strokeAlpha, o = (16711680 & s) >>> 16, a = (65280 & s) >>> 8, h = 255 & s; t.strokeStyle = "rgba(" + o + "," + a + "," + h + "," + r + ")", t.lineWidth = e.lineWidth } var Ot = Phaser.Utils.Objects.GetValue, Mt = function () { function r(t, e, i, n, s) { z(this, r), this.cornerRadius = {}, this._width = 0, this._height = 0, this.setTo(t, e, i, n, s) } return k(r, [{ key: "setTo", value: function (t, e, i, n, s) { return this.setPosition(t, e), this.setRadius(s), this.setSize(i, n), this } }, { key: "setPosition", value: function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.x = t, this.y = e, this } }, { key: "setRadius", value: function (t) { return void 0 === t && (t = 0), this.radius = t, this } }, { key: "setSize", value: function (t, e) { return this.width = t, this.height = e, this } }, { key: "minWidth", get: function () { var t = this.cornerRadius; return Math.max(t.tl.x + t.tr.x, t.bl.x + t.br.x) } }, { key: "minHeight", get: function () { var t = this.cornerRadius; return Math.max(t.tl.y + t.bl.y, t.tr.y + t.br.y) } }, { key: "width", get: function () { return this._width }, set: function (t) { null == t && (t = 0), this._width = Math.max(t, this.minWidth) } }, { key: "height", get: function () { return this._height }, set: function (t) { null == t && (t = 0), this._height = Math.max(t, this.minHeight) } }, { key: "radius", get: function () { var t = this.cornerRadius; return Math.max(t.tl.x, t.tl.y, t.tr.x, t.tr.y, t.bl.x, t.bl.y, t.br.x, t.br.y) }, set: function (t) { var e, i; i = "number" == typeof t ? e = t : (e = Ot(t, "x", 0), Ot(t, "y", 0)); var n = this.cornerRadius; n.tl = Et(Ot(t, "tl", void 0), e, i), n.tr = Et(Ot(t, "tr", void 0), e, i), n.bl = Et(Ot(t, "bl", void 0), e, i), n.br = Et(Ot(t, "br", void 0), e, i) } }, { key: "radiusTL", get: function () { var t = this.cornerRadius.tl; return Math.max(t.x, t.y) }, set: function (t) { _t(this.cornerRadius.tl, t) } }, { key: "radiusTR", get: function () { var t = this.cornerRadius.tr; return Math.max(t.x, t.y) }, set: function (t) { _t(this.cornerRadius.tr, t) } }, { key: "radiusBL", get: function () { var t = this.cornerRadius.bl; return Math.max(t.x, t.y) }, set: function (t) { _t(this.cornerRadius.bl, t) } }, { key: "radiusBR", get: function () { var t = this.cornerRadius.br; return Math.max(t.x, t.y) }, set: function (t) { _t(this.cornerRadius.br, t) } }]), r }(), Et = function (t, e, i) { return void 0 === t ? { x: e, y: i } : "number" == typeof t ? { x: t, y: t } : t }, _t = function (t, e) { "number" == typeof e ? (t.x = e, t.y = e) : (t.x = Ot(e, "x", 0), t.y = Ot(e, "y", 0)) }, Bt = Phaser.Math.DegToRad, It = Phaser.Renderer.WebGL.Utils, Rt = Phaser.Renderer.WebGL.Utils, At = Phaser.GameObjects.GetCalcMatrix, Dt = Phaser.Renderer.Canvas.SetTransform, Lt = { renderWebGL: function (t, e, i, n) { e.dirty && (e.updateData(), e.dirty = !1), i.addToRenderList(e); var s = t.pipelines.set(e.pipeline), r = At(e, i, n), o = s.calcMatrix.copyFrom(r.calc), a = e._displayOriginX, h = e._displayOriginY, l = i.alpha * e.alpha; t.pipelines.preBatch(e), e.isFilled && wt(s, o, e, l, a, h), e.isStroked && St(s, e, l, a, h), t.pipelines.postBatch(e) }, renderCanvas: function (t, e, i, n) { e.dirty && (e.updateData(), e.dirty = !1), i.addToRenderList(e); var s = t.currentContext; if (Dt(t, s, e, i, n)) { var r = e._displayOriginX, o = e._displayOriginY, a = e.pathData, h = a.length - 1, l = a[0] - r, u = a[1] - o; s.beginPath(), s.moveTo(l, u), e.closePath || (h -= 2); for (var c = 2; c < h; c += 2) { var d = a[c] - r, f = a[c + 1] - o; s.lineTo(d, f) } s.closePath(), e.isFilled && (Pt(s, e), s.fill()), e.isStroked && (Tt(s, e), s.stroke()), s.restore() } } }, zt = Phaser.GameObjects.Shape, jt = Phaser.Utils.Objects.IsPlainObject, Ft = Phaser.Utils.Objects.GetValue, Yt = Phaser.Geom.Polygon.Earcut, Wt = function () { w(y, zt); var g = T(y); function y(t, e, i, n, s, r, o, a) { var h, l, u, c; if (z(this, y), jt(e)) { var d = e; e = d.x, i = d.y, n = d.width, s = d.height, r = d.radius, o = d.color, a = d.alpha, l = d.strokeColor, u = d.strokeAlpha, c = d.strokeWidth } void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === r && (r = 0); var f = new Mt; h = g.call(this, t, "rexRoundRectangleShape", f); var p = Ft(r, "radius", r); f.setTo(0, 0, n, s, p); var v = Ft(r, "iteration", void 0); return h.setIteration(v), h.setPosition(e, i), void 0 !== o && h.setFillStyle(o, a), void 0 !== l && (void 0 === c && (c = 2), h.setStrokeStyle(c, l, u)), h.updateDisplayOrigin(), h.dirty = !0, h } return k(y, [{ key: "updateData", value: function () { var t = this.geom, e = this.pathData; e.length = 0; var i, n = t.cornerRadius, s = this.iteration + 1; if (i = n.br, Vt(i)) { var r = t.width - i.x, o = t.height - i.y; Ct(r, o, i.x, i.y, 0, 90, !1, s, e) } else xt(t.width, t.height, e); if (i = n.bl, Vt(i)) { r = i.x, o = t.height - i.y; Ct(r, o, i.x, i.y, 90, 180, !1, s, e) } else xt(0, t.height, e); if (i = n.tl, Vt(i)) { r = i.x, o = i.y; Ct(r, o, i.x, i.y, 180, 270, !1, s, e) } else xt(0, 0, e); if (i = n.tr, Vt(i)) { r = t.width - i.x, o = i.y; Ct(r, o, i.x, i.y, 270, 360, !1, s, e) } else xt(t.width, 0, e); return e.push(e[0], e[1]), this.pathIndexes = Yt(e), this } }, { key: "width", get: function () { return this.geom.width }, set: function (t) { this.resize(t, this.height) } }, { key: "height", get: function () { return this.geom.height }, set: function (t) { this.resize(this.width, t) } }, { key: "setSize", value: function (t, e) { if (void 0 === e && (e = t), this.geom.width === t && this.geom.height === e) return this; this.geom.setSize(t, e), this.updateDisplayOrigin(), this.dirty = !0; var i = this.input; return i && !i.customHitArea && (i.hitArea.width = t, i.hitArea.height = e), this } }, { key: "resize", value: function (t, e) { return this.setSize(t, e), this } }, { key: "iteration", get: function () { return this._iteration }, set: function (t) { void 0 !== this._iteration ? this._iteration !== t && (this._iteration = t, this.dirty = !0) : this._iteration = t } }, { key: "setIteration", value: function (t) { return void 0 === t && (t = 6), this.iteration = t, this } }, { key: "radius", get: function () { return this.geom.radius }, set: function (t) { this.geom.setRadius(t), this.updateDisplayOrigin(), this.dirty = !0 } }, { key: "radiusTL", get: function () { return this.geom.radiusTL }, set: function (t) { this.geom.radiusTL = t, this.dirty = !0 } }, { key: "radiusTR", get: function () { return this.geom.radiusTR }, set: function (t) { this.geom.radiusTR = t, this.dirty = !0 } }, { key: "radiusBL", get: function () { return this.geom.radiusBL }, set: function (t) { this.geom.radiusBL = t, this.dirty = !0 } }, { key: "radiusBR", get: function () { return this.geom.radiusBR }, set: function (t) { this.geom.radiusBR = t, this.dirty = !0 } }, { key: "setRadius", value: function (t) { return void 0 === t && (t = 0), this.radius = t, this } }, { key: "setRadiusTL", value: function (t) { return void 0 === t && (t = 0), this.radiusTL = t, this } }, { key: "setRadiusTR", value: function (t) { return void 0 === t && (t = 0), this.radiusTR = t, this } }, { key: "setRadiusBL", value: function (t) { return void 0 === t && (t = 0), this.radiuBL = t, this } }, { key: "setRadiusBR", value: function (t) { return void 0 === t && (t = 0), this.radiusBR = t, this } }, { key: "cornerRadius", get: function () { return this.geom.cornerRadius }, set: function (t) { this.radius = t } }, { key: "setCornerRadius", value: function (t) { return this.setRadius(t) } }]), y }(), Vt = function (t) { return 0 !== t.x && 0 !== t.y }; Object.assign(Wt.prototype, Lt), c.register("roundRectangle", function (t, e, i, n, s, r, o) { var a = new Wt(this.scene, t, e, i, n, s, r, o); return this.scene.add.existing(a), a }), R(window, "RexPlugins.UI.RoundRectangle", Wt); function Xt(t, e, i, n, s, r, o) { var a, h = t.sys.textures, l = t.renderer; void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = e.width), void 0 === o && (o = e.height); var u = (a = h.exists(i) ? h.get(i) : h.createCanvas(i, r, o)).getSourceImage(); u.width !== r && (u.width = r), u.height !== o && (u.height = o); var c = u.getContext("2d"); c.clearRect(0, 0, r, o), c.drawImage(e, n, s, r, o), l.gl && a && l.canvasToTexture(u, a.source[0].glTexture, !0, 0) } var Gt = Phaser.Renderer.WebGL.Utils, Ut = { renderWebGL: function (t, e, i, n) { if (e.dirty && (e.updateTexture(), e.dirty = !1), 0 !== e.width && 0 !== e.height) { i.addToRenderList(e); var s = e.frame, r = s.width, o = s.height, a = Gt.getTintAppendFloatAlpha, h = t.pipelines.set(e.pipeline, e), l = h.setTexture2D(s.glTexture, e); t.pipelines.preBatch(e), h.batchTexture(e, s.glTexture, r, o, e.x, e.y, r / e.resolution, o / e.resolution, e.scaleX, e.scaleY, e.rotation, e.flipX, e.flipY, e.scrollFactorX, e.scrollFactorY, e.displayOriginX, e.displayOriginY, 0, 0, r, o, a(e.tintTopLeft, i.alpha * e._alphaTL), a(e.tintTopRight, i.alpha * e._alphaTR), a(e.tintBottomLeft, i.alpha * e._alphaBL), a(e.tintBottomRight, i.alpha * e._alphaBR), e.tintFill, 0, 0, i, n, !1, l), t.pipelines.postBatch(e) } }, renderCanvas: function (t, e, i, n) { e.dirty && (e.updateTexture(), e.dirty = !1), 0 !== e.width && 0 !== e.height && (i.addToRenderList(e), t.batchSprite(e, e.frame, i, n)) } }, Ht = Phaser.Display.Color, Nt = { clear: function () { return this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.dirty = !0, this }, fill: function (t) { return this.context.fillStyle = t, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height), this.dirty = !0, this }, loadFromURL: function (t, e) { var i = this, n = new Image; return n.onload = function () { i.width !== n.width || i.height !== n.height ? i.resize(n.width, n.height) : i.clear(), i.context.drawImage(n, 0, 0), i.updateTexture(), e && e(), n.onload = null, n.src = "", n.remove() }, n.src = t, this }, loadFromURLPromise: function (i) { var n = this; return new Promise(function (t, e) { n.loadFromURL(i, t) }) }, getDataURL: function (t, e) { return this.canvas.toDataURL(t, e) }, getPixel: function (t, e, i) { void 0 === i && (i = new Ht); var n = this.context.getImageData(t, e, 1, 1); return i.setTo(n.data[0], n.data[1], n.data[2], n.data[3]), i }, setPixel: function (t, e, i, n, s, r) { if ("number" != typeof i) { var o = i; i = o.red, n = o.green, s = o.blue, r = o.alpha } void 0 === r && (r = 0 !== i || 0 !== n || 0 !== s ? 255 : 0); var a = this.context.createImageData(1, 1); return a.data[0] = i, a.data[1] = n, a.data[2] = s, a.data[3] = r, this.context.putImageData(a, t, e), this.dirty = !0, this } }, Jt = { updateTexture: function (t, e) { t && (e ? t.call(e, this.canvas, this.context) : t(this.canvas, this.context)), this.canvas.width === this.frame.width && this.canvas.height === this.frame.height || this.frame.setSize(this.canvas.width, this.canvas.height), this.renderer.gl && (this.frame.source.glTexture = this.renderer.canvasToTexture(this.canvas, this.frame.source.glTexture, !0), this.frame.glTexture = this.frame.source.glTexture), this.dirty = !1; var i = this.input; return i && !i.customHitArea && (i.hitArea.width = this.width, i.hitArea.height = this.height), this }, generateTexture: function (t, e, i, n, s) { var r = this.canvas; return void 0 === n ? n = r.width : n *= this.resolution, void 0 === s ? s = r.height : s *= this.resolution, Xt(this.scene, r, t, e, i, n, s), this }, loadTexture: function (t, e) { var i = this.scene.sys.textures.getFrame(t, e); return i && (this.width !== i.cutWidth || this.height !== i.cutHeight ? this.setSize(i.cutWidth, i.cutHeight) : this.clear(), this.context.drawImage(i.source.image, i.cutX, i.cutY, i.cutWidth, i.cutHeight, 0, 0, this.canvas.width, this.canvas.height), this.dirty = !0), this } }, Kt = Phaser.Display.Canvas.CanvasPool, qt = Phaser.GameObjects.GameObject, $t = function () { w(a, qt); var o = T(a); function a(t, e, i, n, s) { var r; return z(this, a), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 1), void 0 === s && (s = 1), (r = o.call(this, t, "rexCanvas")).renderer = t.sys.game.renderer, r.resolution = 1, r._width = n, r._height = s, n = Math.max(Math.ceil(n * r.resolution), 1), s = Math.max(Math.ceil(s * r.resolution), 1), r.canvas = Kt.create(j(r), n, s), r.context = r.canvas.getContext("2d"), r.dirty = !1, r.setPosition(e, i), r.setOrigin(.5, .5), r.initPipeline(), r._crop = r.resetCropObject(), r.texture = t.sys.textures.addCanvas(null, r.canvas, !0), r.frame = r.texture.get(), r.frame.source.resolution = r.resolution, r.renderer && r.renderer.gl && (r.renderer.deleteTexture(r.frame.source.glTexture), r.frame.source.glTexture = null), r.dirty = !0, t.sys.game.events.on("contextrestored", r.onContextRestored, j(r)), r } return k(a, [{ key: "onContextRestored", value: function () { this.dirty = !0 } }, { key: "preDestroy", value: function () { this.scene.sys.game.events.off("contextrestored", this.onContextRestored, this), Kt.remove(this.canvas), this.texture.destroy(), this.canvas = null, this.context = null } }, { key: "width", get: function () { return this._width }, set: function (t) { this.setSize(t, this._height) } }, { key: "height", get: function () { return this._height }, set: function (t) { this.setSize(this._width, t) } }, { key: "setSize", value: function (t, e) { return this._width === t && this._height === e || (this._width = t, this._height = e, this.updateDisplayOrigin(), t = Math.max(Math.ceil(t * this.resolution), 1), e = Math.max(Math.ceil(e * this.resolution), 1), this.canvas.width = t, this.canvas.height = e, this.frame.setSize(t, e), this.dirty = !0), this } }, { key: "displayWidth", get: function () { return this.scaleX * this._width }, set: function (t) { this.scaleX = t / this._width } }, { key: "displayHeight", get: function () { return this.scaleY * this._height }, set: function (t) { this.scaleY = t / this._height } }, { key: "setDisplaySize", value: function (t, e) { return this.displayWidth = t, this.displayHeight = e, this } }, { key: "getCanvas", value: function (t) { return t || (this.dirty = !0), this.canvas } }, { key: "getContext", value: function (t) { return t || (this.dirty = !0), this.context } }, { key: "needRedraw", value: function () { return this.dirty = !0, this } }, { key: "resize", value: function (t, e) { return this.setSize(t, e), this } }]), a }(), Zt = Phaser.GameObjects.Components; Phaser.Class.mixin($t, [Zt.Alpha, Zt.BlendMode, Zt.Crop, Zt.Depth, Zt.Flip, Zt.GetBounds, Zt.Mask, Zt.Origin, Zt.Pipeline, Zt.ScrollFactor, Zt.Tint, Zt.Transform, Zt.Visible, Ut, Nt, Jt]); function Qt(t, e, i) { if (null == t) return t; switch (P(t)) { case "string": return t; case "number": return "#".concat(ie(Math.floor(t).toString(16), 6, "0", 1)); case "function": return t(e, i); case "object": return t.hasOwnProperty("r") ? t.hasOwnProperty("a") ? "rgba(".concat(t.r, ",").concat(t.g, ",").concat(t.b, ",").concat(t.a, ")") : "rgb(".concat(t.r, ",").concat(t.g, ",").concat(t.b, ")") : t.hasOwnProperty("h") ? t.hasOwnProperty("a") ? "hsla(".concat(t.h, ",").concat(t.s, ",").concat(t.l, ",").concat(t.a, ")") : "hsl(".concat(t.h, ",").concat(t.s, ",").concat(t.l, ")") : t; default: return t } } function te(t, e, i, n, s, r, o) { var a, h, l, u, c, d = new Mt(e, i, n, s, r), f = d.minWidth, p = d.minHeight, v = f <= n ? 1 : n / f, g = p <= s ? 1 : s / p, y = d.cornerRadius; t.save(), t.beginPath(), t.translate(e, i), u = n - (h = (a = y.br).x * v), c = s - (l = a.y * g), t.moveTo(n, c), 0 < h && 0 < l ? he(t, u, c, h, l, se, re, o) : (t.lineTo(n, s), t.lineTo(u, s)), u = h = (a = y.bl).x * v, c = s - (l = a.y * g), t.lineTo(h, s), 0 < h && 0 < l ? he(t, u, c, h, l, re, oe, o) : (t.lineTo(0, s), t.lineTo(0, c)), u = h = (a = y.tl).x * v, c = l = a.y * g, t.lineTo(0, c), 0 < h && 0 < l ? he(t, u, c, h, l, oe, ae, o) : (t.lineTo(0, 0), t.lineTo(u, 0)), u = n - (h = (a = y.tr).x * v), c = l = a.y * g, t.lineTo(u, 0), 0 < h && 0 < l ? he(t, u, c, h, l, ae, se, o) : (t.lineTo(n, 0), t.lineTo(n, c)), t.closePath(), t.restore() } function ee(t, e, i, n, s, r, o, a) { if (null != e || null != i) { var h = t.canvas.width, l = t.canvas.height; null == i && (n = 0); var u = n / 2; h -= n, l -= n, function (t, e, i, n, s, r, o, a, h, l, u, c) { if (te(t, e, i, n, s, r, c), null != o) { var d; if (null != l) (d = u ? t.createLinearGradient(0, 0, n, 0) : t.createLinearGradient(0, 0, 0, s)).addColorStop(0, o), d.addColorStop(1, l), o = d; t.fillStyle = o, t.fill() } null != a && 0 < h && (t.strokeStyle = a, t.lineWidth = h, t.stroke()) }((t.canvas, t.context), u, u, h, l, s, e, i, n, r, o, a) } } var ie = Phaser.Utils.String.Pad, ne = Phaser.Math.DegToRad, se = ne(0), re = ne(90), oe = ne(180), ae = ne(270), he = function (t, e, i, n, s, r, o, a) { if (null == a) t.ellipse(e, i, n, s, 0, r, o); else for (var h, l, u, c = (o - r) / (a += 1), d = 0; d <= a; d++)u = r + c * d, h = e + n * Math.cos(u), l = i + s * Math.sin(u), t.lineTo(h, l) }, le = Phaser.Utils.Objects.GetValue, ue = function () { w(v, $t); var p = T(v); function v(t, e, i, n, s, r, o, a, h, l, u) { var c; z(this, v), (c = p.call(this, t, e, i, n, s)).type = "rexRoundRectangleCanvas"; var d = le(r, "radius", r), f = le(r, "iteration", void 0); return c.setRadius(d), c.setIteration(f), c.setFillStyle(o, l, u), c.setStrokeStyle(a, h), c } return k(v, [{ key: "radius", get: function () { return this._radius }, set: function (t) { this.dirty |= this._radius != t, this._radius = t } }, { key: "setRadius", value: function (t) { return this.radius = t, this } }, { key: "iteration", get: function () { return this._iteration }, set: function (t) { this.dirty |= this._iteration != t, this._iteration = t } }, { key: "setIteration", value: function (t) { return this.iteration = t, this } }, { key: "fillStyle", get: function () { return this._fillStyle }, set: function (t) { t = Qt(t, this.canvas, this.context), this.dirty |= this._fillStyle != t, this._fillStyle = t } }, { key: "fillColor2", get: function () { return this._fillColor2 }, set: function (t) { t = Qt(t, this.canvas, this.context), this.dirty |= this._fillColor2 != t, this._fillColor2 = t } }, { key: "isHorizontalGradient", get: function () { return this._fillStyle }, set: function (t) { this.dirty |= this._isHorizontalGradient != t, this._isHorizontalGradient = t } }, { key: "setFillStyle", value: function (t, e, i) { return void 0 === i && (i = !0), this.fillStyle = t, this.fillColor2 = e, this.isHorizontalGradient = i, this } }, { key: "strokeStyle", get: function () { return this._strokeStyle }, set: function (t) { t = Qt(t, this.canvas, this.context), this.dirty |= this._strokeStyle != t, this._strokeStyle = t } }, { key: "lineWidth", get: function () { return this._lineWidth }, set: function (t) { this.dirty |= this._lineWidth != t, this._lineWidth = t } }, { key: "setStrokeStyle", value: function (t, e) { return this.strokeStyle = t, this.lineWidth = e, this } }, { key: "updateTexture", value: function () { return this.clear(), function () { ee(this, this.fillStyle, this.strokeStyle, this.lineWidth, this.radius, this.fillColor2, this.isHorizontalGradient, this.iteration) }.call(this), O(C(v.prototype), "updateTexture", this).call(this), this } }]), v }(); c.register("roundRectangleCanvas", function (t, e, i, n, s, r, o, a, h, l) { var u = new ue(this.scene, t, e, i, n, s, r, o, a, h, l); return this.scene.add.existing(u), u }), R(window, "RexPlugins.UI.RoundRectangleCanvas", ue); function ce(t) { var e = ge.create(this), i = e.getContext("2d"); t.syncFont(e, i); var n = i.measureText(t.testString); if ("actualBoundingBoxAscent" in n) { var s = n.actualBoundingBoxAscent, r = n.actualBoundingBoxDescent, o = { ascent: s, descent: r, fontSize: s + r }; return ge.remove(e), o } var a = Math.ceil(n.width * t.baselineX), h = a, l = 2 * h; if (h = h * t.baselineY | 0, e.width = a, e.height = l, i.fillStyle = "#f00", i.fillRect(0, 0, a, l), i.font = t._font, i.textBaseline = "alphabetic", i.fillStyle = "#000", i.fillText(t.testString, 0, h), o = { ascent: 0, descent: 0, fontSize: 0 }, !i.getImageData(0, 0, a, l)) return o.ascent = h, o.descent = h + 6, o.fontSize = o.ascent + o.descent, ge.remove(e), o; var u, c, d = i.getImageData(0, 0, a, l).data, f = d.length, p = 4 * a, v = 0, g = !1; for (u = 0; u < h; u++) { for (c = 0; c < p; c += 4)if (255 !== d[v + c]) { g = !0; break } if (g) break; v += p } for (o.ascent = h - u, v = f - p, g = !1, u = l; h < u; u--) { for (c = 0; c < p; c += 4)if (255 !== d[v + c]) { g = !0; break } if (g) break; v -= p } return o.descent = u - h, o.fontSize = o.ascent + o.descent, ge.remove(e), o } function de(t, e, i) { var n = Ke.pop(); return null === n && (n = {}), n.text = t, n.width = e, n.newLineMode = i, n } function fe(t, e, i, n, s) { n <= 0 && (i = Qe); var r = []; if (!t || !t.length) return r; for (var o, a, h, l, u = i === Qe, c = i === ti, d = t.split(ii), f = 0, p = d.length; f < p; f++)if (o = d[f], h = f === p - 1 ? qe : $e, u) { var v = e(o); r.push(de(o, v, h)) } else { var g, y, m, k, b; if (a = 0 === f ? n - s : n, o.length <= 100) if ((v = e(o)) <= a) { r.push(de(o, v, h)); continue } c ? (y = "" === (g = o.split(" "))[g.length - 1]) && --g.length : g = o; for (var x, C = "", w = 0, S = c ? e(" ") : void 0, P = 0, T = g.length; P < T; P++)if (k = e(m = g[P]), b = P === T - 1, !c || b && !y || (m += " ", k += S), c && n < k) { "" !== C ? r.push(de(C, w, Ze)) : 0 === P && 0 < s && r.push(de("", 0, Ze)), r.push.apply(r, M(fe(m, e, ei, n, 0))); var O = r.pop(); C = O.text, w = O.width, (l = O) && Ke.push(l), " " === C && (C = "", w = 0) } else a < (x = w + k) ? (r.push(de(C, w, Ze)), C = m, w = k, a = n) : (C += m, w = x), b && r.push(de(C, w, h)) } return r } var pe = Phaser.Renderer.WebGL.Utils, ve = { renderWebGL: function (t, e, i, n) { if (0 !== e.width && 0 !== e.height) { i.addToRenderList(e); var s = e.frame, r = s.width, o = s.height, a = pe.getTintAppendFloatAlpha, h = t.pipelines.set(e.pipeline, e), l = h.setTexture2D(s.glTexture, e); t.pipelines.preBatch(e), h.batchTexture(e, s.glTexture, r, o, e.x, e.y, r / e.style.resolution, o / e.style.resolution, e.scaleX, e.scaleY, e.rotation, e.flipX, e.flipY, e.scrollFactorX, e.scrollFactorY, e.displayOriginX, e.displayOriginY, 0, 0, r, o, a(e.tintTopLeft, i.alpha * e._alphaTL), a(e.tintTopRight, i.alpha * e._alphaTR), a(e.tintBottomLeft, i.alpha * e._alphaBL), a(e.tintBottomRight, i.alpha * e._alphaBR), e.tintFill, 0, 0, i, n, !1, l), t.pipelines.postBatch(e) } }, renderCanvas: function (t, e, i, n) { 0 !== e.width && 0 !== e.height && (i.addToRenderList(e), t.batchSprite(e, e.frame, i, n)) } }, ge = Phaser.Display.Canvas.CanvasPool, ye = 0, me = 1, ke = 2, be = 0, xe = 1, Ce = 2, we = /(?:\r\n|\r|\n)/, Se = Phaser.Utils.Objects.GetAdvancedValue, Pe = Phaser.Utils.Objects.GetValue, Te = { backgroundColor: ["backgroundColor", null, Qt], backgroundColor2: ["backgroundColor2", null, Qt], backgroundHorizontalGradient: ["backgroundHorizontalGradient", !0, null], backgroundStrokeColor: ["backgroundStrokeColor", null, Qt], backgroundStrokeLineWidth: ["backgroundStrokeLineWidth", 2, null], backgroundCornerRadius: ["backgroundCornerRadius", 0, null], backgroundCornerIteration: ["backgroundCornerIteration", null, null], fontFamily: ["fontFamily", "Courier", null], fontSize: ["fontSize", "16px", null], fontStyle: ["fontStyle", "", null], color: ["color", "#fff", Qt], stroke: ["stroke", "#fff", Qt], strokeThickness: ["strokeThickness", 0, null], shadowOffsetX: ["shadow.offsetX", 0, null], shadowOffsetY: ["shadow.offsetY", 0, null], shadowColor: ["shadow.color", "#000", Qt], shadowBlur: ["shadow.blur", 0, null], shadowStroke: ["shadow.stroke", !1, null], shadowFill: ["shadow.fill", !1, null], underlineColor: ["underline.color", "#000", Qt], underlineThickness: ["underline.thickness", 0, null], underlineOffset: ["underline.offset", 0, null], halign: ["halign", "left", null], valign: ["valign", "top", null], maxLines: ["maxLines", 0, null], fixedWidth: ["fixedWidth", 0, null], fixedHeight: ["fixedHeight", 0, null], resolution: ["resolution", 0, null], lineSpacing: ["lineSpacing", 0, null], xOffset: ["xOffset", 0, null], rtl: ["rtl", !1, null], testString: ["testString", "|MÃ‰qgy", null], baselineX: ["baselineX", 1.2, null], baselineY: ["baselineY", 1.4, null], wrapMode: ["wrap.mode", 0, null], wrapWidth: ["wrap.width", 0, null], wrapCallback: ["wrap.callback", null], wrapCallbackScope: ["wrap.callbackScope", null] }, Oe = function () { function i(t, e) { z(this, i), this.parent = t, this.backgroundColor, this.backgroundColor2, this.backgroundHorizontalGradient, this.backgroundStrokeColor, this.backgroundStrokeLineWidth, this.backgroundCornerRadius, this.backgroundCornerIteration, this.fontFamily, this.fontSize, this.fontStyle, this.color, this.stroke, this.strokeThickness, this.shadowOffsetX, this.shadowOffsetY, this.shadowColor, this.shadowBlur, this.shadowStroke, this.shadowFill, this.underlineColor, this.underlineThickness, this.underlineOffset, this.halign, this.valign, this.maxLines, this.fixedWidth, this.fixedHeight, this.resolution, this.lineSpacing, this.xOffset, this.rtl, this.testString, this.baselineX, this.baselineY, this.wrapMode, this.wrapWidth, this.wrapCallback, this.wrapCallbackScope, this._font, this.setStyle(e, !1, !0) } return k(i, [{ key: "canvas", get: function () { return this.parent.canvasText.canvas } }, { key: "context", get: function () { return this.parent.canvasText.context } }, { key: "isWrapFitMode", get: function () { return 0 < this.fixedWidth && this.wrapMode !== be && 0 === this.wrapWidth } }, { key: "setStyle", value: function (t, e, i) { if (void 0 === e && (e = !0), void 0 === i && (i = !1), t && t.hasOwnProperty("wrap")) { var n = t.wrap; if (n.hasOwnProperty("mode")) { var s = n.mode; "string" == typeof s && (n.mode = Me[s]) } else n.hasOwnProperty("width") && (n.mode = 1) } for (var r in t && t.rtl && i && !t.hasOwnProperty("halign") && (t.halign = "right"), t && t.hasOwnProperty("fontSize") && "number" == typeof t.fontSize && (t.fontSize = t.fontSize.toString() + "px"), Te) { var o = Te[r], a = o[0], h = i ? o[1] : this[r], l = o[2]; if ("wrapCallback" === r || "wrapCallbackScope" === r) this[r] = Pe(t, a, h); else { var u = Se(t, a, h); l && (u = l(u)), this[r] = u } } var c = Pe(t, "font", null); this._font = null === c ? this.fontStyle + " " + this.fontSize + " " + this.fontFamily : c; var d = Pe(t, "fill", null); null !== d && (this.color = Qt(d)); var f = Pe(t, "images", void 0); f && this.parent.addImage(f); var p = Pe(t, "metrics", !1); return p ? this.metrics = { ascent: Pe(p, "ascent", 0), descent: Pe(p, "descent", 0), fontSize: Pe(p, "fontSize", 0) } : !e && this.metrics || (this.metrics = ce(this)), e ? this.parent.updateText() : this.parent } }, { key: "syncFont", value: function (t, e) { e.font = this._font } }, { key: "syncStyle", value: function (t, e) { e.textBaseline = "alphabetic", e.fillStyle = this.color, e.strokeStyle = this.stroke, e.lineWidth = this.strokeThickness, e.lineCap = "round", e.lineJoin = "round" } }, { key: "syncShadow", value: function (t, e) { e ? (t.shadowOffsetX = this.shadowOffsetX, t.shadowOffsetY = this.shadowOffsetY, t.shadowColor = this.shadowColor, t.shadowBlur = this.shadowBlur) : (t.shadowOffsetX = 0, t.shadowOffsetY = 0, t.shadowColor = 0, t.shadowBlur = 0) } }, { key: "update", value: function (t) { return t && (this._font = "".concat(this.fontStyle, " ").concat(this.fontSize, " ").concat(this.fontFamily).trim(), this.metrics = ce(this)), this.parent.updateText(t) } }, { key: "buildFont", value: function () { var t = "".concat(this.fontStyle, " ").concat(this.fontSize, " ").concat(this.fontFamily).trim(); return t !== this._font && (this._font = t), this } }, { key: "setFont", value: function (t) { return "string" == typeof t ? (this.fontFamily = t, this.fontSize = "", this.fontStyle = "") : (this.fontFamily = Pe(t, "fontFamily", "Courier"), this.fontSize = Pe(t, "fontSize", "16px"), this.fontStyle = Pe(t, "fontStyle", "")), this.update(!0) } }, { key: "setFontFamily", value: function (t) { return this.fontFamily = t, this.update(!0) } }, { key: "setFontStyle", value: function (t) { return this.fontStyle = t, this.update(!0) } }, { key: "setFontSize", value: function (t) { return "number" == typeof t && (t = t.toString() + "px"), this.fontSize = t, this.update(!0) } }, { key: "setTestString", value: function (t) { return this.testString = t, this.update(!0) } }, { key: "setFixedSize", value: function (t, e) { return this.fixedWidth = t, this.fixedHeight = e, t && (this.parent.width = t), e && (this.parent.height = e), this.update(this.isWrapFitMode) } }, { key: "setResolution", value: function (t) { return this.resolution = t, this.update(!1) } }, { key: "setLineSpacing", value: function (t) { return this.lineSpacing = t, this.update(!1) } }, { key: "setXOffset", value: function (t) { return this.xOffset = t, this.update(!1) } }, { key: "setBackgroundColor", value: function (t, e, i) { return void 0 === i && (i = !0), this.backgroundColor = Qt(t, this.canvas, this.context), this.backgroundColor2 = Qt(e, this.canvas, this.context), this.backgroundHorizontalGradient = i, this.update(!1) } }, { key: "setBackgroundStrokeColor", value: function (t, e) { return this.backgroundStrokeColor = Qt(t, this.canvas, this.context), this.backgroundStrokeLineWidth = e, this.update(!1) } }, { key: "setBackgroundCornerRadius", value: function (t, e) { return this.backgroundCornerRadius = t, this.backgroundCornerIteration = e, this.update(!1) } }, { key: "setFill", value: function (t) { return this.color = Qt(t, this.canvas, this.context), this.update(!1) } }, { key: "setColor", value: function (t) { return this.color = Qt(t, this.canvas, this.context), this.update(!1) } }, { key: "setStroke", value: function (t, e) { return void 0 === t ? this.strokeThickness = 0 : (void 0 === e && (e = this.strokeThickness), this.stroke = Qt(t, this.canvas, this.context), this.strokeThickness = e), this.update(!0) } }, { key: "setShadow", value: function (t, e, i, n, s, r) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = "#000"), void 0 === n && (n = 0), void 0 === s && (s = !1), void 0 === r && (r = !0), this.shadowOffsetX = t, this.shadowOffsetY = e, this.shadowColor = Qt(i, this.canvas, this.context), this.shadowBlur = n, this.shadowStroke = s, this.shadowFill = r, this.update(!1) } }, { key: "setShadowOffset", value: function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.shadowOffsetX = t, this.shadowOffsetY = e, this.update(!1) } }, { key: "setShadowColor", value: function (t) { return void 0 === t && (t = "#000"), this.shadowColor = Qt(t, this.canvas, this.context), this.update(!1) } }, { key: "setShadowBlur", value: function (t) { return void 0 === t && (t = 0), this.shadowBlur = t, this.update(!1) } }, { key: "setShadowStroke", value: function (t) { return this.shadowStroke = t, this.update(!1) } }, { key: "setShadowFill", value: function (t) { return this.shadowFill = t, this.update(!1) } }, { key: "setUnderline", value: function (t, e, i) { return void 0 === t && (t = "#000"), void 0 === e && (e = 0), void 0 === i && (i = 0), this.underlineColor = Qt(t, this.canvas, this.context), this.underlineThickness = e, this.underlineOffset = i, this.update(!1) } }, { key: "setUnderlineColor", value: function (t) { return void 0 === t && (t = "#000"), this.underlineColor = Qt(t, this.canvas, this.context), this.update(!1) } }, { key: "setUnderlineThickness", value: function (t) { return void 0 === t && (t = 0), this.underlineThickness = t, this.update(!1) } }, { key: "setUnderlineOffset", value: function (t) { return void 0 === t && (t = 0), this.underlineOffset = t, this.update(!1) } }, { key: "setWrapMode", value: function (t) { return "string" == typeof t && (t = Me[t.toLowerCase()] || 0), this.wrapMode = t, this.update(!0) } }, { key: "setWrapWidth", value: function (t) { return this.wrapWidth = t, this.update(!1) } }, { key: "setAlign", value: function (t, e) { return void 0 === t && (t = "left"), void 0 === e && (e = "top"), this.halign = t, this.valign = e, this.update(!1) } }, { key: "setHAlign", value: function (t) { return void 0 === t && (t = "left"), this.halign = t, this.update(!1) } }, { key: "setVAlign", value: function (t) { return void 0 === t && (t = "top"), this.valign = t, this.update(!1) } }, { key: "setMaxLines", value: function (t) { return void 0 === t && (t = 0), this.maxLines = t, this.update(!1) } }, { key: "getTextMetrics", value: function () { var t = this.metrics; return { ascent: t.ascent, descent: t.descent, fontSize: t.fontSize } } }, { key: "setTextMetrics", value: function (t, e) { return this.metrics.ascent = t.ascent, this.metrics.descent = t.descent, this.metrics.fontSize = t.fontSize, e && ("string" == typeof e ? (this.fontFamily = e, this.fontSize = "", this.fontStyle = "") : (this.fontFamily = Pe(e, "fontFamily", this.fontFamily), this.fontSize = Pe(e, "fontSize", this.fontSize), this.fontStyle = Pe(e, "fontStyle", this.fontStyle))), this.parent.updateText(!0) } }, { key: "lineHeight", get: function () { return this.metrics.fontSize + this.strokeThickness + this.lineSpacing } }, { key: "toJSON", value: function () { var t = {}; for (var e in Te) t[e] = this[e]; return t.metrics = this.getTextMetrics(), t } }, { key: "destroy", value: function () { this.parent = void 0 } }]), i }(), Me = { none: be, word: xe, char: Ce, character: Ce }, Ee = Phaser.Display.Canvas.CanvasPool, _e = { draw: function (t, e, i, n) { var s = this.penManager; this.hitAreaManager.clear(); var r = this.context; r.save(); var o = this.defaultStyle; this.clear(), ee(this, o.backgroundColor, o.backgroundStrokeColor, o.backgroundStrokeLineWidth, o.backgroundCornerRadius, o.backgroundColor2, o.backgroundHorizontalGradient, o.backgroundCornerIteration), t += this.startXOffset, e += this.startYOffset; var a, h, l, u, c, d, f = o.halign, p = o.valign, v = o.lineHeight, g = s.lines, y = g.length, m = o.maxLines; u = (l = 0 < m && m < y ? (h = m, "center" === p ? Math.floor((y - h) / 2) : "bottom" === p ? y - h : 0) : (h = y, 0)) + h; var k = this.rtl, b = k ? this.parent.width : void 0; d = "center" === p ? Math.max((n - h * v) / 2, 0) : "bottom" === p ? Math.max(n - h * v - 2, 0) : 0, d += e; for (var x = l; x < u; x++)if (0 !== (a = s.getLineWidth(x))) { for (var C = g[x], w = C.length, S = f, P = 0; P < w; P++) { var T = C[P].prop.align; if (void 0 !== T) { S = T; break } } c = "center" === S ? (i - a) / 2 : "right" === S ? k ? 0 : i - a : k ? i - a : 0, c += t; for (P = 0; P < w; P++)this.drawPen(C[P], c, d, b) } r.restore() }, drawPen: function (t, e, i, n) { e += t.x, i += t.y + (t.prop.y || 0), void 0 !== n && (e = n - e); var s = this.canvas, r = this.context; r.save(); var o = this.parser.propToContextStyle(this.defaultStyle, t.prop); o.buildFont(), o.syncFont(s, r), o.syncStyle(s, r), 0 < o.underlineThickness && 0 < t.width && this.drawUnderline(e, i, t.width, o), t.isTextPen && this.drawText(e, i, t.text, o), t.isImagePen && this.drawImage(e, i, t.prop.img, o), r.restore(), t.hasAreaMarker && 0 < t.width && this.hitAreaManager.add(t.prop.area, e, i - this.startYOffset, t.width, this.defaultStyle.lineHeight) }, clear: function () { var t = this.canvas; this.context.clearRect(0, 0, t.width, t.height) }, drawUnderline: function (t, e, i, n) { e += n.underlineOffset - n.underlineThickness / 2, this.autoRound && (t = Math.round(t), e = Math.round(e)); var s = this.context, r = s.lineCap; s.lineCap = "butt", s.strokeStyle = n.underlineColor, s.lineWidth = n.underlineThickness, s.beginPath(), s.moveTo(t, e), s.lineTo(t + i, e), s.stroke(), s.lineCap = r }, drawText: function (t, e, i, n) { this.autoRound && (t = Math.round(t), e = Math.round(e)); var s = this.context; n.stroke && "none" !== n.stroke && 0 < n.strokeThickness && (n.syncShadow(s, n.shadowStroke), s.strokeText(i, t, e)), n.color && "none" !== n.color && (n.syncShadow(s, n.shadowFill), s.fillText(i, t, e)) }, drawImage: function (t, e, i) { e -= this.startYOffset, this.parent.imageManager.draw(i, this.context, t, e, this.autoRound) } }, Be = Phaser.Utils.Objects.GetValue, Ie = ye, Re = me, Ae = function () { function e(t) { z(this, e), this.prop = {}, this.resetFromJSON(t) } return k(e, [{ key: "resetFromJSON", value: function (t) { this.text = Be(t, "text", ""), this.x = Be(t, "x", 0), this.y = Be(t, "y", 0), this.width = Be(t, "width", 0); var e = Be(t, "prop", null); null === e && (e = {}), this.prop = e, this.newLineMode = Be(t, "newLineMode", 0), this.startIndex = Be(t, "startIndex", 0) } }, { key: "plainText", get: function () { var t = this.text; return this.newLineMode === Re && (t += "\n"), t } }, { key: "wrapText", get: function () { var t = this.text; return this.newLineMode !== Ie && (t += "\n"), t } }, { key: "rawTextLength", get: function () { var t = this.text.length; return this.newLineMode === Re && (t += 1), t } }, { key: "endIndex", get: function () { return this.startIndex + this.rawTextLength } }, { key: "lastX", get: function () { return this.x + this.width } }, { key: "isTextPen", get: function () { return "" !== this.text } }, { key: "isImagePen", get: function () { return !!this.prop.img } }, { key: "hasAreaMarker", get: function () { return !!this.prop.area } }]), e }(), De = Phaser.Utils.Objects.GetFastValue, Le = ye, ze = ke, je = new G, Fe = new G, Ye = function () { function a(t) { z(this, a), this.pens = [], this.lines = [], this.maxLinesWidth = void 0, this.PensPool = De(t, "pensPool", je), this.LinesPool = De(t, "linesPool", Fe), this.tagToText = De(t, "tagToText", _), this.tagToTextScope = De(t, "tagToTextScope", void 0) } return k(a, [{ key: "destroy", value: function () { this.clear(), this.tagToText = void 0, this.tagToTextScope = void 0 } }, { key: "clear", value: function () { for (var t = 0, e = this.lines.length; t < e; t++)this.lines[t].length = 0; this.PensPool.pushMultiple(this.pens), this.LinesPool.pushMultiple(this.lines), this.maxLinesWidth = void 0 } }, { key: "addTextPen", value: function (t, e, i, n, s, r) { var o = this.PensPool.pop(); return null == o && (o = new Ae), We.text = t, We.x = e, We.y = i, We.width = n, We.prop = s, We.newLineMode = r, o.resetFromJSON(We), this.addPen(o), this } }, { key: "addImagePen", value: function (t, e, i, n) { return this.addTextPen("", t, e, i, n, Le), this } }, { key: "addNewLinePen", value: function () { var t = this.lastPen, e = t ? t.lastX : 0, i = t ? t.y : 0, n = t ? rt(t.prop) : null; return this.addTextPen("", e, i, 0, n, ze), this } }, { key: "addPen", value: function (t) { var e = this.lastPen; t.startIndex = null == e ? 0 : e.endIndex, this.pens.push(t); var i = this.lastLine; null == i && (i = this.LinesPool.pop() || [], this.lines.push(i)), i.push(t), t.newLineMode !== Le && (i = this.LinesPool.pop() || [], this.lines.push(i)), this.maxLinesWidth = void 0 } }, { key: "clone", value: function (t) { null == t && (t = new a), t.clear(); for (var e = 0, i = this.lines.length; e < i; e++)for (var n = this.lines[e], s = 0, r = n.length; s < r; s++) { var o = n[s]; t.addPen(o.text, o.x, o.y, o.width, rt(o.prop), o.newLineMode) } return t } }, { key: "lastPen", get: function () { return this.pens[this.pens.length - 1] } }, { key: "lastLine", get: function () { return this.lines[this.lines.length - 1] } }, { key: "getLineStartIndex", value: function (t) { if (t >= this.lines.length) return this.getLineEndIndex(t); var e = this.lines[t]; return e && e[0] ? e[0].startIndex : 0 } }, { key: "getLineEndIndex", value: function (t) { t >= this.lines.length && (t = this.lines.length - 1); var e, i, n = !1; for (e = t; 0 <= e && !(n = null != (i = this.lines[e]) && 0 < i.length); e--); return n ? i[i.length - 1].endIndex : 0 } }, { key: "getLineWidth", value: function (t) { var e = this.lines[t]; if (!e) return 0; var i = e[e.length - 1]; return null == i ? 0 : i.lastX } }, { key: "getMaxLineWidth", value: function () { if (void 0 !== this.maxLinesWidth) return this.maxLinesWidth; for (var t, e = 0, i = 0, n = this.lines.length; i < n; i++)e < (t = this.getLineWidth(i)) && (e = t); return this.maxLinesWidth = e } }, { key: "getLineWidths", value: function () { for (var t = [], e = 0, i = this.lines.length; e < i; e++)t.push(this.getLineWidth(e)); return t } }, { key: "linesCount", get: function () { return this.lines.length } }, { key: "plainText", get: function () { for (var t = "", e = this.pens, i = 0, n = e.length; i < n; i++)t += e[i].plainText; return t } }, { key: "rawTextLength", get: function () { for (var t = 0, e = this.pens, i = 0, n = this.pens.length; i < n; i++)t += e[i].rawTextLength; return t } }, { key: "getSliceTagText", value: function (t, e, i) { if (void 0 === t && (t = 0), void 0 === e) { var n = this.lastPen; if (null == n) return ""; e = n.endIndex } void 0 === i && (i = !1); for (var s, r, o, a, h, l, u = "", c = 0, d = this.pens.length; c < d && ((a = (s = this.pens[c]).endIndex) <= t || (s = this.pens[c], r = i ? s.wrapText : s.plainText, h = s.prop, t <= (o = s.startIndex) && a <= e || (r = r.substring(t - o, e - o)), this.tagToTextScope ? u += this.tagToText.call(this.tagToTextScope, r, h, l) : u += this.tagToText(r, h, l), l = h, !(e <= a))); c++); return u } }, { key: "length", get: function () { return this.lines.length }, set: function () { this.clear() } }]), a }(), We = {}, Ve = Phaser.Geom.Rectangle, Xe = new G, Ge = function () { function t() { z(this, t), this.hitAreas = [] } return k(t, [{ key: "destroy", value: function () { this.clear() } }, { key: "clear", value: function () { return Xe.pushMultiple(this.hitAreas), this } }, { key: "add", value: function (t, e, i, n, s) { var r = Xe.pop(); return null === r ? r = new Ve(e, i, n, s) : r.setTo(e, i, n, s), r.key = t, this.hitAreas.push(r), this } }, { key: "getFirst", value: function (t, e) { for (var i = 0, n = this.hitAreas.length; i < n; i++) { var s = this.hitAreas[i]; if (s.contains(t, e)) return s } return null } }, { key: "drawBounds", value: function (t, e, i) { void 0 === e && (e = 16777215), i && t.save().scaleCanvas(i.scaleX, i.scaleY).rotateCanvas(i.rotation).translateCanvas(i.x, i.y); for (var n = 0, s = this.hitAreas.length; n < s; n++) { var r = this.hitAreas[n]; t.lineStyle(1, e).strokeRect(r.x, r.y, r.width, r.height) } return i && t.restore(), this } }]), t }(), Ue = function (t, e, i, n) { var s = this.hitAreaManager.getFirst(e, i); null !== s && Je.call(this, "areadown", s.key, t, e, i, n) }, He = function (t, e, i, n) { var s = this.hitAreaManager.getFirst(e, i); null !== s && Je.call(this, "areaup", s.key, t, e, i, n) }, Ne = function (t, e, i, n) { if (null === e) return null !== this.lastHitAreaKey && Je.call(this, "areaout", this.lastHitAreaKey, t, e, i, n), void (this.lastHitAreaKey = null); var s = this.hitAreaManager.getFirst(e, i), r = s ? s.key : null; this.lastHitAreaKey !== r && (null !== this.lastHitAreaKey && Je.call(this, "areaout", this.lastHitAreaKey, t, e, i, n), null !== r && Je.call(this, "areaover", r, t, e, i, n), this.lastHitAreaKey = r) }, Je = function (t, e, i, n, s, r) { this.parent.emit("".concat(t, "-").concat(e), i, n, s, r), this.parent.emit(t, e, i, n, s, r) }, Ke = new G, qe = ye, $e = me, Ze = ke, Qe = be, ti = xe, ei = Ce, ii = we, ni = Phaser.Utils.Objects.GetValue, si = be, ri = ye, oi = function () { function i(t) { z(this, i), this.parent = t.parent, this.context = ni(t, "context", null), this.canvas = this.context.canvas, this.parser = ni(t, "parser", null), this.defaultStyle = ni(t, "style", null), this.autoRound = !0, this.pensPool = ni(t, "pensPool", null), this.penManager = this.newPenManager(), this._tmpPenManager = null, this.hitAreaManager = new Ge, this.lastHitAreaKey = null; var e = this.context; this.getTextWidth = function (t) { return e.measureText(t).width } } return k(i, [{ key: "destroy", value: function () { this.context = void 0, this.canvas = void 0, this.parser = void 0, this.defaultStyle = void 0, this.penManager && (this.penManager.destroy(), this.penManager = void 0), this._tmpPenManager && (this._tmpPenManager.destroy(), this._tmpPenManager = void 0), this.hitAreaManager && (this.hitAreaManager.destroy(), this.hitAreaManager = void 0) } }, { key: "updatePenManager", value: function (t, e, i, n, s) { if (void 0 === s && (s = this.penManager), s.clear(), "" === t) return s; var r = this.parent.style; if (r.isWrapFitMode) { var o = this.parent.padding; i = r.fixedWidth - o.left - o.right } function a(t) { return v.measureText(t).width } for (var h, l, u, c, d, f, p = this.canvas, v = this.context, g = 0, y = 0, m = r.wrapCallback, k = r.wrapCallbackScope, b = !0, x = this.parser.splitText(t), C = 0, w = x.length; C < w; C++)if (h = (c = this.parser.tagTextToProp(x[C], l)).plainText, (l = c.prop).img) { var S = this.imageManager.getOuterWidth(l.img); 0 < i && e !== si && i < g + S && (s.addNewLinePen(), y += n, g = 0), s.addImagePen(g, y, S, rt(l)), g += S } else if ("" !== h) { if (v.save(), (u = this.parser.propToContextStyle(this.defaultStyle, l)).buildFont(), u.syncFont(p, v), u.syncStyle(p, v), m) { "string" == typeof (d = m.call(k, h, a, i, g)) && (d = d.split("\n")); for (var P = 0, T = d.length; P < T; P++)"string" == typeof (O = d[P]) ? d[P] = de(O, a(O), P < T - 1 ? 2 : 0) : b = !1 } else d = fe(h, a, e, i, g); var O; for (P = 0, T = d.length; P < T; P++)O = d[P], s.addTextPen(O.text, g, y, O.width, rt(l), O.newLineMode), O.newLineMode !== ri ? (g = 0, y += n) : g += O.width; b && (f = d) && Ke.pushMultiple(f), d = null, v.restore() } for (C = 0, w = this.lines.length; C < w; C++) { var M = this.lines[C], E = M[M.length - 1]; E && (E.width += this.parser.getStrokeThinkness(this.defaultStyle, E.prop)) } return s } }, { key: "startXOffset", get: function () { var t = this.defaultStyle; return t.strokeThickness / 2 + t.xOffset } }, { key: "startYOffset", get: function () { var t = this.defaultStyle; return t.strokeThickness / 2 + t.metrics.ascent } }, { key: "lines", get: function () { return this.penManager.lines } }, { key: "desplayLinesCount", get: function () { var t = this.penManager.linesCount, e = this.defaultStyle.maxLines; return 0 < e && e < t && (t = e), t } }, { key: "linesWidth", get: function () { return Math.ceil(this.penManager.getMaxLineWidth()) } }, { key: "linesHeight", get: function () { var t = this.desplayLinesCount, e = this.defaultStyle.lineHeight * t; return 0 < t && (e -= this.defaultStyle.lineSpacing), e } }, { key: "imageManager", get: function () { return this.parent.imageManager } }, { key: "rtl", get: function () { return this.parent.style.rtl } }, { key: "newPenManager", value: function () { return new Ye({ pensPool: this.pensPool, tagToText: this.parser.propToTagText, tagToTextScope: this.parser }) } }, { key: "tmpPenManager", get: function () { return null === this._tmpPenManager && (this._tmpPenManager = this.newPenManager()), this._tmpPenManager } }, { key: "getPlainText", value: function (t, e, i) { var n; if (null == t) n = this.penManager.plainText; else { var s = this.parser.splitText(t, 1); n = ""; for (var r = 0, o = s.length; r < o; r++)n += s[r] } return null == e && null == i || (null == e && (e = 0), null == i && (i = n.length), n = n.substring(e, i)), n } }, { key: "getPenManager", value: function (t, e) { if (void 0 === t) return this.copyPenManager(e, this.penManager); void 0 === e && (e = this.newPenManager()); var i = this.defaultStyle; return this.updatePenManager(t, i.wrapMode, i.wrapWidth, i.lineHeight, e), e } }, { key: "getText", value: function (t, e, i, n) { if (null == t) return this.penManager.getSliceTagText(e, i, n); var s = this.tmpPenManager, r = this.defaultStyle; return this.updatePenManager(t, r.wrapMode, r.wrapWidth, r.lineHeight, s), s.getSliceTagText(e, i, n) } }, { key: "copyPenManager", value: function (t, e) { return void 0 === e && (e = this.penManager), e.copy(t) } }, { key: "getTextWidth", value: function (t) { return void 0 === t && (t = this.penManager), t.getMaxLineWidth() } }, { key: "getLastPen", value: function (t) { return void 0 === t && (t = this.penManager), t.lastPen } }]), i }(), ai = { setInteractive: function () { this.parent.on("pointerdown", Ue, this).on("pointerup", He, this).on("pointermove", Ne, this).on("pointerover", Ne, this).on("pointerout", function (t, e) { Ne.call(this, t, null, null, e) }, this) } }; Object.assign(oi.prototype, _e, ai); function hi(t, e) { void 0 === e && (e = { key: t }), e.hasOwnProperty("key") || (e.key = t); var i = e.key, n = e.frame, s = e.width, r = e.height; if (void 0 === s || void 0 === r) { var o = this.textureManager.getFrame(i, n), a = o ? o.cutWidth : 0, h = o ? o.cutHeight : 0; void 0 === s && void 0 === r ? (s = a, r = h) : void 0 === s ? s = a * (r / h) : void 0 === r && (r = h * (s / a)) } this.images[t] = { key: i, frame: n, width: s, height: r, y: li(e, "y", 0), left: li(e, "left", 0), right: li(e, "right", 0) } } var li = Phaser.Utils.Objects.GetValue, ui = function () { function e(t) { z(this, e), this.textureManager = t.sys.textures, this.images = {} } return k(e, [{ key: "destroy", value: function () { this.textureManager = void 0, this.images = void 0 } }, { key: "add", value: function (t, e) { if ("string" == typeof t) hi.call(this, t, e); else if (Array.isArray(t)) for (var i = 0, n = (s = t).length; i < n; i++)hi.call(this, s[i]); else { var s = t; for (var t in s) hi.call(this, t, s[t]) } return this } }, { key: "has", value: function (t) { return this.images.hasOwnProperty(t) } }, { key: "remove", value: function (t) { return this.has(t) && delete this.images[t], this } }, { key: "get", value: function (t) { return this.has(t) || this.textureManager.exists(t) && this.add(t), this.images[t] } }, { key: "getOuterWidth", value: function (t) { var e = this.get(t); return e ? e.width + e.left + e.right : 0 } }, { key: "getFrame", value: function (t) { var e = this.get(t); return e ? this.textureManager.getFrame(e.key, e.frame) : void 0 } }, { key: "hasTexture", value: function (t) { return !!this.getFrame(t) } }]), e }(), ci = { draw: function (t, e, i, n, s) { var r = this.get(t); i += r.left, n += r.y, s && (i = Math.round(i), n = Math.round(n)); var o = this.textureManager.getFrame(r.key, r.frame); e.drawImage(o.source.image, o.cutX, o.cutY, o.cutWidth, o.cutHeight, i, n, r.width, r.height) } }; Object.assign(ui.prototype, ci); var di = Phaser.Utils.Objects.IsPlainObject, fi = Phaser.DOM.AddToDOM, pi = Phaser.Display.Canvas.CanvasPool, vi = Phaser.GameObjects.GameObject, gi = Phaser.Utils.Objects.GetValue, yi = Phaser.DOM.RemoveFromDOM, mi = we, ki = {}, bi = function () { w(c, vi); var u = T(c); function c(t, e, i, n, s, r, o) { var a; if (z(this, c), di(e)) { var h = e; e = gi(h, "x", 0), i = gi(h, "y", 0), n = gi(h, "text", ""), s = gi(h, "style", "") } if (void 0 === e && (e = 0), void 0 === i && (i = 0), (a = u.call(this, t, r)).renderer = t.sys.game.renderer, a.setPosition(e, i), a.setOrigin(0, 0), a.initPipeline(), a.canvas = pi.create(j(a)), a.context = a.canvas.getContext("2d"), a._imageManager = void 0, s) { if (s.hasOwnProperty("align")) { var l = s.align; delete s.align, s.halign = l } s.hasOwnProperty("stroke") && !s.hasOwnProperty("strokeThickness") && (s.strokeThickness = 1) } return a.style = new Oe(j(a), s), a.autoRound = !0, a._text = void 0, a.padding = { left: 0, right: 0, top: 0, bottom: 0 }, a.width = 1, a.height = 1, a.dirty = !1, 0 === a.style.resolution && (a.style.resolution = 1), a._crop = a.resetCropObject(), a.texture = t.sys.textures.addCanvas(null, a.canvas, !0), a.frame = a.texture.get(), a.frame.source.resolution = a.style.resolution, a.renderer.gl && (a.renderer.deleteTexture(a.frame.source.glTexture), a.frame.source.glTexture = null), ki.hasOwnProperty(r) || (ki[r] = new G), a.canvasText = new oi({ parent: j(a), context: a.context, parser: o, style: a.style, pensPool: ki[r] }), a.parser = o, a.initRTL(), s && s.padding && a.setPadding(s.padding), a.setText(n), t.sys.game.events.on("contextrestored", a.onContextRestored, j(a)), a } return k(c, [{ key: "onContextRestored", value: function () { this.dirty = !0 } }, { key: "preDestroy", value: function () { this.style.rtl && yi(this.canvas), this.scene.sys.game.events.off("contextrestored", this.onContextRestored, this), this.canvasText.destroy(), this.canvasText = void 0, this._imageManager && (this._imageManager.destroy(), this._imageManager = void 0), pi.remove(this.canvas), this.texture.destroy() } }, { key: "text", get: function () { return this._text }, set: function (t) { this.setText(t) } }, { key: "initRTL", value: function () { this.style.rtl && (this.canvas.dir = "rtl", this.context.direction = "rtl", this.canvas.style.display = "none", fi(this.canvas, this.scene.sys.canvas), this.originX = 1) } }, { key: "setText", value: function (t) { return (t = null == t ? "" : Array.isArray(t) ? t.join("\n") : t.toString()) === this._text || (this._text = t, this.updateText()), this } }, { key: "appendText", value: function (t) { return null == t || (Array.isArray(t) && (t = t.join("\n")), this.setText(this.text + t.toString())), this } }, { key: "setStyle", value: function (t) { return this.style.setStyle(t) } }, { key: "setFont", value: function (t) { return this.style.setFont(t) } }, { key: "setFontFamily", value: function (t) { return this.style.setFontFamily(t) } }, { key: "setFontSize", value: function (t) { return this.style.setFontSize(t) } }, { key: "setFontStyle", value: function (t) { return this.style.setFontStyle(t) } }, { key: "setTestString", value: function (t) { return this.style.setTestString(t) } }, { key: "setFixedSize", value: function (t, e) { return this.style.setFixedSize(t, e) } }, { key: "setBackgroundColor", value: function (t, e, i) { return this.style.setBackgroundColor(t, e, i) } }, { key: "setBackgroundStrokeColor", value: function (t, e) { return this.style.setBackgroundStrokeColor(t, e) } }, { key: "setBackgroundCornerRadius", value: function (t, e) { return this.style.setBackgroundCornerRadius(t, e) } }, { key: "setFill", value: function (t) { return this.style.setFill(t) } }, { key: "setColor", value: function (t) { return this.style.setColor(t) } }, { key: "setStroke", value: function (t, e) { return this.style.setStroke(t, e) } }, { key: "setShadow", value: function (t, e, i, n, s, r) { return this.style.setShadow(t, e, i, n, s, r) } }, { key: "setShadowOffset", value: function (t, e) { return this.style.setShadowOffset(t, e) } }, { key: "setShadowColor", value: function (t) { return this.style.setShadowColor(t) } }, { key: "setShadowBlur", value: function (t) { return this.style.setShadowBlur(t) } }, { key: "setShadowStroke", value: function (t) { return this.style.setShadowStroke(t) } }, { key: "setShadowFill", value: function (t) { return this.style.setShadowFill(t) } }, { key: "setWrapMode", value: function (t) { return this.style.setWrapMode(t) } }, { key: "setWrapWidth", value: function (t) { return this.style.setWrapWidth(t) } }, { key: "setWordWrapWidth", value: function (t) { return this.style.setWrapWidth(t) } }, { key: "setAlign", value: function (t) { return this.style.setHAlign(t) } }, { key: "setHAlign", value: function (t) { return this.style.setHAlign(t) } }, { key: "setVAlign", value: function (t) { return this.style.setVAlign(t) } }, { key: "setLineSpacing", value: function (t) { return this.style.setLineSpacing(t) } }, { key: "setXOffset", value: function (t) { return this.style.setXOffset(t) } }, { key: "setPadding", value: function (t, e, i, n) { if ("object" === P(t)) { var s = t, r = gi(s, "x", null); i = null !== r ? t = r : (t = gi(s, "left", 0), gi(s, "right", t)); var o = gi(s, "y", null); n = null !== o ? e = o : (e = gi(s, "top", 0), gi(s, "bottom", e)) } else void 0 === t && (t = 0), void 0 === e && (e = t), void 0 === i && (i = t), void 0 === n && (n = e); return this.padding.left = t, this.padding.top = e, this.padding.right = i, this.padding.bottom = n, this.updateText(!1) } }, { key: "setMaxLines", value: function (t) { return this.style.setMaxLines(t) } }, { key: "setResolution", value: function (t) { return this.style.setResolution(t) } }, { key: "updateText", value: function (t) { void 0 === t && (t = !0); var e = this.canvasText, i = this.style; t && e.updatePenManager(this._text, i.wrapMode, i.wrapWidth, i.lineHeight); var n, s, r = this.padding, o = Math.ceil(e.linesWidth); 0 === i.fixedWidth ? (this.width = o + r.left + r.right, n = o) : (this.width = i.fixedWidth, (n = this.width - r.left - r.right) < o && (n = o)), 0 === i.fixedHeight ? (this.height = e.linesHeight + r.top + r.bottom, s = e.linesHeight) : (this.height = i.fixedHeight, (s = this.height - r.top - r.bottom) < e.linesHeight && (s = e.linesHeight)); var a = this.width, h = this.height; this.updateDisplayOrigin(); var l = i.resolution; a *= l, h *= l, a = Math.max(Math.ceil(a), 1), h = Math.max(Math.ceil(h), 1); var u = this.canvas, c = this.context; u.width !== a || u.height !== h ? (u.width = a, u.height = h, this.frame.setSize(a, h)) : c.clearRect(0, 0, a, h), c.save(), c.scale(l, l); var d = this.style.rtl ? r.right : r.left, f = r.top; e.draw(d, f, n, s), c.restore(), this.renderer && this.renderer.gl && (this.frame.source.glTexture = this.renderer.canvasToTexture(u, this.frame.source.glTexture, !0), this.frame.glTexture = this.frame.source.glTexture), this.dirty = !0; var p = this.input; return p && !p.customHitArea && (p.hitArea.width = this.width, p.hitArea.height = this.height), this } }, { key: "getTextMetrics", value: function () { return this.style.getTextMetrics() } }, { key: "setTextMetrics", value: function (t, e) { return this.style.setTextMetrics(t, e) } }, { key: "toJSON", value: function () { var t = xi.ToJSON(this), e = { autoRound: this.autoRound, text: this._text, style: this.style.toJSON(), resolution: this.resolution, padding: { left: this.padding.left, right: this.padding.right, top: this.padding.top, bottom: this.padding.bottom } }; return t.data = e, t } }, { key: "setInteractive", value: function (t, e, i) { var n = !!this.input; return vi.prototype.setInteractive.call(this, t, e, i), n || this.canvasText.setInteractive(), this } }, { key: "getWrappedText", value: function (t, e, i) { return (t = this.canvasText.getText(t, e, i, !0)).split(mi) } }, { key: "getPlainText", value: function (t, e, i) { return this.canvasText.getPlainText(t, e, i) } }, { key: "getText", value: function (t, e, i, n) { return void 0 === n && (n = !1), this.canvasText.getText(t, e, i, n) } }, { key: "getSubString", value: function (t, e, i) { return this.getText(t, e, i) } }, { key: "copyPenManager", value: function (t) { return this.canvasText.copyPenManager(t) } }, { key: "getPenManager", value: function (t, e) { return this.canvasText.getPenManager(t, e) } }, { key: "setSize", value: function (t, e) { return this.setFixedSize(t, e) } }, { key: "resize", value: function (t, e) { return this.setFixedSize(t, e) } }, { key: "lineSpacing", get: function () { return this.style.lineSpacing }, set: function (t) { this.setLineSpacing(t) } }, { key: "imageManager", get: function () { return this._imageManager || (this._imageManager = new ui(this.scene)), this._imageManager } }, { key: "addImage", value: function (t, e) { return this.imageManager.add(t, e), this } }, { key: "drawAreaBounds", value: function (t, e) { return this.canvasText.hitAreaManager.drawBounds(t, e, this), this } }, { key: "measureTextMargins", value: function (t, e) { return function (t, e, i) { void 0 === i && (i = {}); var n = Ee.create(this), s = n.getContext("2d"); t.syncFont(n, s); var r = s.measureText(e), o = Math.ceil(r.width * t.baselineX), a = o, h = 2 * a; if (a = a * t.baselineY | 0, n.width = o, n.height = h, s.fillStyle = "#f00", s.fillRect(0, 0, o, h), s.font = t._font, s.textBaseline = "alphabetic", s.fillStyle = "#000", s.fillText(t.testString, 0, a), (i.left = 0) === o || 0 == h || !s.getImageData(0, 0, o, h)) return Ee.remove(n), i; for (var l = s.getImageData(0, 0, o, h).data, u = !1, c = 0; c < o; c++) { for (var d = 0; d < h; d++) { if (255 !== l[4 * (d * o + c)]) { i.left = c, u = !0; break } } if (u) break } return Ee.remove(n), i }(this.style, t, e) } }, { key: "generateTexture", value: function (t, e, i, n, s) { var r = this.canvas; return void 0 === n ? n = r.width : n *= this.resolution, void 0 === s ? s = r.height : s *= this.resolution, Xt(this.scene, r, t, e, i, n, s), this } }]), c }(), xi = Phaser.GameObjects.Components; Phaser.Class.mixin(bi, [xi.Alpha, xi.BlendMode, xi.ComputedSize, xi.Crop, xi.Depth, xi.Flip, xi.GetBounds, xi.Mask, xi.Origin, xi.Pipeline, xi.ScrollFactor, xi.Tint, xi.Transform, xi.Visible, ve]); function Ci(t, e) { return void 0 === e ? "\\[".concat(t, "\\]") : "\\[".concat(t, "=(").concat(e, ")\\]") } function wi(t) { return "\\[/".concat(t, "\\]") } var Si = "[-.0-9]+", Pi = "[a-z]+|#[0-9abcdef]+", Ti = "[^\\]]+", Oi = Ci("esc"), Mi = wi("esc"), Ei = Ci("raw"), _i = wi("raw"), Bi = Ci("b"), Ii = wi("b"), Ri = Ci("i"), Ai = wi("i"), Di = Ci("weight", Si), Li = wi("weight"), zi = Ci("size", Si), ji = wi("size"), Fi = Ci("color", Pi), Yi = wi("color"), Wi = Ci("u"), Vi = Ci("u", Pi), Xi = wi("u"), Gi = Ci("shadow"), Ui = wi("shadow"), Hi = "stroke", Ni = Ci(Hi), Ji = Ci(Hi, Pi), Ki = wi(Hi), qi = Ci("y", Si), $i = wi("y"), Zi = Ci("img", Ti), Qi = wi("img"), tn = Ci("area", Ti), en = wi("area"), nn = Ci("align", Ti), sn = wi("align"), rn = new RegExp(Oi, "i"), on = new RegExp(Mi, "i"), an = new RegExp(Ei, "i"), hn = new RegExp(_i, "i"), ln = new RegExp(Bi, "i"), un = new RegExp(Ii, "i"), cn = new RegExp(Ri, "i"), dn = new RegExp(Ai, "i"), fn = new RegExp(Di, "i"), pn = new RegExp(Li, "i"), vn = new RegExp(zi, "i"), gn = new RegExp(ji, "i"), yn = new RegExp(Fi, "i"), mn = new RegExp(Yi, "i"), kn = new RegExp(Wi, "i"), bn = new RegExp(Vi, "i"), xn = new RegExp(Xi, "i"), Cn = new RegExp(Gi, "i"), wn = new RegExp(Ui, "i"), Sn = new RegExp(Ni, "i"), Pn = new RegExp(Ji, "i"), Tn = new RegExp(Ki, "i"), On = new RegExp(qi, "i"), Mn = new RegExp($i, "i"), En = new RegExp(Zi, "i"), _n = new RegExp(Qi, "i"), Bn = new RegExp(tn, "i"), In = new RegExp(en, "i"), Rn = new RegExp(nn, "i"), An = new RegExp(sn, "i"), Dn = new RegExp([Ei, _i, Oi, Mi, Bi, Ii, Ri, Ai, Di, Li, zi, ji, Fi, Yi, Wi, Vi, Xi, Gi, Ui, Ni, Ji, Ki, qi, $i, Zi, Qi, tn, en, nn, sn].join("|"), "ig"), Ln = { plainText: null, prevProp: null }, zn = function (t, e, i, n) { return !0 === e ? t[i] = n : t.hasOwnProperty(i) && delete t[i], t }, jn = function (t) { var e = t.b, i = t.weight, n = t.i; return e || i || n ? n ? e ? "bold italic" : i ? "".concat(i, " italic") : "italic" : e ? "bold" : i.toString() : "" }, Fn = new Oe, Yn = {}, Wn = function () { function t() { z(this, t) } return k(t, [{ key: "getStrokeThinkness", value: function (t, e) { return e.hasOwnProperty("stroke") ? t.strokeThickness : 0 } }]), t }(), Vn = { splitText: function (t, e) { for (var i = [], n = 0, s = !1, r = !1; ;) { var o = Dn.exec(t); if (!o) break; var a = o[0]; if (r) { if (!on.test(a)) continue; r = !1 } else if (s) { if (!hn.test(a)) continue; s = !1 } else rn.test(a) ? r = !0 : an.test(a) && (s = !0); var h = Dn.lastIndex, l = h - a.length; if (n < l) { var u = t.substring(n, l); i.push(u) } void 0 === e && i.push(a), n = h } var c = t.length; return n < c && i.push(t.substring(n, c)), i }, tagTextToProp: function (t, e) { null == e && (e = {}); var i = ""; if (e.img && zn(e, !1, "img"), e.esc) on.test(t) ? zn(e, !1, "esc") : i = t; else if (e.raw) hn.test(t) ? zn(e, !1, "raw") : i = t; else if (rn.test(t)) zn(e, !0, "esc", !0); else if (on.test(t)) zn(e, !1, "esc"); else if (an.test(t)) zn(e, !0, "raw", !0); else if (hn.test(t)) zn(e, !1, "raw"); else if (ln.test(t)) zn(e, !0, "b", !0); else if (un.test(t)) zn(e, !1, "b"); else if (cn.test(t)) zn(e, !0, "i", !0); else if (dn.test(t)) zn(e, !1, "i"); else if (fn.test(t)) { var n = t.match(fn); zn(e, !0, "weight", n[1]) } else if (pn.test(t)) zn(e, !1, "weight"); else if (vn.test(t)) { n = t.match(vn); zn(e, !0, "size", "".concat(n[1], "px")) } else if (gn.test(t)) zn(e, !1, "size"); else if (yn.test(t)) { n = t.match(yn); zn(e, !0, "color", n[1]) } else if (mn.test(t)) zn(e, !1, "color"); else if (kn.test(t)) zn(e, !0, "u", !0); else if (bn.test(t)) { n = t.match(bn); zn(e, !0, "u", n[1]) } else if (xn.test(t)) zn(e, !1, "u"); else if (Cn.test(t)) zn(e, !0, "shadow", !0); else if (wn.test(t)) zn(e, !1, "shadow"); else if (Sn.test(t)) zn(e, !0, "stroke", !0); else if (Pn.test(t)) { n = t.match(Pn); zn(e, !0, "stroke", n[1]) } else if (Tn.test(t)) zn(e, !1, "stroke"); else if (On.test(t)) { n = t.match(On); zn(e, !0, "y", parseFloat(n[1])) } else if (Mn.test(t)) zn(e, !1, "y"); else if (En.test(t)) { n = t.match(En); zn(e, !0, "img", n[1]) } else if (_n.test(t)) zn(e, !1, "img"); else if (Bn.test(t)) { n = t.match(Bn); zn(e, !0, "area", n[1]) } else if (In.test(t)) zn(e, !1, "area"); else if (Rn.test(t)) { n = t.match(Rn); zn(e, !0, "align", n[1]) } else An.test(t) ? zn(e, !1, "align") : i = t; var s = Ln; return s.plainText = i, s.prop = e, s }, propToContextStyle: function (t, e) { var i = Fn; if (e.hasOwnProperty("img")) i.image = e.img; else { if (i.image = null, e.hasOwnProperty("family") ? i.fontFamily = e.family : i.fontFamily = t.fontFamily, e.hasOwnProperty("size")) { var n = e.size; "number" == typeof n && (n = "".concat(n, "px")), i.fontSize = n } else i.fontSize = t.fontSize; i.fontStyle = jn(e), e.hasOwnProperty("color") ? i.color = e.color : i.color = t.color, e.hasOwnProperty("stroke") ? (!0 === e.stroke ? i.stroke = t.stroke : i.stroke = e.stroke, i.strokeThickness = t.strokeThickness) : (i.stroke = t.stroke, i.strokeThickness = 0) } return e.hasOwnProperty("shadow") ? (!0 === e.shadow ? i.shadowColor = t.shadowColor : i.shadowColor = e.shadow, i.shadowOffsetX = t.shadowOffsetX, i.shadowOffsetY = t.shadowOffsetY, i.shadowBlur = t.shadowBlur, i.shadowStroke = !0, i.shadowFill = !0) : (i.shadowColor = "#000", i.shadowOffsetX = 0, i.shadowOffsetY = 0, i.shadowBlur = 0, i.shadowStroke = !1, i.shadowFill = !1), e.hasOwnProperty("u") ? (!0 === e.u ? i.underlineColor = t.underlineColor : i.underlineColor = e.u, i.underlineThickness = t.underlineThickness, i.underlineOffset = t.underlineOffset) : (i.underlineColor = "#000", i.underlineThickness = 0, i.underlineOffset = 0), i }, propToTagText: function (t, e, i) { null == i && (i = Yn); var n = []; for (var s in i) e.hasOwnProperty(s) || n.push("[/".concat(s, "]")); for (var s in e) { var r = e[s]; if (i[s] !== r) switch (s) { case "size": n.push("[size=".concat(r.replace("px", ""), "]")); break; case "color": case "weight": case "stroke": case "y": case "img": case "area": case "align": n.push("[".concat(s, "=").concat(r, "]")); break; case "u": !0 === r ? n.push("[u]") : n.push("[u=".concat(r, "]")); break; default: n.push("[".concat(s, "]")) } } return n.push(t), n.join("") } }; Object.assign(Wn.prototype, Vn); var Xn = function () { w(a, bi); var o = T(a); function a(t, e, i, n, s) { z(this, a); var r = new Wn(s); return o.call(this, t, e, i, n, s, "rexBBCodeText", r) } return k(a) }(); c.register("BBCodeText", function (t, e, i, n) { var s = new Xn(this.scene, t, e, i, n); return this.scene.add.existing(s), s }), R(window, "RexPlugins.UI.BBCodeText", Xn); var Gn = { plainText: null, prevProp: null }, Un = new Oe, Hn = function () { function e(t) { z(this, e), void 0 === t && (t = {}), this.tags = t } return k(e, [{ key: "addTag", value: function (t, e) { this.tags[t] = e } }, { key: "getTag", value: function (t) { return this.tags[t] } }, { key: "splitText", value: function (t, e) { for (var i = [], n = 0; ;) { var s = Kn.exec(t); if (!s) break; var r = s[0], o = Kn.lastIndex - r.length; if (n < o && i.push(t.substring(n, o)), void 0 === e) i.push(r); else if (1 === e) if (qn.test(r)) { var a = r.match($n); i.push(a[2]) } else if (Zn.test(r)) { a = r.match(Qn); i.push(a[2]) } n = Kn.lastIndex } var h = t.length; return n < h && i.push(t.substring(n, h)), i } }, { key: "tagTextToProp", value: function (t) { var e, i; if (qn.test(t)) { if (null != (r = t.match($n))) { var n = r[1], s = this.tags; (i = s.hasOwnProperty(n) ? s[n] : {})._class = n, e = r[2] } } else if (Zn.test(t)) { var r; if (null != (r = t.match(Qn))) { var o = r[1]; (i = Nn(o))._style = o, e = r[2] } } null == e && (e = t), null == i && (i = {}); var a = Gn; return a.plainText = e, a.prop = i, a } }, { key: "propToContextStyle", value: function (t, e) { var i = Un; if (e.hasOwnProperty("img")) i.image = e.img; else { if (i.image = null, e.hasOwnProperty("family") || e.hasOwnProperty("fontFamily") || e.hasOwnProperty("font-family")) { var n = e.hasOwnProperty("family") ? e.family : e.hasOwnProperty("fontFamily") ? e.fontFamily : e["font-family"]; i.fontFamily = n } else i.fontFamily = t.fontFamily; if (e.hasOwnProperty("size") || e.hasOwnProperty("fontSize") || e.hasOwnProperty("font-size")) { var s = e.hasOwnProperty("size") ? e.size : e.hasOwnProperty("fontSize") ? e.fontSize : e["font-size"]; "number" == typeof s && (s = "".concat(s, "px")), i.fontSize = s } else i.fontSize = t.fontSize; if (e.hasOwnProperty("style") || e.hasOwnProperty("fontStyle") || e.hasOwnProperty("font-style")) { var r = e.hasOwnProperty("style") ? e.style : e.hasOwnProperty("fontStyle") ? e.fontStyle : e["font-style"]; i.fontStyle = r } else i.fontStyle = t.fontStyle; if (e.hasOwnProperty("color") || e.hasOwnProperty("font-color")) { var o = e.hasOwnProperty("color") ? e.color : e["font-color"]; i.color = o } else i.color = t.color; if (e.hasOwnProperty("stroke")) { var a = e.stroke; i.stroke = a.hasOwnProperty("color") ? a.color : t.stroke, i.strokeThickness = a.hasOwnProperty("thickness") ? a.thickness : t.strokeThickness } else i.stroke = t.stroke, i.strokeThickness = t.strokeThickness } if (e.hasOwnProperty("shadow")) { var h = e.shadow; i.shadowColor = h.hasOwnProperty("color") ? h.color : t.shadowColor, i.shadowOffsetX = h.hasOwnProperty("offsetX") ? h.offsetX : t.shadowOffsetX, i.shadowOffsetY = h.hasOwnProperty("offsetY") ? h.offsetY : t.shadowOffsetY, i.shadowBlur = h.hasOwnProperty("blur") ? h.blur : t.shadowBlur, i.shadowStroke = !0, i.shadowFill = !0 } else i.shadowColor = t.shadowColor, i.shadowOffsetX = t.shadowOffsetX, i.shadowOffsetY = t.shadowOffsetY, i.shadowBlur = t.shadowBlur, i.shadowStroke = t.shadowStroke, i.shadowFill = t.shadowFill; if (e.hasOwnProperty("u") || e.hasOwnProperty("underline")) { var l = e.hasOwnProperty("u") ? e.u : e.underline; i.underlineColor = l.hasOwnProperty("color") ? l.color : t.underlineColor, i.underlineThickness = l.hasOwnProperty("thickness") ? l.thickness : t.underlineThickness, i.underlineOffset = l.hasOwnProperty("offset") ? l.offset : t.underlineOffset } else i.underlineColor = t.underlineColor, i.underlineThickness = t.underlineThickness, i.underlineOffset = t.underlineOffset; return i } }, { key: "getStrokeThinkness", value: function (t, e) { var i; if (e.hasOwnProperty("stroke")) { var n = e.stroke; i = n.hasOwnProperty("thickness") ? n.thickness : t.strokeThickness } else i = t.strokeThickness; return i } }, { key: "propToTagText", value: function (t, e) { return e.hasOwnProperty("_class") ? "" === t && this.isTextTag(e._class) ? "" : "<class='".concat(e._class, "'>").concat(t, "</class>") : e.hasOwnProperty("_style") ? "<style='".concat(e._style, "'>").concat(t, "</style>") : t } }, { key: "destroy", value: function () { this.tags = void 0 } }, { key: "isTextTag", value: function (t) { var e = this.tags[t]; return !!e && null == e.img } }]), e }(), Nn = function (t) { for (var e, i, n, s = {}, r = 0, o = (t = t.split(";")).length; r < o; r++)if (i = (e = t[r].split(":"))[0], n = e[1], !Jn(i) && !Jn(n)) { switch (i) { case "stroke": var a = n.split(" "); n = {}, 1 <= (l = a.length) && (n.color = a[0]), 2 <= l && (n.thickness = parseInt(a[1].replace("px", ""))); break; case "shadow": var h = n.split(" "); n = {}, 1 <= (l = h.length) && (n.color = h[0]), 2 <= l && (n.offsetX = parseInt(h[1].replace("px", ""))), 3 <= l && (n.offsetY = parseInt(h[2].replace("px", ""))), 4 <= l && (n.blur = parseInt(h[3].replace("px", ""))); break; case "u": case "underline": var l, u = n.split(" "); n = {}, 1 <= (l = u.length) && (n.color = u[0]), 2 <= l && (n.thickness = parseInt(u[1].replace("px", ""))), 3 <= l && (n.offset = parseInt(u[2].replace("px", ""))); break; case "y": n = parseFloat(n) }s[i] = n } return s }, Jn = function (t) { return 0 === (t = t.replace(ts, "")).length }, Kn = /<\s*class=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/class\s*\>|<\s*style=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/style\s*\>/g, qn = /<\s*class=/i, $n = /<\s*class=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/class\s*\>/, Zn = /<\s*style=/i, Qn = /<\s*style=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/style\s*\>/, ts = /^\s+|\s+$/, es = Phaser.Utils.Objects.GetValue, is = function () { w(h, bi); var a = T(h); function h(t, e, i, n, s) { z(this, h); var r = es(s, "tags", void 0), o = new Hn(r); return a.call(this, t, e, i, n, s, "rexTagText", o) } return k(h, [{ key: "addTag", value: function (t, e) { return this.parser.addTag(t, e), this.updateText(!0) } }, { key: "addTags", value: function (t) { for (var e in t) this.parser.addTag(e, t[e]); return this.updateText(!0) } }, { key: "getTag", value: function (t) { return this.parser.getTag(t) } }, { key: "preDestroy", value: function () { O(C(h.prototype), "preDestroy", this).call(this), this.parser.destroy(), this.parser = void 0 } }]), h }(); c.register("tagText", function (t, e, i, n) { var s = new is(this.scene, t, e, i, n); return this.scene.add.existing(s), s }), R(window, "RexPlugins.UI.TagText", is); function ns(t, e, i) { var n, s; for (var r in void 0 === i && (i = {}), t) n = t[r], void 0 !== (s = rs(e, r, n[1])) && (i[n[0]] = s); return i } function ss(i, t, n) { function e(e) { t.addEventListener(e, function (t) { i.emit(n[e], i, t) }) } for (var s in n) e(s) } var rs = Phaser.Utils.Objects.GetValue, os = function (t) { t.stopPropagation() }, as = Phaser.GameObjects.DOMElement, hs = Phaser.Utils.Objects.IsPlainObject, ls = Phaser.Utils.Objects.GetValue, us = function () { w(p, as); var f = T(p); function p(t, e, i, n, s, r) { var o, a; z(this, p), hs(e) ? (e = ls(r = e, "x", 0), i = ls(r, "y", 0), n = ls(r, "width", 0), s = ls(r, "height", 0)) : hs(n) && (n = ls(r = n, "width", 0), s = ls(r, "height", 0)), void 0 === r && (r = {}); var h = ls(r, "type", "text"); "textarea" === h ? (a = document.createElement("textarea")).style.resize = "none" : (a = document.createElement("input")).type = h, ns(ps, r, a); var l = ls(r, "style", void 0); l = ns(vs, r, l); var u, c = a.style; for (var d in r) d in ps || d in vs || d in c && (l[d] = r[d]); return l["box-sizing"] = "border-box", (o = f.call(this, t, e, i, a, l)).type = "rexInputText", o.resize(n, s), ss(j(o), a, gs), (u = a).addEventListener("touchstart", os, !1), u.addEventListener("touchmove", os, !1), u.addEventListener("touchend", os, !1), u.addEventListener("mousedown", os, !1), u.addEventListener("mouseup", os, !1), u.addEventListener("mousemove", os, !1), ls(r, "selectAll", !1) && o.selectAll(), o._isFocused = !1, o.on("focus", function () { this._isFocused = !0 }, j(o)).on("blur", function () { this._isFocused = !1 }, j(o)), o } return k(p, [{ key: "text", get: function () { return this.node.value }, set: function (t) { this.node.value = t } }, { key: "setText", value: function (t) { return this.text = t, this } }, { key: "maxLength", get: function () { return this.node.maxLength }, set: function (t) { this.node.maxLength = t } }, { key: "setMaxLength", value: function (t) { return this.maxLength = t, this } }, { key: "minLength", get: function () { return this.node.minLength }, set: function (t) { this.node.minLength = t } }, { key: "setMinLength", value: function (t) { return this.minLength = t, this } }, { key: "placeholder", get: function () { return this.node.placeholder }, set: function (t) { this.node.placeholder = t } }, { key: "setPlaceholder", value: function (t) { return this.placeholder = t, this } }, { key: "selectText", value: function (t, e) { return void 0 === t ? this.node.select() : this.node.setSelectionRange(t, e), this } }, { key: "selectAll", value: function () { return this.selectText(), this } }, { key: "selectionStart", get: function () { return this.node.selectionStart } }, { key: "selectionEnd", get: function () { return this.node.selectionEnd } }, { key: "selectedText", get: function () { var t = this.node; return t.value.substring(t.selectionStart, t.selectionEnd) } }, { key: "cursorPosition", get: function () { return this.node.selectionStart }, set: function (t) { this.node.setSelectionRange(t, t) } }, { key: "setCursorPosition", value: function (t) { return void 0 === t && (t = 0), this.cursorPosition = t, this } }, { key: "tooltip", get: function () { return this.node.title }, set: function (t) { this.node.title = t } }, { key: "setTooltip", value: function (t) { return this.tooltip = t, this } }, { key: "setTextChangedCallback", value: function (t) { return this.onTextChanged = t, this } }, { key: "readOnly", get: function () { return this.node.readOnly }, set: function (t) { this.node.readOnly = t } }, { key: "setReadOnly", value: function (t) { return void 0 === t && (t = !0), this.readOnly = t, this } }, { key: "spellCheck", get: function () { return this.node.spellcheck }, set: function (t) { this.node.spellcheck = t } }, { key: "setSpellCheck", value: function (t) { return this.spellCheck = t, this } }, { key: "fontColor", get: function () { return this.node.style.color }, set: function (t) { this.node.style.color = t } }, { key: "setFontColor", value: function (t) { return this.fontColor = t, this } }, { key: "setStyle", value: function (t, e) { return this.node.style[t] = e, this } }, { key: "getStyle", value: function (t) { return this.node.style[t] } }, { key: "scrollToBottom", value: function () { return this.node.scrollTop = this.node.scrollHeight, this } }, { key: "setEnabled", value: function (t) { return void 0 === t && (t = !0), this.node.disabled = !t, this } }, { key: "setBlur", value: function () { return this.node.blur(), this } }, { key: "setFocus", value: function () { return this.node.focus(), this } }, { key: "isFocused", get: function () { return this._isFocused } }]), p }(), cs = { resize: function (t, e) { if (this.scene.sys.scale.autoRound && (t = Math.floor(t), e = Math.floor(e)), this.width === t && this.height === e) return this; var i = this.node.style; return i.width = "".concat(t, "px"), i.height = "".concat(e, "px"), this.updateSize(), this } }; Object.assign(us.prototype, cs); function ds(t, e, i, n) { if (e) return !(i && !i(t, e)) && (!!ys(t, e) && !(n && !n(t, e))); for (var s = t.scene.input.manager, r = s.pointersTotal, o = s.pointers, a = 0; a < r; a++)if (e = o[a], (!i || i(t, e)) && ys(t, e) && (!n || n(t, e))) return !0; return !1 } function fs(t, e, i) { t = t.replace(" ", ""); var n = i.previousText; if (t === n) return t; if (isNaN(t)) { t = n; var s = i.cursorPosition - 1; i.setText(t), i.setCursorPosition(s) } else i.previousText = t; return t } var ps = { id: ["id", void 0], text: ["value", void 0], maxLength: ["maxLength", void 0], minLength: ["minLength", void 0], placeholder: ["placeholder", void 0], tooltip: ["title", void 0], readOnly: ["readOnly", !1], spellCheck: ["spellcheck", !1], autoComplete: ["autocomplete", "off"] }, vs = { align: ["textAlign", void 0], paddingLeft: ["padding-left", void 0], paddingRight: ["padding-right", void 0], paddingTop: ["padding-top", void 0], paddingBottom: ["padding-bottom", void 0], fontFamily: ["fontFamily", void 0], fontSize: ["font-size", void 0], color: ["color", "#ffffff"], backgroundColor: ["backgroundColor", "transparent"], border: ["border", 0], borderColor: ["borderColor", "transparent"], outline: ["outline", "none"], direction: ["direction", void 0] }, gs = { input: "textchange", click: "click", dblclick: "dblclick", mousedown: "pointerdown", mousemove: "pointermove", mouseup: "pointerup", touchstart: "pointerdown", touchmove: "pointermove", touchend: "pointerup", keydown: "keydown", keyup: "keyup", keypress: "keypress", focus: "focus", blur: "blur", select: "select" }, ys = function (t, e) { for (var i = t.scene, n = i.input.cameras.getCamerasBelowPointer(e), s = i.input.manager, r = [t], o = 0, a = n.length; o < a; o++)if (0 < s.hitTest(e, r, n[o]).length) return !0; return !1 }, ms = Phaser.Utils.Objects.GetValue, ks = Phaser.Math.Wrap, bs = function () { w(o, us); var r = T(o); function o(t, e) { var i; z(this, o); var n = (i = r.call(this, t.scene, e)).node.style; n.position = "absolute", n.opacity = 0, n.pointerEvents = "none", n.zIndex = 0, n.transform = "scale(0)", i.setCursor(ms(e, "cursor", "|")), i.setCursorFlashDuration(ms(e, "cursorFlashDuration", 1e3)), i.cursorFlashTimer = 0, i.setEnterClose(ms(e, "enterClose", !0)), i.onOpenCallback = ms(e, "onOpen", void 0), i.onCloseCallback = ms(e, "onClose", void 0); var s = ms(e, "onUpdate", void 0); return "number" === s && (s = fs), i.onUpdateCallback = s, (i.textObject = t).setInteractive().on("pointerdown", i.setFocus, j(i)).on("destroy", i.destroy, j(i)), i.on("focus", function () { this.cursorFlashTimer = 0, this.enterClose && this.scene.input.keyboard.once("keydown-ENTER", this.setBlur, this), this.setText(this.textObject.text), this.scene.sys.events.on("postupdate", this.updateText, this), this.scene.input.on("pointerdown", this.onClickOutside, this), this.onOpenCallback && this.onOpenCallback(this.textObject, this) }, j(i)).on("blur", function () { this.updateText(), this.scene.sys.events.off("postupdate", this.updateText, this), this.scene.input.off("pointerdown", this.onClickOutside, this), this.onCloseCallback && this.onCloseCallback(this.textObject, this) }, j(i)), i } return k(o, [{ key: "preDestroy", value: function () { this.textObject.off("pointerdown", this.setFocus, this), this.textObject.off("destroy", this.destroy, this), this.scene.sys.events.off("postupdate", this.updateText, this), this.scene.input.off("pointerdown", this.onClickOutside, this), O(C(o.prototype), "preDestroy", this).call(this) } }, { key: "onClickOutside", value: function (t) { ds(this.textObject, t) || this.setBlur() } }, { key: "updateText", value: function () { var t = this.text; if (this.onUpdateCallback) { var e = this.onUpdateCallback(t, this.textObject, this); null != e && (t = e) } if (this.isFocused && this.hasCursor) { var i = this.cursorPosition; t = t.substring(0, i) + this.cursor + t.substring(i) } return this.textObject.setText(t), this } }, { key: "setCursor", value: function (t) { return this._cursor = t, this.hasCursor = t && "" !== t, t } }, { key: "setCursorFlashDuration", value: function (t) { return this.cursorFlashDuration = t, this } }, { key: "cursor", get: function () { if (!this._isFocused) return this._cursor; var t; t = this.cursorFlashTimer < this.cursorFlashDuration / 2 ? this._cursor : " "; var e = this.cursorFlashTimer + this.scene.game.loop.delta; return this.cursorFlashTimer = ks(e, 0, this.cursorFlashDuration), t } }, { key: "setEnterClose", value: function (t) { return void 0 === t && (t = !0), this.enterClose = t, this } }, { key: "open", value: function () { return this.setFocus(), this } }, { key: "close", value: function () { return this.setBlur(), this } }, { key: "isOpened", get: function () { return this._isFocused } }]), o }(); c.register("hiddenEdit", function (t, e) { return new bs(t, e) }), R(window, "RexPlugins.UI.HiddenEdit", bs); var xs = Phaser.GameObjects.Zone, Cs = Phaser.Utils.Array.Add, ws = Phaser.Utils.Array.Remove, Ss = function () { w(a, xs); var o = T(a); function a(t, e, i, n, s) { var r; return z(this, a), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 1), void 0 === s && (s = 1), (r = o.call(this, t, e, i, n, s)).children = [], r } return k(a, [{ key: "destroy", value: function (t) { if (this.scene) { if (t) for (var e, i = this.children.length - 1; 0 <= i; i--)(e = this.children[i]).parentContainer || e.displayList || e.destroy(t); this.clear(!t), O(C(a.prototype), "destroy", this).call(this, t) } } }, { key: "contains", value: function (t) { return -1 !== this.children.indexOf(t) } }, { key: "add", value: function (t) { var e = this; return Cs(this.children, t, 0, function (t) { t.once("destroy", e.onChildDestroy, e) }, this), this } }, { key: "remove", value: function (t, e) { var i = this; return ws(this.children, t, function (t) { t.off("destroy", i.onChildDestroy, i), e && t.destroy() }), this } }, { key: "onChildDestroy", value: function (t) { this.remove(t, !1) } }, { key: "clear", value: function (t) { for (var e, i = 0, n = this.children.length; i < n; i++)(e = this.children[i]).off("destroy", this.onChildDestroy, this), t && e.destroy(); return this.children.length = 0, this } }]), a }(), Ps = Phaser.GameObjects.Components; Phaser.Class.mixin(Ss, [Ps.Alpha, Ps.Flip]); function Ts(t, e) { var i; if (void 0 === e) t.hasOwnProperty("rexContainer") && (i = t.rexContainer.parent); else for (i = Ts(t); i && i.name !== e;)i = Ts(i); return i } function Os(t) { for (var e = Ts(t); e;)e = Ts(t = e); return t } function Ms(e) { if (!e.hasOwnProperty("rexContainer")) { var t = { parent: null, self: null, x: 0, y: 0, syncPosition: !0, rotation: 0, syncRotation: !0, scaleX: 0, scaleY: 0, syncScale: !0, alpha: 0, syncAlpha: !0, visible: !0, active: !0 }; Object.defineProperty(t, "angle", { get: function () { return js(this.rotation) }, set: function (t) { this.rotation = zs(t) } }), Object.defineProperty(t, "displayWidth", { get: function () { return e.width * this.scaleX }, set: function (t) { this.scaleX = t / e.width } }), Object.defineProperty(t, "displayHeight", { get: function () { return e.height * this.scaleY }, set: function (t) { this.scaleY = t / e.height } }), e.rexContainer = t } return e.rexContainer } function Es(t, e) { this.setParent(t); var i = Ms(t); return Vs(i, e), this.resetChildState(t).updateChildVisible(t).updateChildActive(t).updateChildScrollFactor(t).updateChildMask(t), Ws.call(this, t), this } function _s(t, e) { this.setParent(t); var i = Ms(t); return Vs(i, e), i.x = t.x, i.y = t.y, i.rotation = t.rotation, i.scaleX = t.scaleX, i.scaleY = t.scaleY, i.alpha = t.alpha, i.visible = t.visible, i.active = t.active, this.updateChildPosition(t).updateChildAlpha(t).updateChildVisible(t).updateChildActive(t).updateChildScrollFactor(t).updateChildMask(t), Ws.call(this, t), this } function Bs(t, e) { return t === e ? 1 : t / e } function Is(t, e) { if (0 === t.length) return t; void 0 === e && (e = !1); var i = t[0].scene.sys.displayList; return i.depthSort(), e ? t.sort(function (t, e) { return i.getIndex(e) - i.getIndex(t) }) : t.sort(function (t, e) { return i.getIndex(t) - i.getIndex(e) }), t } function Rs(t, e) { for (var i = [t]; 0 < i.length;) { var n = i.shift(); !e(n) && n.isRexContainerLite && i.push.apply(i, M(n.children)) } } function As(t) { for (var e = [], i = 0, n = t.length; i < n; i++) { var s = t[i]; s.hasOwnProperty("rexContainer") && e.push(s.rexContainer) } return e } function Ds(t, e, i) { if (i.parent) { var n = i.parent, s = i.self; switch (e) { case "x": case "y": n.updateChildPosition(s); break; case "angle": case "rotation": n.updateChildRotation(s); break; case "scaleX": case "scaleY": case "displayWidth": case "displayHeight": n.updateChildScale(s); break; case "alpha": n.updateChildAlpha(s); break; default: n.updateChildPosition(s), n.updateChildRotation(s), n.updateChildScale(s), n.updateChildAlpha(s) } } else t.remove() } function Ls(t) { var e = this.getAllChildren([this]); return Is(e), t.add(e), this } var zs = Phaser.Math.DegToRad, js = Phaser.Math.RadToDeg, Fs = { setParent: function (t, e) { void 0 === e && (e = this); var i = Ms(t); return e ? (i.parent = e, i.self = t) : (i.parent = null, i.self = null), this }, getParent: function (t, e) { return "string" == typeof t && (e = t, t = void 0), void 0 === t && (t = this), Ts(t, e) }, getTopmostParent: function (t) { return void 0 === t && (t = this), Os(t) } }, Ys = Phaser.Utils.Objects.GetValue, Ws = Ss.prototype.add, Vs = function (t, e) { t.syncPosition = Ys(e, "syncPosition", !0), t.syncRotation = Ys(e, "syncRotation", !0), t.syncScale = Ys(e, "syncScale", !0), t.syncAlpha = Ys(e, "syncAlpha", !0) }, Xs = { add: function (t) { return Array.isArray(t) ? this.addMultiple(t) : Es.call(this, t), this }, pin: function (t, e) { return Array.isArray(t) ? this.addMultiple(t, e) : Es.call(this, t, e), this }, addMultiple: function (t) { for (var e = 0, i = t.length; e < i; e++)Es.call(this, t[e]); return this }, addLocal: function (t) { return Array.isArray(t) ? this.addMultiple(t) : _s.call(this, t), this }, pinLocal: function (t, e) { return Array.isArray(t) ? this.addMultiple(t, e) : _s.call(this, t, e), this }, addLocalMultiple: function (t) { for (var e = 0, i = t.length; e < i; e++)_s.call(this, t[e]); return this } }, Gs = Ss.prototype.remove, Us = Ss.prototype.clear, Hs = { remove: function (t, e) { return Ts(t) !== this || (this.setParent(t, null), Gs.call(this, t, e)), this }, clear: function (t) { for (var e = 0, i = this.children.length; e < i; e++)this.setParent(this.children[e], null); return Us.call(this, t), this } }, Ns = { getLocalState: function (t) { return Ms(t) }, resetChildState: function (t) { return this.resetChildPositionState(t).resetChildVisibleState(t).resetChildAlphaState(t).resetChildActiveState(t), this }, resetChildrenState: function (t) { for (var e = 0, i = t.length; e < i; e++)this.resetChildState(t[e]); return this }, syncProperties: function () { return this.syncPosition().syncVisible().syncAlpha().syncActive().syncScrollFactor().syncMask(), this } }, Js = Phaser.Math.RotateAround, Ks = { worldToLocal: function (t) { return t.x -= this.x, t.y -= this.y, Js(t, 0, 0, -this.rotation), t.x /= this.scaleX, t.y /= this.scaleY, t }, localToWorld: function (t) { return t.x *= this.scaleX, t.y *= this.scaleY, Js(t, 0, 0, this.rotation), t.x += this.x, t.y += this.y, t } }, qs = { updateChildPosition: function (t) { t.isRexContainerLite && (t.syncChildrenEnable = !1); var e = Ms(t), i = e.parent; return e.syncPosition && (t.x = e.x, t.y = e.y, i.localToWorld(t)), e.syncRotation && (t.rotation = e.rotation + i.rotation), e.syncScale && (t.scaleX = e.scaleX * i.scaleX, t.scaleY = e.scaleY * i.scaleY), t.isRexContainerLite && (t.syncChildrenEnable = !0, t.syncPosition()), this }, syncPosition: function () { return this.syncChildrenEnable && this.children.forEach(this.updateChildPosition, this), this }, resetChildPositionState: function (t) { var e = Ms(t), i = e.parent; return e.x = t.x, e.y = t.y, i.worldToLocal(e), e.scaleX = Bs(t.scaleX, i.scaleX), e.scaleY = Bs(t.scaleY, i.scaleY), e.rotation = t.rotation - i.rotation, this }, setChildPosition: function (t, e, i) { return t.x = e, t.y = i, this.resetChildPositionState(t), this }, setChildLocalPosition: function (t, e, i) { var n = Ms(t); return n.x = e, n.y = i, this.updateChildPosition(t), this }, resetLocalPositionState: function () { var t = Ms(this).parent; return t && t.resetChildPositionState(this), this } }, $s = Phaser.Math.DegToRad, Zs = { updateChildRotation: function (t) { var e = Ms(t), i = e.parent; return e.syncRotation && (t.rotation = i.rotation + e.rotation), this }, syncRotation: function () { return this.syncChildrenEnable && this.children.forEach(this.updateChildRotation, this), this }, resetChildRotationState: function (t) { var e = Ms(t), i = e.parent; return e.rotation = t.rotation - i.rotation, this }, setChildRotation: function (t, e) { return t.rotation = e, this.resetChildRotationState(t), this }, setChildAngle: function (t, e) { return t.angle = e, this.resetChildRotationState(t), this }, setChildLocalRotation: function (t, e) { return Ms(t).rotation = e, this.updateChildRotation(t), this }, setChildLocalAngle: function (t, e) { return Ms(t).rotation = $s(e), this.updateChildRotation(t), this }, resetLocalRotationState: function () { var t = Ms(this).parent; return t && t.resetChildRotationState(this), this } }, Qs = { updateChildScale: function (t) { var e = Ms(t), i = e.parent; return e.syncScale && (t.scaleX = i.scaleX * e.scaleX, t.scaleY = i.scaleY * e.scaleY), this }, syncScale: function () { return this.syncChildrenEnable && this.children.forEach(this.updateChildScale, this), this }, resetChildScaleState: function (t) { var e = Ms(t), i = e.parent; return e.scaleX = Bs(t.scaleX, i.scaleX), e.scaleY = Bs(t.scaleY, i.scaleY), this }, setChildScale: function (t, e, i) { return void 0 === i && (i = e), t.scaleX = e, t.scaleY = i, this.resetChildScaleState(t), this }, setChildLocalScale: function (t, e, i) { void 0 === i && (i = e); var n = Ms(t); return n.scaleX = e, n.scaleY = i, this.updateChildScale(t), this }, setChildDisplaySize: function (t, e, i) { return t.setDisplaySize(e, i), this.resetChildScaleState(t), this }, resetLocalScaleState: function () { var t = Ms(this).parent; return t && t.resetChildScaleState(this), this } }, tr = { updateChildVisible: function (t) { var e = Ms(t), i = e.parent, n = !e.hasOwnProperty("maskVisible") || e.maskVisible; return t.visible = i.visible && e.visible && n, this }, syncVisible: function () { return this.syncChildrenEnable && this.children.forEach(this.updateChildVisible, this), this }, resetChildVisibleState: function (t) { var e = Ms(t); return e.hasOwnProperty("maskVisible") && delete e.maskVisible, e.visible = t.visible, this }, setChildVisible: function (t, e) { return this.setChildLocalVisible(t, e), this }, setChildLocalVisible: function (t, e) { return void 0 === e && (e = !0), Ms(t).visible = e, this.updateChildVisible(t), this }, setChildMaskVisible: function (t, e) { return void 0 === e && (e = !0), Ms(t).maskVisible = e, this.updateChildVisible(t), this }, resetLocalVisibleState: function () { var t = Ms(this).parent; return t && t.resetChildVisibleState(this), this } }, er = { updateChildAlpha: function (t) { var e = Ms(t), i = e.parent; return e.syncAlpha && (t.alpha = i.alpha * e.alpha), this }, syncAlpha: function () { return this.syncChildrenEnable && this.children.forEach(this.updateChildAlpha, this), this }, resetChildAlphaState: function (t) { var e = Ms(t), i = e.parent; return e.alpha = Bs(t.alpha, i.alpha), this }, setChildAlpha: function (t, e) { return t.alpha = e, this.resetChildAlphaState(t), this }, setChildLocalAlpha: function (t, e) { return Ms(t).alpha = e, this.updateChildAlpha(t), this }, resetLocalAlphaState: function () { var t = Ms(this).parent; return t && t.resetChildAlphaState(this), this } }, ir = { updateChildActive: function (t) { var e = Ms(t), i = e.parent; return t.active = i.active && e.active, this }, syncActive: function () { return this.syncChildrenEnable && this.children.forEach(this.updateChildActive, this), this }, resetChildActiveState: function (t) { return Ms(t).active = t.active, this }, setChildActive: function (t, e) { return t.active = e, this.resetChildActiveState(t), this }, setChildLocalActive: function (t, e) { return void 0 === e && (e = !0), Ms(t).active = e, this.updateChildActive(t), this }, resetLocalActiveState: function () { var t = Ms(this).parent; return t && t.resetChildActiveState(this), this } }, nr = { updateChildScrollFactor: function (t) { var e = Ms(t).parent; return t.setScrollFactor(e.scrollFactorX, e.scrollFactorY), this }, syncScrollFactor: function () { return this.syncChildrenEnable && this.children.forEach(this.updateChildScrollFactor, this), this } }, sr = { updateChildMask: function (t) { return null == this.mask || (this.mask.hasOwnProperty("geometryMask") ? this.mask.geometryMask : this.mask.bitmapMask) !== t && (t.mask = this.mask), this }, syncMask: function () { return this.syncChildrenEnable && this.children.forEach(this.updateChildMask, this), this }, setMask: function (t) { return this.mask = t, this }, clearMask: function (t) { return void 0 === t && (t = !1), this._mask = null, this.children.forEach(function (t) { t.clearMask(!1) }), t && this.mask && this.mask.destroy(), this } }, rr = { setDepth: function (t, e) { if (this.depth = t, !e && this.children) for (var i = this.getAllChildren(), n = 0, s = i.length; n < s; n++)i[n].depth = t; return this }, swapDepth: function (t) { var e = this.depth, i = t.depth; return this.setDepth(i), t.setDepth(e), this }, incDepth: function (t) { if (this.depth += t, this.children) for (var e = this.getAllChildren(), i = 0, n = e.length; i < n; i++)e[i].depth += t; return this }, moveDepthBelow: function (t) { var e = t.scene.children, i = this.getAllChildren([this]); Is(i); for (var n = 0, s = i.length; n < s; n++) { var r = i[n]; if (e.exists(r)) { e.moveBelow(t, r); break } } return this }, moveDepthAbove: function (t) { var e = t.scene.children, i = this.getAllChildren([this]); Is(i, !0); for (var n = 0, s = i.length; n < s; n++) { var r = i[n]; if (e.exists(r)) { e.moveAbove(t, r); break } } return this } }, or = Phaser.Utils.Array, ar = { getChildren: function (t) { if (t) for (var e = 0, i = this.children.length; e < i; e++)t.push(this.children[e]); else t = this.children; return t }, getAllChildren: function (e) { void 0 === e && (e = []); var i = this; return Rs(i, function (t) { t !== i && e.push(t) }), e }, getAllVisibleChildren: function (e) { void 0 === e && (e = []); var i = this; return Rs(i, function (t) { if (t !== i) return !t.visible || void e.push(t) }), e }, bfs: function (t, e) { return void 0 === e && (e = this), Rs(e, t), this }, dfs: function (t, e) { return void 0 === e && (e = this), function t(e, i) { if (!i(e) && e.isRexContainerLite) for (var n = e.children, s = 0, r = n.length; s < r; s++)t(n[s], i) }(e, t), this }, contains: function (t) { var e = Ts(t); return !!e && (e === this || this.contains(e)) }, getByName: function (t, e) { if (e) { for (var i, n, s = [this]; s.length;)for (var r = 0, o = (i = s.shift()).children.length; r < o; r++) { if ((n = i.children[r]).name === t) return n; n.isRexContainerLite && s.push(n) } return null } return or.GetFirst(this.children, "name", t) }, getRandom: function (t, e) { return or.GetRandom(this.children, t, e) }, getFirst: function (t, e, i, n) { return or.GetFirstElement(this.children, t, e, i, n) }, getAll: function (t, e, i, n) { return or.GetAll(this.children, t, e, i, n) }, count: function (t, e, i, n) { return or.CountAllMatching(this.children, t, e, i, n) }, swap: function (t, e) { return or.Swap(this.children, t, e), this }, setAll: function (t, e, i, n) { return or.SetAll(this.children, t, e, i, n), this } }, hr = { tweenChild: function (t) { var e = t.targets; Array.isArray(e) || (e = [e]); var i = this.scene || function (t) { for (var e = 0, i = t.length; e < i; e++) { var n = t[e].scene; if (n) return n } return null }(e); if (i) { t.targets = As(e); var n = i.tweens.add(t); return n.on("update", Ds), n } }, createTweenChildConfig: function (t) { var e = t.targets; e && (Array.isArray(e) || (e = [e]), t.targets = As(e)); var i = t.onUpdate; return t.onUpdate = function (t, e) { i && i(t, e), Ds(t, void 0, e) }, t }, tween: function (t) { var e = this.scene; return t.targets || (t.targets = this), e.tweens.add(t) }, timelineChild: function (t) { var e = t.targets; e && (Array.isArray(e) || (e = [e]), t.targets = As(e)); for (var i = t.tweens, n = 0, s = i.length; n < s; n++)i[n] = this.createTweenChildConfig(i[n]); return this.scene.tweens.timeline(t) } }, lr = { addToLayer: Ls, addToContainer: Ls }, ur = Phaser.Math.RotateAround, cr = { changeOrigin: function (t, e) { this.syncChildrenEnable = !1, function (t, e, i) { void 0 === i && (i = e); var n = { x: (e - t.originX) * t.displayWidth, y: (i - t.originY) * t.displayHeight }; ur(n, 0, 0, t.rotation), t.originX = e, t.originY = i, t.x = t.x + n.x, t.y = t.y + n.y }(this, t, e), this.syncChildrenEnable = !0; for (var i = this.getAllChildren(), n = 0, s = i.length; n < s; n++)this.resetChildPositionState(i[n]); return this } }; Object.assign(cr, Fs, Xs, Hs, Ns, Ks, qs, Zs, Qs, tr, er, ir, nr, sr, rr, ar, hr, lr); var dr = function () { w(h, Ss); var a = T(h); function h(t, e, i, n, s, r) { var o; return z(this, h), (o = a.call(this, t, e, i, n, s)).type = "rexContainerLite", o.isRexContainerLite = !0, o.syncChildrenEnable = !0, o._active = !0, o._mask = null, o._scrollFactorX = 1, o._scrollFactorY = 1, r && o.add(r), o } return k(h, [{ key: "destroy", value: function (t) { this.scene && (this.syncChildrenEnable = !1, O(C(h.prototype), "destroy", this).call(this, t)) } }, { key: "resize", value: function (t, e) { return this.setSize(t, e), this } }, { key: "x", get: function () { return this._x }, set: function (t) { this._x !== t && (this._x = t, this.syncPosition()) } }, { key: "y", get: function () { return this._y }, set: function (t) { this._y !== t && (this._y = t, this.syncPosition()) } }, { key: "rotation", get: function () { return O(C(h.prototype), "rotation", this) }, set: function (t) { this.rotation !== t && (e(C(h.prototype), "rotation", t, this, !0), this.syncPosition()) } }, { key: "scaleX", get: function () { return O(C(h.prototype), "scaleX", this) }, set: function (t) { this.scaleX !== t && (e(C(h.prototype), "scaleX", t, this, !0), this.syncPosition()) } }, { key: "scaleY", get: function () { return O(C(h.prototype), "scaleY", this) }, set: function (t) { this.scaleY !== t && (e(C(h.prototype), "scaleY", t, this, !0), this.syncPosition()) } }, { key: "scale", get: function () { return O(C(h.prototype), "scale", this) }, set: function (t) { this.scale !== t && (e(C(h.prototype), "scale", t, this, !0), this.syncPosition()) } }, { key: "visible", get: function () { return O(C(h.prototype), "visible", this) }, set: function (t) { O(C(h.prototype), "visible", this) !== t && (e(C(h.prototype), "visible", t, this, !0), this.syncVisible()) } }, { key: "alpha", get: function () { return O(C(h.prototype), "alpha", this) }, set: function (t) { O(C(h.prototype), "alpha", this) !== t && (e(C(h.prototype), "alpha", t, this, !0), this.syncAlpha()) } }, { key: "active", get: function () { return this._active }, set: function (t) { this._active !== t && (this._active = t, this.syncActive()) } }, { key: "mask", get: function () { return this._mask }, set: function (t) { this._mask !== t && (this._mask = t, this.syncMask()) } }, { key: "scrollFactorX", get: function () { return this._scrollFactorX }, set: function (t) { this._scrollFactorX !== t && (this._scrollFactorX = t, this.syncScrollFactor()) } }, { key: "scrollFactorY", get: function () { return this._scrollFactorY }, set: function (t) { this._scrollFactorY !== t && (this._scrollFactorY = t, this.syncScrollFactor()) } }, { key: "list", get: function () { return this.children } }], [{ key: "GetParent", value: function (t) { return Ts(t) } }]), h }(); Object.assign(dr.prototype, cr), c.register("container", function (t, e, i, n, s) { var r = new dr(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r }), R(window, "RexPlugins.UI.Container", dr), c.register("canvas", function (t, e, i, n) { var s = new $t(this.scene, t, e, i, n); return this.scene.add.existing(s), s }), R(window, "RexPlugins.UI.Canvas", $t); var fr = Phaser.Utils.Objects.GetValue, pr = function () { w(h, $t); var a = T(h); function h(t, e, i, n, s, r) { var o; return z(this, h), (o = a.call(this, t, e, i)).type = "rexCircleMaskImage", o.setTexture(n, s, r), o } return k(h, [{ key: "setTexture", value: function (t, e, i) { var n, s; if ("object" === P(e) && (i = e, e = void 0), s = "string" == typeof i ? void (n = i) : (n = fr(i, "maskType", 0), fr(i, "backgroundColor", void 0)), void 0 === n ? n = 0 : "string" == typeof n && (n = vr[n]), this._textureKey = t, this._frameName = e, null === n) return this.loadTexture(t, e), this.dirty = !0, this; var r = null != s; r || this.loadTexture(t, e); var o = this.canvas, a = this.context, h = o.width, l = o.height; switch (a.save(), a.globalCompositeOperation = r ? "source-over" : "destination-in", a.beginPath(), n) { case 2: var u = fr(i, "radius", 0), c = fr(i, "iteration", void 0); te(a, 0, 0, h, l, u, c); break; default: var d = Math.floor(h / 2), f = Math.floor(l / 2); 0 === n ? a.arc(d, f, Math.min(d, f), 0, 2 * Math.PI) : a.ellipse(d, f, d, f, 0, 0, 2 * Math.PI) }return r && (a.fillStyle = s), a.fill(), a.restore(), r && (a.save(), a.globalCompositeOperation = "destination-atop", this.loadTexture(t, e), a.restore()), this.dirty = !0, this } }, { key: "resize", value: function (t, e) { return this.setDisplaySize(t, e), this } }]), h }(), vr = { circle: 0, ellipse: 1, roundRectangle: 2 }; c.register("circleMaskImage", function (t, e, i, n, s) { var r = new pr(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r }), R(window, "RexPlugins.UI.CircleMaskImage", pr); var gr = function () { function i(t, e) { z(this, i), this.setParent(t), this.type = e, this.reset().setActive() } return k(i, [{ key: "destroy", value: function () { this.parent.removeChild(this) } }, { key: "setParent", value: function (t) { return this.parent = t, this } }, { key: "scene", get: function () { return this.parent.scene } }, { key: "canvas", get: function () { return this.parent ? this.parent.canvas : null } }, { key: "context", get: function () { return this.parent ? this.parent.context : null } }, { key: "setDirty", value: function (t) { return t && this.parent && (this.parent.dirty = !0), this } }, { key: "active", get: function () { return this._active }, set: function (t) { this.setDirty(this._active != t), this._active = t } }, { key: "setActive", value: function (t) { return void 0 === t && (t = !0), this.active = t, this } }, { key: "modifyPorperties", value: function () { return this } }, { key: "onFree", value: function () { this.reset().setParent() } }, { key: "reset", value: function () { return this } }]), i }(); Object.assign(gr.prototype, ot); function yr(t, e, i) { return e.hasOwnProperty(t) ? e[t] : i[t] } function mr(t, e) { return void 0 === e ? t : t[e] } function kr(t, e, i) { var n = P(e); "string" === n ? t[e] = i : "number" === n ? (t.left = e, t.right = e, t.top = e, t.bottom = e) : (t.left = Yr(e, "left", 0), t.right = Yr(e, "right", 0), t.top = Yr(e, "top", 0), t.bottom = Yr(e, "bottom", 0)) } function br(t) { var e = t.type; return e === Wr || e === Vr } function xr(t) { return t.type === Wr && "\n" === t.text } function Cr(t, e) { e && this.textStyle.modify(e); for (var i = [], n = 0, s = t.length; n < s; n++) { var r = t.charAt(n), o = this.poolManager.allocate(Wr); null === o ? o = new Gr(this, r, this.textStyle) : o.setParent(this).setActive().modifyStyle(this.textStyle).setText(r), i.push(o) } return this.addChild(i), this } function wr(t, e, i) { var n = this.poolManager.allocate(Vr); return null === n ? n = new Ur(this, t, e) : n.setParent(this).setActive().setTexture(t, e), n.modifyPorperties(i), this.addChild(n), this } function Sr(t, e, i, n) { var s = this.poolManager.allocate(Xr); return null === s ? s = new Hr(this, t, e, i, n) : s.setParent(this).setActive().setName(t).setCallback(e, n).setParameter(i), this.addChild(s), this } function Pr(t, e, i, n) { void 0 === n && (n = { word: [], width: 0 }), n.word.length = 0; for (var s = t.length, r = e, o = n.word, a = 0; r < s;) { var h = t[r]; if (br(h)) { if (h.type !== Wr || " " === h.text || "\n" === h.text) { r === e && (o.push(h), a += h.outerWidth); break } if (o.push(h), a += h.outerWidth, r++, i) break } else o.push(h), r++ } return n.width = a, n } function Tr(t, e, i) { if (0 !== e || 0 !== i) for (var n = 0, s = t.length; n < s; n++) { var r = t[n]; br(r) && (r.x += e, r.y += i) } } function Or(t) { for (var e = 0, i = t.length; e < i; e++) { var n = t[e]; if (void 0 !== n.align) return n.align } } function Mr(t) { var e, i = Nr(t, "start", 0), n = Nr(t, "padding.top", 0), s = Nr(t, "padding.bottom", 0), r = Nr(t, "lineHeight", void 0); if (void 0 === r) e = Nr(t, "maxLines", 0), r = 0 < this.fixedHeight ? (o = this.fixedHeight - this.padding.top - this.padding.bottom - n - s) / e : 0; else if (0 < this.fixedHeight) { if (void 0 === (e = Nr(t, "maxLines", void 0))) { var o = this.fixedHeight - this.padding.top - this.padding.bottom - n - s; e = Math.floor(o / r) } } else e = Nr(t, "maxLines", 0); var a = 0 === e, h = Nr(t, "wrapWidth", void 0); void 0 === h && (h = 0 < this.fixedWidth ? this.fixedWidth - this.padding.left - this.padding.right : 1 / 0); for (var l = Nr(t, "letterSpacing", 0), u = Nr(t, "hAlign", 0), c = Nr(t, "vAlign", 0), d = Nr(t, "charWrap", !1), f = { start: i, isLastPage: !1, padding: { top: n, bottom: s }, lineHeight: r, maxLines: e, wrapWidth: h, letterSpacing: l, hAlign: u, vAlign: c, charWrap: d, children: [], lines: [], maxLineWidth: 0, linesHeight: 0 }, p = this.children, v = 0, g = p.length; v < g; v++)p[v].setActive(!1); h += l; for (var y, m = this.padding.left, k = m, b = this.padding.top + r + n, x = h, C = i, w = p.length, S = f.children, P = f.lines, T = [], O = 0, M = 0; C < w;) { var E = (y = Pr(p, C, d, y)).word, _ = E.length, B = y.width + _ * l; C += _; var I = xr(E[0]); if (x < B || I) { if (I) { var R = E[0]; R.setActive().setPosition(k, b), S.push(R), T.push(R) } if (k = m, b += r, x = h, P.push({ children: T, width: O }), M = Math.max(M, O), O = 0, T = [], !a && P.length === e) break; if (I) continue } x -= B, O += B; for (v = 0, g = E.length; v < g; v++) { var A = E[v]; A.setActive(), S.push(A), T.push(A), br(A) && (A.setPosition(k, b), k += A.outerWidth + l) } } 0 < T.length && (P.push({ children: T, width: O }), M = Math.max(M, O)), f.start += S.length, f.isLastPage = f.start === w, f.maxLineWidth = M, f.linesHeight = P.length * r + n + s; var D = 0 < this.fixedWidth ? this.fixedWidth : f.maxLineWidth + this.padding.left + this.padding.right, L = 0 < this.fixedHeight ? this.fixedHeight : f.linesHeight + this.padding.top + this.padding.bottom; return function (t, e, i) { var n, s, r = t.hAlign, o = t.vAlign, a = t.linesHeight; switch (o) { case 1: case "center": s = (i - a) / 2; break; case 2: case "bottom": s = i - a; break; default: s = 0 }for (var h = t.lines, l = 0, u = h.length; l < u; l++) { var c = h[l], d = c.width, f = c.children, p = Or(f); switch (void 0 === p && (p = r), p) { case 1: case "center": n = (e - d) / 2; break; case 2: case "right": n = e - d; break; default: n = 0 }Tr(f, n, s) } }(f, D - this.padding.left - this.padding.right, o = L - this.padding.top - this.padding.bottom - n - s), this.setSize(D, L), f } function Er(t) { var e, i = Kr(t, "start", 0), n = Kr(t, "padding.top", 0), s = Kr(t, "padding.bottom", 0), r = Kr(t, "padding.left", 0), o = Kr(t, "padding.right", 0), a = Kr(t, "lineWidth", void 0); if (void 0 === a) e = Kr(t, "maxLines", 0), a = 0 < this.fixedWidth ? (h = this.fixedWidth - this.padding.left - this.padding.right - r - o) / e : 0; else if (0 < this.fixedWidth) { if (void 0 === (e = Kr(t, "maxLines", void 0))) { var h = this.fixedWidth - this.padding.left - this.padding.right; e = Math.floor(h / a) } } else e = Kr(t, "maxLines", 0); var l = 0 === e, u = Kr(t, "fixedChildHeight", void 0); if (void 0 === u) { var c = Kr(t, "charPerLine", void 0); if (void 0 !== c) { var d = this.fixedHeight - this.padding.top - this.padding.bottom - n - s; u = Math.floor(d / c) } } var f = Kr(t, "wrapHeight", void 0); void 0 === f && (f = 0 < this.fixedHeight ? this.fixedHeight - this.padding.top - this.padding.bottom : 1 / 0); for (var p = Kr(t, "letterSpacing", 0), v = Kr(t, "rtl", !0), g = { start: i, isLastPage: !1, padding: { top: n, bottom: s, left: r, right: o }, lineWidth: a, maxLines: e, fixedChildHeight: u, wrapHeight: f, letterSpacing: p, hAlign: Kr(t, "hAlign", v ? 2 : 0), vAlign: Kr(t, "vAlign", 0), rtl: v, children: [], lines: [], maxLineHeight: 0, linesWidth: 0 }, y = this.children, m = 0, k = y.length; m < k; m++)y[m].setActive(!1); f += p; for (var b = this.padding.left + r, x = this.padding.top + n, C = b, w = x, S = f, P = i, T = y.length, O = g.children, M = g.lines, E = [], _ = 0, B = 0; P < T;) { var I = y[P]; if (P++, br(I)) { var R = (void 0 !== u ? u : I.height) + p, A = xr(I); if (S < R || A) { if (A && (I.setActive().setPosition(C, w).setOrigin(.5), O.push(I), E.push(I)), C = b, w = x, S = f, M.push({ children: E, height: _ }), B = Math.max(B, _), _ = 0, E = [], !l && M.length === e) break; if (A) continue } S -= R, _ += R, I.setActive().setPosition(C, w).setOrigin(.5), O.push(I), E.push(I), w += R } else I.setActive(), O.push(I), E.push(I) } 0 < E.length && (M.push({ children: E, height: _ }), B = Math.max(B, _)), g.start += O.length, g.isLastPage = g.start === T, g.maxLineHeight = B, g.linesWidth = M.length * a + r + o; var D = 0 < this.fixedWidth ? this.fixedWidth : g.linesWidth + this.padding.left + this.padding.right, L = 0 < this.fixedHeight ? this.fixedHeight : g.maxLineHeight + this.padding.top + this.padding.bottom; return function (t, e, i) { var n, s, r = t.hAlign, o = t.vAlign, a = t.rtl, h = t.lines, l = t.lineWidth, u = t.linesWidth; switch (r) { case 1: case "center": n = (e - u) / 2; break; case 2: case "right": n = e - u; break; default: n = 0 }a && (n += l); for (var c = 0, d = h.length; c < d; c++) { var f = h[a ? d - c - 1 : c], p = f.children, v = f.height, g = GetChildrenAlign(p); switch (void 0 === g && (g = o), g) { case 1: case "center": s = (i - v) / 2; break; case 2: case "bottom": s = i - v; break; default: s = 0 }Tr(p, n, s), n += l } }(g, h = D - this.padding.left - this.padding.right - r - o, d = L - this.padding.top - this.padding.bottom - n - s), this.setSize(D, L), g } var _r = Phaser.Math.DegToRad, Br = Phaser.Math.RadToDeg, Ir = Phaser.Utils.Objects.GetValue, Rr = function () { w(s, gr); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, t, e)).originX = 0, i.offsetX = 0, i.offsetY = 0, i } return k(s, [{ key: "visible", get: function () { return this._visible }, set: function (t) { this.setDirty(this._visible != t), this._visible = t } }, { key: "setVisible", value: function (t) { return void 0 === t && (t = !0), this.visible = t, this } }, { key: "alpha", get: function () { return this._alpha }, set: function (t) { this.setDirty(this._alpha != t), this._alpha = t } }, { key: "setAlpha", value: function (t) { return this.alpha = t, this } }, { key: "x", get: function () { return this._x }, set: function (t) { this.setDirty(this._x != t), this._x = t } }, { key: "setX", value: function (t) { return this.x = t, this } }, { key: "y", get: function () { return this._y }, set: function (t) { this.setDirty(this._y != t), this._y = t } }, { key: "setY", value: function (t) { return this.y = t, this } }, { key: "setPosition", value: function (t, e) { return this.x = t, this.y = e, this } }, { key: "rotation", get: function () { return this._rotation }, set: function (t) { this.setDirty(this._rotation != t), this._rotation = t } }, { key: "setRotation", value: function (t) { return this.rotation = t, this } }, { key: "angle", get: function () { return Br(this._rotation) }, set: function (t) { this.rotation = _r(t) } }, { key: "setAngle", value: function (t) { return this.angle = t, this } }, { key: "scaleX", get: function () { return this._scaleX }, set: function (t) { this.setDirty(this._scaleX !== t), this._scaleX = t } }, { key: "setScaleX", value: function (t) { return this.scaleX = t, this } }, { key: "width", get: function () { return 0 }, set: function () { } }, { key: "setWidth", value: function (t, e) { return void 0 === e && (e = !1), this.width = t, e && (this.scaleY = this.scaleX), this } }, { key: "leftSpace", get: function () { return this._leftSpace }, set: function (t) { this.setDirty(this._leftSpace !== t), this._leftSpace = t } }, { key: "setLeftSpace", value: function (t) { return this.leftSpace = t, this } }, { key: "rightSpace", get: function () { return this._rightSpace }, set: function (t) { this.setDirty(this._rightSpace !== t), this._rightSpace = t } }, { key: "setRightSpace", value: function (t) { return this.rightSpace = t, this } }, { key: "outerWidth", get: function () { return this.width + this.leftSpace + this.rightSpace } }, { key: "scaleY", get: function () { return this._scaleY }, set: function (t) { this.setDirty(this._scaleY !== t), this._scaleY = t } }, { key: "setScaleY", value: function (t) { return this.scaleY = t, this } }, { key: "height", get: function () { return 0 }, set: function () { } }, { key: "setHeight", value: function (t, e) { return void 0 === e && (e = !1), this.height = t, e && (this.scaleX = this.scaleY), this } }, { key: "setScale", value: function (t, e) { return void 0 === e && (e = t), this.scaleX = t, this.scaleY = e, this } }, { key: "setOrigin", value: function (t) { return this.originX = t, this } }, { key: "setAlign", value: function (t) { return this.align = t, this } }, { key: "modifyPorperties", value: function (t) { if (!t) return this; t.hasOwnProperty("x") && this.setX(t.x), t.hasOwnProperty("y") && this.setY(t.y), t.hasOwnProperty("rotation") ? this.setRotation(t.rotation) : t.hasOwnProperty("angle") && this.setAngle(t.angle), t.hasOwnProperty("alpha") && this.setAlpha(t.alpha); var e = Ir(t, "width", void 0), i = Ir(t, "height", void 0), n = Ir(t, "scaleX", void 0), s = Ir(t, "scaleY", void 0); return void 0 !== e ? void 0 === i && void 0 === s ? this.setWidth(e, !0) : this.setWidth(e) : void 0 !== n && this.setScaleX(n), void 0 !== i ? void 0 === e && void 0 === n ? this.setHeight(i, !0) : this.setHeight(i) : void 0 !== s && this.setScaleY(s), t.hasOwnProperty("leftSpace") && this.setLeftSpace(t.leftSpace), t.hasOwnProperty("rightSpace") && this.setRightSpace(t.rightSpace), t.hasOwnProperty("align") && this.setAlign(t.align), this } }, { key: "setDrawBelowCallback", value: function (t) { return this.drawBelowCallback = t, this } }, { key: "setDrawAboveCallback", value: function (t) { return this.drawAboveCallback = t, this } }, { key: "reset", value: function () { return this.setVisible().setAlpha(1).setPosition(0, 0).setRotation(0).setScale(1, 1).setLeftSpace(0).setRightSpace(0).setOrigin(0).setAlign().setDrawBelowCallback().setDrawAboveCallback(), this } }, { key: "drawContent", value: function () { } }, { key: "draw", value: function () { var t = this.context; t.save(); var e = this.x + this.leftSpace + this.offsetX - this.originX * this.width, i = this.y + this.offsetY; this.autoRound && (e = Math.round(e), i = Math.round(i)), t.translate(e, i), t.globalAlpha = this.alpha, t.scale(this.scaleX, this.scaleY), t.rotate(this.rotation), this.drawBelowCallback && this.drawBelowCallback(this), this.drawContent(), this.drawAboveCallback && this.drawAboveCallback(this), t.restore() } }]), s }(), Ar = Phaser.Utils.Objects.GetValue, Dr = function () { w(s, Rr); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, t, "background")).setColor(Ar(e, "color", null), Ar(e, "color2", null), Ar(e, "horizontalGradient", !0)), i.setStroke(Ar(e, "stroke", null), Ar(e, "strokeThickness", 2)), i.setCornerRadius(Ar(e, "cornerRadius", 0), Ar(e, "cornerIteration", null)), i } return k(s, [{ key: "color", get: function () { return this._color }, set: function (t) { t = Qt(t, this.canvas, this.context), this.setDirty(this._color != t), this._color = t } }, { key: "color2", get: function () { return this._color2 }, set: function (t) { t = Qt(t, this.canvas, this.context), this.setDirty(this._color2 != t), this._color2 = t } }, { key: "horizontalGradient", get: function () { return this._horizontalGradient }, set: function (t) { this.setDirty(this._horizontalGradient != t), this._horizontalGradient = t } }, { key: "setColor", value: function (t, e, i) { return void 0 === i && (i = !0), this.color = t, this.color2 = e, this.horizontalGradient = i, this } }, { key: "stroke", get: function () { return this._stroke }, set: function (t) { t = Qt(t, this.canvas, this.context), this.setDirty(this._stroke != t), this._stroke = t } }, { key: "strokeThickness", get: function () { return this._strokeThickness }, set: function (t) { this.setDirty(this._strokeThickness != t), this._strokeThickness = t } }, { key: "setStroke", value: function (t, e) { return this.stroke = t, this.strokeThickness = e, this } }, { key: "cornerRadius", get: function () { return this._cornerRadius }, set: function (t) { this.setDirty(this._cornerRadius != t), this._cornerRadius = t } }, { key: "cornerIteration", get: function () { return this._cornerIteration }, set: function (t) { this.setDirty(this._cornerIteration != t), this._cornerIteration = t } }, { key: "setCornerRadius", value: function (t, e) { return this.cornerRadius = t, this.cornerIteration = e, this } }, { key: "drawContent", value: function () { ee(this.parent, this.color, this.stroke, this.strokeThickness, this.cornerRadius, this.color2, this.horizontalGradient, this.cornerIteration) } }]), s }(), Lr = Phaser.Utils.Objects.GetValue, zr = function () { w(s, Rr); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, t, "background")).setColor(Lr(e, "color", null), Lr(e, "color2", null), Lr(e, "horizontalGradient", !0)), i.setStroke(Lr(e, "stroke", null), Lr(e, "strokeThickness", 2)), i } return k(s, [{ key: "color", get: function () { return this._color }, set: function (t) { t = Qt(t, this.canvas, this.context), this.setDirty(this._color != t), this._color = t } }, { key: "color2", get: function () { return this._color2 }, set: function (t) { t = Qt(t, this.canvas, this.context), this.setDirty(this._color2 != t), this._color2 = t } }, { key: "horizontalGradient", get: function () { return this._horizontalGradient }, set: function (t) { this.setDirty(this._horizontalGradient != t), this._horizontalGradient = t } }, { key: "setColor", value: function (t, e, i) { return void 0 === i && (i = !0), this.color = t, this.color2 = e, this.horizontalGradient = i, this } }, { key: "stroke", get: function () { return this._stroke }, set: function (t) { t = Qt(t, this.canvas, this.context), this.setDirty(this._stroke != t), this._stroke = t } }, { key: "strokeThickness", get: function () { return this._strokeThickness }, set: function (t) { this.setDirty(this._strokeThickness != t), this._strokeThickness = t } }, { key: "setStroke", value: function (t, e) { return this.stroke = t, this.strokeThickness = e, this } }, { key: "drawContent", value: function () { var t = this.parent.padding, e = t.left, i = t.top, n = this.parent.width - t.left - t.right, s = this.parent.height - t.top - t.bottom, r = this.context; if (null != this.color) { var o, a; if (null != this.color2) (a = this.horizontalGradient ? r.createLinearGradient(0, 0, n, 0) : r.createLinearGradient(0, 0, 0, s)).addColorStop(0, this.color), a.addColorStop(1, this.color2), o = a; else o = this.color; r.fillStyle = o, r.fillRect(e, i, n, s) } null != this.stroke && 0 < this.strokeThickness && (r.strokeStyle = this.stroke, r.lineWidth = this.strokeThickness, r.strokeRect(e, i, n, s)) } }]), s }(), jr = Phaser.Utils.Objects.GetValue, Fr = function () { function e(t) { z(this, e), this.set(t) } return k(e, [{ key: "toJSON", value: function () { return { bold: this.bold, italic: this.italic, fontSize: this.fontSize, fontFamily: this.fontFamily, color: this.color, stroke: this.stroke, strokeThickness: this.strokeThickness, shaodwColor: this.shadowColor, shadowBlur: this.shadowBlur, shadowOffsetX: this.shadowOffsetX, shadowOffsetY: this.shadowOffsetY, offsetX: this.offsetX, offsetY: this.offsetY, leftSpace: this.leftSpace, rightSpace: this.rightSpace, align: this.align } } }, { key: "set", value: function (t) { return this.setBold(jr(t, "bold", !1)), this.setItalic(jr(t, "italic", !1)), this.setFontSize(jr(t, "fontSize", "16px")), this.setFontFamily(jr(t, "fontFamily", "Courier")), this.setColor(jr(t, "color", "#fff")), this.setStrokeStyle(jr(t, "stroke", null), jr(t, "strokeThickness", 0)), this.setShadow(jr(t, "shadowColor", null), jr(t, "shadowOffsetX", 0), jr(t, "shadowOffsetY", 0), jr(t, "shadowBlur", 0)), this.setOffset(jr(t, "offsetX", 0), jr(t, "offsetY", 0)), this.setSpace(jr(t, "leftSpace", 0), jr(t, "rightSpace", 0)), this.setAlign(jr(t, "align", void 0)), this } }, { key: "modify", value: function (t) { return t.hasOwnProperty("bold") && this.setBold(t.bold), t.hasOwnProperty("italic") && this.setItalic(t.italic), t.hasOwnProperty("fontSize") && this.setFontSize(t.fontSize), t.hasOwnProperty("fontFamily") && this.setFontFamily(t.fontFamily), t.hasOwnProperty("color") && this.setColor(t.color), (t.hasOwnProperty("stroke") || t.hasOwnProperty("strokeThickness")) && this.setStrokeStyle(yr("stroke", t, this), yr("strokeThickness", t, this)), t.hasOwnProperty("shadowColor") && this.setShadowColor(t.shadowColor), (t.hasOwnProperty("shadowOffsetX") || t.hasOwnProperty("shadowOffsetY")) && this.setShadowOffset(yr("shadowOffsetX", t, this), yr("shadowOffsetY", t, this)), t.hasOwnProperty("shadowBlur") && this.setShadowBlur(t.shaodwBlur), t.hasOwnProperty("offsetX") && this.setOffsetX(t.offsetX), t.hasOwnProperty("offsetY") && this.setOffsetY(t.offsetY), t.hasOwnProperty("leftSpace") && this.setLeftSpace(t.leftSpace), t.hasOwnProperty("rightSpace") && this.setRightSpace(t.rightSpace), t.hasOwnProperty("align") && this.setAlign(t.align), this } }, { key: "clone", value: function () { return new e(this.toJSON()) } }, { key: "copyFrom", value: function (t) { return this.set(t.toJSON()), this } }, { key: "copyTo", value: function (t) { return t.set(this.toJSON()), this } }, { key: "setBold", value: function (t) { return void 0 === t && (t = !0), this.bold = t, this } }, { key: "setItalic", value: function (t) { return void 0 === t && (t = !0), this.italic = t, this } }, { key: "fontStyle", get: function () { return this.bold && this.italic ? "bold italic" : this.bold ? "bold" : this.italic ? "italic" : "" } }, { key: "setFontSize", value: function (t) { return "number" == typeof t && (t = "".concat(t, "px")), this.fontSize = t, this } }, { key: "setFontFamily", value: function (t) { return this.fontFamily = t, this } }, { key: "font", get: function () { return "".concat(this.fontStyle, " ").concat(this.fontSize, " ").concat(this.fontFamily) } }, { key: "setColor", value: function (t) { return this.color = Qt(t), this } }, { key: "hasFill", get: function () { return null != this.color } }, { key: "setStrokeStyle", value: function (t, e) { return this.stroke = Qt(t), void 0 !== e && (this.strokeThickness = e), this } }, { key: "setStrokeThickness", value: function (t) { return this.strokeThickness = t, this } }, { key: "hasStroke", get: function () { return null != this.stroke && 0 < this.strokeThickness } }, { key: "setShadowColor", value: function (t) { return this.shadowColor = Qt(t), this } }, { key: "setShadowOffset", value: function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = 0), this.shadowOffsetX = t, this.shadowOffsetY = e, this } }, { key: "setShadowBlur", value: function (t) { return void 0 === t && (t = 0), this.shaodwBlur = t, this } }, { key: "setShadow", value: function (t, e, i, n) { return this.setShadowColor(t).setShadowOffset(e, i).setShadowBlur(n), this } }, { key: "setOffsetX", value: function (t) { return void 0 === t && (t = 0), this.offsetX = t, this } }, { key: "setOffsetY", value: function (t) { return void 0 === t && (t = 0), this.offsetY = t, this } }, { key: "setOffset", value: function (t, e) { return this.setOffsetX(t).setOffsetY(e), this } }, { key: "setLeftSpace", value: function (t) { return void 0 === t && (t = 0), this.leftSpace = t, this } }, { key: "setRightSpace", value: function (t) { return void 0 === t && (t = 0), this.rightSpace = t, this } }, { key: "setSpace", value: function (t, e) { return this.setLeftSpace(t).setRightSpace(e), this } }, { key: "setAlign", value: function (t) { return this.align = t, this } }, { key: "syncFont", value: function (t) { return t.font = this.font, this } }, { key: "syncStyle", value: function (t) { t.textBaseline = "alphabetic"; var e = this.hasFill, i = this.hasStroke; return t.fillStyle = e ? this.color : "#000", t.strokeStyle = i ? this.stroke : "#000", t.lineWidth = i ? this.strokeThickness : 0, t.lineCap = "round", t.lineJoin = "round", this } }, { key: "syncShadow", value: function (t) { null != t.shadowColor ? (t.shadowColor = this.shadowColor, t.shadowOffsetX = this.shadowOffsetX, t.shadowOffsetY = this.shadowOffsetY, t.shadowBlur = this.shadowBlur) : (t.shadowColor = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0, t.shadowBlur = 0) } }, { key: "getTextMetrics", value: function (t, e) { return this.syncFont(t).syncStyle(t), t.measureText(e) } }]), e }(), Yr = Phaser.Utils.Objects.GetValue, Wr = "text", Vr = "image", Xr = "command", Gr = function () { w(r, Rr); var s = T(r); function r(t, e, i) { var n; return z(this, r), (n = s.call(this, t, Wr)).style = new Fr(i), n.setText(e), n } return k(r, [{ key: "autoRound", get: function () { return this.parent.autoRound } }, { key: "offsetX", get: function () { return this.style.offsetX }, set: function (t) { this.style && (this.style.offsetX = t) } }, { key: "offsetY", get: function () { return this.style.offsetY }, set: function (t) { this.style && (this.style.offsetY = t) } }, { key: "leftSpace", get: function () { return this.style.leftSpace * this.scaleX }, set: function (t) { this.style && (this.style.leftSpace = t), e(C(r.prototype), "leftSpace", t, this, !0) } }, { key: "rightSpace", get: function () { return this.style.rightSpace * this.scaleX }, set: function (t) { this.style && (this.style.rightSpace = t), e(C(r.prototype), "rightSpace", t, this, !0) } }, { key: "align", get: function () { return this.style.align }, set: function (t) { this.style && (this.style.align = t) } }, { key: "modifyStyle", value: function (t) { return this.setDirty(!0), this.style.modify(t), this } }, { key: "modifyPorperties", value: function (t) { return t && (this.modifyStyle(t), O(C(r.prototype), "modifyPorperties", this).call(this, t)), this } }, { key: "setText", value: function (t) { return this.setDirty(this.text != t), this.text = t, this.updateTextSize(), this } }, { key: "updateTextSize", value: function () { if ("\n" === this.text || "" === this.text) this.textWidth = 0, this.textHeight = 0; else { var t, e, i = this.style.getTextMetrics(this.context, this.text); this.textWidth = i.width, e = i.hasOwnProperty("actualBoundingBoxAscent") ? (t = i.actualBoundingBoxAscent, i.actualBoundingBoxDescent) : t = 0, this.textHeight = t + e } return this } }, { key: "width", get: function () { return this.textWidth * this.scaleX }, set: function (t) { 0 < this.textWidth ? this.scaleX = t / this.textWidth : this.scaleX = 1 } }, { key: "height", get: function () { return this.textHeight * this.scaleY }, set: function (t) { 0 < this.textHeight ? this.scaleY = t / this.textHeight : this.scaleY = 1 } }, { key: "drawContent", value: function () { var t = this.style, e = t.hasFill, i = t.hasStroke; if (e || i) { var n = this.context; t.syncFont(n).syncStyle(n), i && (t.syncShadow(n), n.strokeText(this.text, 0, 0)), e && (t.syncShadow(n), n.fillText(this.text, 0, 0)) } } }, { key: "draw", value: function () { if (!this.visible || "" === this.text || "\n" === this.text) return this; O(C(r.prototype), "draw", this).call(this) } }]), r }(), Ur = function () { w(r, Rr); var s = T(r); function r(t, e, i) { var n; return z(this, r), (n = s.call(this, t, Vr)).setTexture(e, i), n } return k(r, [{ key: "frameWidth", get: function () { return this.frameObj ? this.frameObj.cutWidth : 0 } }, { key: "frameHeight", get: function () { return this.frameObj ? this.frameObj.cutHeight : 0 } }, { key: "offsetY", get: function () { return -this.height }, set: function () { } }, { key: "key", get: function () { return this._key }, set: function (t) { this.setDirty(this._key != t), this._key = t } }, { key: "frame", get: function () { return this._frame }, set: function (t) { this.setDirty(this._frame != t), this._frame = t } }, { key: "setTexture", value: function (t, e) { return this.key = t, this.frame = e, this.frameObj = this.scene.sys.textures.getFrame(t, e), this } }, { key: "width", get: function () { return this.frameWidth * this.scaleX }, set: function (t) { this.setDirty(this.width !== t), this.scaleX = t / this.frameWidth } }, { key: "height", get: function () { return this.frameHeight * this.scaleY }, set: function (t) { this.setDirty(this.height !== t), this.scaleY = t / this.frameHeight } }, { key: "setHeight", value: function (t, e) { return void 0 === e && (e = !1), this.height = t, e && (this.scaleX = this.scaleY), this } }, { key: "drawContent", value: function () { var t = this.context, e = this.frameObj, i = this.frameWidth, n = this.frameHeight; t.drawImage(e.source.image, e.cutX, e.cutY, i, n, 0, 0, i, n) } }, { key: "draw", value: function () { if (!this.visible) return this; O(C(r.prototype), "draw", this).call(this) } }]), r }(), Hr = function () { w(a, gr); var o = T(a); function a(t, e, i, n, s) { var r; return z(this, a), (r = o.call(this, t, Xr)).setName(e).setParameter(n).setCallback(i, s), r } return k(a, [{ key: "setName", value: function (t) { return this.name = t, this } }, { key: "setParameter", value: function (t) { return this.param = t, this } }, { key: "setCallback", value: function (t, e) { return this.callback = t, this.scope = e, this } }, { key: "exec", value: function () { return this.scope ? this.callback.call(this.scope, this.param, this.name) : this.callback(this.param, this.name) } }, { key: "draw", value: function () { } }, { key: "onFree", value: function () { O(C(a.prototype), "onFree", this).call(this), this.setName().setCallback().setParameter() } }]), a }(), Nr = Phaser.Utils.Objects.GetValue, Jr = Phaser.Utils.Objects.Merge, Kr = Phaser.Utils.Objects.GetValue, qr = Phaser.Utils.Objects.Merge, $r = Phaser.Utils.Array.GetAll, Zr = { setFixedSize: function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = 0), 0 < t && 0 < e && this.fixedWidth === t && this.fixedHeight === e || (this.dirty = !0), this.fixedWidth = t, this.fixedHeight = e, this }, setPadding: function (t, e) { var i = this.padding, n = i.left, s = i.right, r = i.top, o = i.bottom; return kr(i, t, e), this.dirty = this.dirty || n != i.left || s != i.right || r != i.top || o != i.bottom, this }, getPadding: function (t) { return mr(this.padding, t) }, modifyTextStyle: function (t) { return this.textStyle.modify(t), this }, resetTextStyle: function () { return this.textStyle.copyFrom(this.defaultTextStyle), this }, removeChild: function (t) { return this.poolManager.free(t), RemoveItem(this.children.list, t), this.lastAppendedChildren.length = 0, this.dirty = !0, this }, removeChildren: function () { return this.poolManager.freeMultiple(this.children), this.children.length = 0, this.lastAppendedChildren.length = 0, this.dirty = !0, this }, clearContent: function () { return this.setText(), this }, addChild: function (t) { var e, i; (this.lastAppendedChildren.length = 0, Array.isArray(t)) ? ((e = this.children).push.apply(e, M(t)), (i = this.lastAppendedChildren).push.apply(i, M(t))) : (this.children.push(t), this.lastAppendedChildren.push(t)); return this }, setText: function (t, e) { return void 0 === t && (t = ""), this.removeChildren(), Cr.call(this, t, e), this.dirty = !0, this }, appendText: Cr, appendImage: wr, appendCommand: Sr, setWrapConfig: function (t) { return void 0 === t && (t = {}), this.wrapConfig = t, this }, runWordWrap: function (t) { return void 0 === t && (t = {}), Mr.call(this, Jr(t, this.wrapConfig)) }, runVerticalWrap: function (t) { return void 0 === t && (t = {}), Er.call(this, qr(t, this.wrapConfig)) }, drawContent: function () { this.clear(); var t, e = 0 < this.fixedWidth ? this.fixedWidth : this.width, i = 0 < this.fixedHeight ? this.fixedHeight : this.height; this.setSize(e, i), this.background.active && this.background.draw(); for (var n = 0, s = this.children.length; n < s; n++)(t = this.children[n]).active && t.visible && t.draw(); this.innerBounds.active && this.innerBounds.draw() }, getChildren: function () { return this.children }, getLastAppendedChildren: function () { return this.lastAppendedChildren }, getActiveChildren: function () { return $r(this.children, "active", !0) } }, Qr = Phaser.Utils.Objects.GetFastValue, to = {}, eo = function () { function e(t) { z(this, e), this.pools = Qr(t, "pools", to) } return k(e, [{ key: "free", value: function (t) { if (!this.pools) return this; var e = t.type; return this.pools.hasOwnProperty(e) || (this.pools[e] = new G), this.pools[e].push(t), t.onFree(), this } }, { key: "freeMultiple", value: function (t) { if (!this.pools) return this; for (var e = 0, i = t.length; e < i; e++)this.free(t[e]); return this } }, { key: "allocate", value: function (t) { return this.pools && this.pools.hasOwnProperty(t) ? this.pools[t].pop() : null } }]), e }(), io = Phaser.Utils.Objects.IsPlainObject, no = Phaser.Utils.Objects.GetValue, so = function () { w(d, $t); var c = T(d); function d(t, e, i, n, s, r) { var o; z(this, d), io(e) ? (e = no(r = e, "x", 0), i = no(r, "y", 0), n = no(r, "width", 0), s = no(r, "height", 0)) : io(n) && (n = no(r = n, "width", 0), s = no(r, "height", 0)); var a = 0 === n ? 1 : n, h = 0 === s ? 1 : s; (o = c.call(this, t, e, i, a, h)).type = "rexDynamicText", o.autoRound = !0, o.padding = {}; var l = no(r, "style", void 0); o.defaultTextStyle = new Fr(l), o.textStyle = o.defaultTextStyle.clone(), o.background = new Dr(j(o), no(r, "background", void 0)), o.innerBounds = new zr(j(o), no(r, "innerBounds", void 0)), o.children = [], o.lastAppendedChildren = [], o.poolManager = new eo(r), o.setFixedSize(n, s), o.setPadding(no(r, "padding", 0)), o.setWrapConfig(no(r, "wrap", void 0)); var u = no(r, "text", void 0); return u && o.setText(u), o } return k(d, [{ key: "updateTexture", value: function () { return this.drawContent(), O(C(d.prototype), "updateTexture", this).call(this), this } }]), d }(); Object.assign(so.prototype, Zr), c.register("dynamicText", function (t, e, i, n, s) { var r = new so(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r }), R(window, "RexPlugins.UI.DynamicText", so); function ro(t) { return t.replace(lo, "\\$&").replace(uo, "\\x2d") } function oo(t) { return "string" != typeof t || ("" === t ? t = null : co.test(t) ? t = parseFloat(t) : "false" === t ? t = !1 : "true" === t && (t = !0)), t } function ao(t) { return t } var ho = { setEventEmitter: function (t, e) { return void 0 === e && (e = Phaser.Events.EventEmitter), this._privateEE = !0 === t || void 0 === t, this._eventEmitter = this._privateEE ? new e : t, this }, destroyEventEmitter: function () { return this._eventEmitter && this._privateEE && this._eventEmitter.shutdown(), this }, getEventEmitter: function () { return this._eventEmitter }, on: function () { return this._eventEmitter && this._eventEmitter.on.apply(this._eventEmitter, arguments), this }, once: function () { return this._eventEmitter && this._eventEmitter.once.apply(this._eventEmitter, arguments), this }, off: function () { return this._eventEmitter && this._eventEmitter.off.apply(this._eventEmitter, arguments), this }, emit: function (t) { return this._eventEmitter && t && this._eventEmitter.emit.apply(this._eventEmitter, arguments), this }, addListener: function () { return this._eventEmitter && this._eventEmitter.addListener.apply(this._eventEmitter, arguments), this }, removeListener: function () { return this._eventEmitter && this._eventEmitter.removeListener.apply(this._eventEmitter, arguments), this }, removeAllListeners: function () { return this._eventEmitter && this._eventEmitter.removeAllListeners.apply(this._eventEmitter, arguments), this }, listenerCount: function () { return this._eventEmitter ? this._eventEmitter.listenerCount.apply(this._eventEmitter, arguments) : 0 }, listeners: function () { return this._eventEmitter ? this._eventEmitter.listeners.apply(this._eventEmitter, arguments) : [] }, eventNames: function () { return this._eventEmitter ? this._eventEmitter.eventNames.apply(this._eventEmitter, arguments) : [] } }, lo = /[|\\{}()[\]^$+*?.]/g, uo = /-/g, co = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i, fo = function () { function i(t) { z(this, i), this.setEventEmitter(nt(t, "eventEmitter", void 0)), this.setTagExpression(nt(t, "regex.tag", "[a-z0-9-_.]+")), this.setValueExpression(nt(t, "regex.value", "[ #a-z-_.0-9,|&]+")), this.setValueConverter(nt(t, "valueConvert", !0)); var e = nt(t, "delimiters", "<>"); this.setDelimiters(e[0], e[1]), this.isRunning = !1, this.isPaused = !1, this.skipEventFlag = !1, this.lastTagStart = null, this.lastTagEnd = null, this.lastContent = null } return k(i, [{ key: "shutdown", value: function () { this.destroyEventEmitter() } }, { key: "destroy", value: function () { this.shutdown() } }, { key: "setTagExpression", value: function (t) { return this.tagExpression = t, this } }, { key: "setValueExpression", value: function (t) { return this.valueExpression = t, this } }, { key: "setValueConverter", value: function (t) { return t = !0 === t ? oo : t || ao, this.valueConverter = t, this } }, { key: "setDelimiters", value: function (t, e) { void 0 === e && (e = t[1], t = t[0]), this.delimiterLeft = t, this.delimiterRight = e, t = ro(t), e = ro(e); var i = "".concat(t, "(").concat(this.tagExpression, ")(=(").concat(this.valueExpression, "))?").concat(e), n = "".concat(t, "/(").concat(this.tagExpression, ")").concat(e); return this.reTagOn = RegExp(i, "i"), this.reTagOff = RegExp(n, "i"), this.reSplit = RegExp("".concat(i, "|").concat(n), "gi"), this } }, { key: "setSource", value: function (t) { return this.source = t, this } }, { key: "resetIndex", value: function (t) { return void 0 === t && (t = 0), this.progressIndex = t, this.reSplit.lastIndex = t, this.lastTagStart = null, this.lastTagEnd = null, this.lastContent = null, this } }, { key: "start", value: function (t) { return this.setSource(t).restart(), this } }, { key: "restart", value: function () { this.resetIndex().next() } }, { key: "next", value: function () { this.isPaused && this.onResume(), 0 === this.reSplit.lastIndex && this.onStart(); for (var t = this.source, e = t.length; !this.isPaused;) { var i = this.reSplit.exec(t); if (!i) return this.progressIndex < e && this.onContent(t.substring(this.progressIndex, e)), void this.onComplete(); var n = i[0], s = this.reSplit.lastIndex - n.length; this.progressIndex < s && this.onContent(t.substring(this.progressIndex, s)), this.reTagOff.test(n) ? this.onTagEnd(n) : this.onTagStart(n), this.progressIndex = this.reSplit.lastIndex } } }, { key: "skipEvent", value: function () { return this.skipEventFlag = !0, this } }, { key: "pause", value: function () { return this.isPaused || this.onPause(), this } }, { key: "onContent", value: function (t) { this.skipEventFlag = !1, this.emit("content", t), this.lastContent = t } }, { key: "onTagStart", value: function (t) { var e = t.match(this.reTagOn), i = e[1], n = function (t, e) { if (null == t) return []; for (var i = t.split(","), n = 0, s = i.length; n < s; n++)i[n] = e(i[n]); return i }(e[3], this.valueConverter); this.skipEventFlag = !1, this.emit.apply(this, ["+".concat(i)].concat(M(n))), this.skipEventFlag || this.emit.apply(this, ["+", i].concat(M(n))), this.lastTagStart = i } }, { key: "onTagEnd", value: function (t) { var e = t.match(this.reTagOff)[1]; this.skipEventFlag = !1, this.emit("-".concat(e)), this.skipEventFlag || this.emit("-", e), this.lastTagEnd = e } }, { key: "onStart", value: function () { this.isRunning = !0, this.emit("start", this) } }, { key: "onComplete", value: function () { this.isRunning = !1, this.emit("complete", this), this.resetIndex() } }, { key: "onPause", value: function () { this.isPaused = !0, this.emit("pause", this) } }, { key: "onResume", value: function () { this.isPaused = !1, this.emit("resume", this) } }, { key: "getTagOnRegString", value: function (t, e) { return void 0 === t && (t = this.tagExpression), void 0 === e && (e = this.valueExpression), "".concat(ro(this.delimiterLeft), "(").concat(t, ")(=(").concat(e, "))?").concat(ro(this.delimiterRight)) } }, { key: "getTagOffRegString", value: function (t) { return void 0 === t && (t = this.tagExpression), "".concat(ro(this.delimiterLeft), "/(").concat(t, ")").concat(ro(this.delimiterRight)) } }]), i }(); Object.assign(fo.prototype, ho); function po(t) { this.typeWriter.setTypingSpeed(t) } var vo = function (t, e) { Sr.call(t, "speed", po, e, t) }, go = function (t) { if (!this.skipSoundEffect) { var e = t[0], i = t[1]; this.soundManager.playSoundEffect(e), i && this.soundManager.fadeInSoundEffect(i) } }, yo = function (t) { this.soundManager.fadeInSoundEffect(t) }, mo = function (t) { var e; (e = this.soundManager).fadeOutSoundEffect.apply(e, M(t)) }, ko = function (t) { this.soundManager.setSoundEffectVolume(t) }, bo = function (t) { var e = t[0], i = t[1]; this.soundManager.playBackgroundMusic(e), i && this.soundManager.fadeInBackgroundMusic(i) }, xo = function () { this.soundManager.stopBackgroundMusic() }, Co = function (t) { this.soundManager.fadeInBackgroundMusic(t) }, wo = function (t) { var e; (e = this.soundManager).fadeOutBackgroundMusic.apply(e, M(t)) }, So = function (t) { var e; (e = this.soundManager).crossFadeBackgroundMusic.apply(e, M(t)) }; Phaser.Utils.Objects.GetValue; function Po(t) { this.typeWriter.wait(t) } function To(t, e) { return 2 === t.length && t[0] === e } function Oo(t, e) { return 3 === t.length && t[0] === e && "play" === t[2] } function Mo(t, e) { var i = "tag.".concat(e); null == t ? this.emit(i) : this.emit.apply(this, [i].concat(M(t))) } function Eo(i, n) { return new Promise(function (t, e) { i.once(n, function () { t() }) }) } function _o(t) { return Eo(t, "complete") } function Bo(t, e, i, n, s) { return function () { t.emit(ya, s), e.apply(n, i) } } function Io(t, e, i, n, s) { var r = Bo(t, i, n, s, "custom"), o = e ? "wait.".concat(e) : "wait"; t.emit(o, r) } function Ro(t, e, i, n, s) { var r, o, a, h, l, u = Bo(t, i, n, s, "time"); t.once(ya, function () { r && (r.remove(), r = void 0) }), o = e, a = u, r = t.typeWriter.timeline.delayCall(o, a, h, l), t.emit("wait.time", e) } function Ao(t, e, i, n) { var s = t.clickEE; if (s) { var r = Bo(t, e, i, n, "click"); t.once(ya, function () { s.off("pointerdown", r, t) }), s.once("pointerdown", r, t), t.emit("wait.click") } } function Do(t, e, i, n, s) { var r = Bo(t, i, n, s, "music"); e && (t.once(ya, function () { e.off("complete", r, t) }), e.once("complete", r, t)), t.emit("wait.music", e), e || r() } function Lo(t) { switch (t) { case "camera.fadein": case "camera.fadeout": case "camera.flash": case "camera.shake": case "camera.zoom": case "camera.rotate": case "camera.scroll": return 1; default: return } } function zo(e, t, i, n, s) { var r, o, a = Bo(e, i, n, s, "camera.".concat(t)), h = e.camera; switch (t) { case "camera.fadein": r = h.fadeEffect, o = "camerafadeincomplete"; break; case "camera.fadeout": r = h.fadeEffect, o = "camerafadeoutcomplete"; break; case "camera.flash": r = h.flashEffect, o = "cameraflashcomplete"; break; case "camera.shake": r = h.shakeEffect, o = "camerashakecomplete"; break; case "camera.zoom": r = h.zoomEffect, o = "camerazoomcomplete"; break; case "camera.rotate": r = h.rotateToEffect, o = "camerarotatecomplete"; break; case "camera.scroll": r = h.panEffect, o = "camerapancomplete" }r.isRunning ? (e.once(ya, function (t) { h.off(o, a, e) }), h.once(o, a, e), e.emit("wait.camera", t)) : (e.emit("wait.camera", t), a()) } function jo(t, e, i, n, s) { var r = Bo(t, i, n, s, "keydown"), o = "keydown-".concat(e.toUpperCase()), a = t.scene.input.keyboard; t.once(ya, function () { a.off(o, r, t) }), a.once(o, r, t), t.emit("wait.keydown", e) } function Fo(e, t, i, n, s) { var r = Bo(e, i, n, s), o = t.split("."), a = e.spriteManager; switch (o.length) { case 1: a.isEmpty ? (e.emit("wait.sprite"), r()) : (e.once(ya, function (t) { a.off("empty", r, e) }), a.once("empty", r, e), e.emit("wait.sprite")); break; case 2: var h = o[1]; if (a.has(h)) { var l = e.spriteManager.get(h).sprite; e.once(ya, function () { l.off("destroy", r, e) }), l.once("destroy", r, e), e.emit("wait.sprite", h) } else e.emit("wait.sprite", h), r(); break; case 3: h = o[1]; var u = o[2], c = e.spriteManager.getTweenTask(h, u); c ? (e.once(ya, function () { c.off("complete", r, e) }), c.once("complete", r, e), e.emit("wait.sprite", h, u)) : (e.emit("wait.sprite", h, u), r()) } } function Yo(t, e, i, n, s) { for (var r = 0, o = (e = "string" == typeof e && 1 < e.length && -1 !== e.indexOf("|") ? e.split("|") : [e]).length; r < o; r++) { var a = e[r]; if (null == a || "wait" === a) Io(t, void 0, i, n, s); else if ("number" != typeof a && isNaN(a)) if ("click" === a) Ao(t, i, n, s); else if ("se" === a) { var h = t.soundManager.getLastSoundEffect(); Do(t, h, i, n, s) } else if ("bgm" === a) { h = t.soundManager.getBackgroundMusic(); Do(t, h, i, n, s) } else ba.hasOwnProperty(a.toUpperCase()) ? jo(t, a, i, n, s) : Lo(a) ? zo(t, a, i, n, s) : ("sprite" === (l = a.split("."))[0] && l.length <= 3 ? Fo : Io)(t, a, i, n, s); else Ro(t, parseFloat(a), i, n, s) } var l } var Wo = function () { this.soundManager.pauseBackgroundMusic() }, Vo = function () { this.soundManager.resumeBackgroundMusic() }, Xo = function (t) { var e; (e = this.camera).fadeIn.apply(e, M(t)) }, Go = function (t) { var e; (e = this.camera).fadeOut.apply(e, M(t)) }, Uo = function (t) { var e; (e = this.camera).shake.apply(e, M(t)) }, Ho = function (t) { var e; (e = this.camera).flash.apply(e, M(t)) }, No = function (t) { this.camera.setZoom(t) }, Jo = function (t) { var e; (e = this.camera).zoomTo.apply(e, M(t)) }, Ko = Phaser.Math.DegToRad, qo = function (t) { this.camera.setRotation(t) }, $o = function (t) { var e = t[0], i = t[1], n = t[2]; this.camera.rotateTo(e, !1, i, n) }, Zo = function (t) { var e; (e = this.camera).setScroll.apply(e, M(t)) }, Qo = function (t) { var e = t[0], i = t[1], n = t[2], s = t[3], r = this.camera, o = r.scrollX, a = r.scrollY; r.setScroll(e, i), e += r.centerX, i += r.centerY, r.setScroll(o, a), r.pan(e, i, n, s) }, ta = function (t, e) { Sr.call(t, "wait", Po, e, t) }, ea = function (t) { var e; (e = this.spriteManager).add.apply(e, M(t)) }, ia = function (t) { this.spriteManager.remove(t) }, na = function () { this.spriteManager.removeAll() }, sa = function (t) { var e; (e = this.spriteManager).setTexture.apply(e, M(t)) }, ra = function (t) { var e = t[0], i = t[1], n = i.shift(); this.spriteManager.playAnimation(e, n), 0 < i.length && this.spriteManager.chainAnimation(e, i) }, oa = function (t) { this.spriteManager.stopAnimation(t) }, aa = function (t) { var e; (e = this.spriteManager).chainAnimation.apply(e, M(t)) }, ha = function (t) { this.spriteManager.pauseAnimation(t) }, la = function (t) { var e; (e = this.spriteManager).setProperty.apply(e, M(t)) }, ua = { to: !0, yoyo: !0 }, ca = function (t) { var e; (e = this.spriteManager).easeProperty.apply(e, M(t)) }, da = function (t, e, i) { Sr.call(t, e, Mo, i, t) }, fa = [function (e, i) { var t; i.on("start", function () { t = e.textStyle.color }).on("+".concat("color"), function (t) { e.textStyle.setColor(t), i.skipEvent() }).on("-".concat("color"), function () { e.textStyle.setColor(t), i.skipEvent() }).on("complete", function () { e.textStyle.setColor(t) }) }, function (e, i) { var n; i.on("start", function () { n = e.textStyle.stroke, e.textStyle.setStrokeStyle(null) }).on("+".concat("stroke"), function (t) { void 0 === t && (t = n), e.textStyle.setStrokeStyle(t), i.skipEvent() }).on("-".concat("stroke"), function () { e.textStyle.setStrokeStyle(null), i.skipEvent() }).on("complete", function () { e.textStyle.setStrokeStyle(n) }) }, function (t, e) { e.on("start", function () { t.textStyle.setBold(!1) }).on("+".concat("b"), function () { t.textStyle.setBold(!0), e.skipEvent() }).on("-".concat("b"), function () { t.textStyle.setBold(!1), e.skipEvent() }) }, function (t, e) { e.on("start", function () { t.textStyle.setItalic(!1) }).on("+".concat("i"), function () { t.textStyle.setItalic(!0), e.skipEvent() }).on("-".concat("i"), function () { t.textStyle.setItalic(!1), e.skipEvent() }) }, function (e, i) { var t; i.on("start", function () { t = e.textStyle.fontSize }).on("+".concat("size"), function (t) { e.textStyle.setFontSize(t), i.skipEvent() }).on("-".concat("size"), function () { e.textStyle.setFontSize(t), i.skipEvent() }).on("complete", function () { e.textStyle.setFontSize(t) }) }, function (e, i) { var n; i.on("start", function () { n = e.textStyle.shadowColor, e.textStyle.setShadowColor(null) }).on("+".concat("shadow"), function (t) { void 0 === t && (t = n), e.textStyle.setShadowColor(t), i.skipEvent() }).on("-".concat("shadow"), function () { e.textStyle.setShadowColor(null), i.skipEvent() }).on("complete", function () { e.textStyle.setShadowColor(n) }) }, function (e, i) { i.on("+".concat("align"), function (t) { e.textStyle.setAlign(t), i.skipEvent() }).on("-".concat("align"), function () { e.textStyle.setAlign(), i.skipEvent() }).on("complete", function () { e.textStyle.setAlign() }) }, function (e, i) { var n; i.on("start", function () { n = e.textStyle.offsetY, e.textStyle.setOffsetY(0) }).on("+".concat("y"), function (t) { void 0 === t && (t = n), e.textStyle.setOffsetY(t), i.skipEvent() }).on("-".concat("y"), function () { e.textStyle.setOffsetY(0), i.skipEvent() }).on("complete", function () { e.textStyle.setOffsetY(0) }) }, function (e, i) { var n; i.on("start", function () { n = e.textStyle.offsetY, e.textStyle.setOffsetX(0) }).on("+".concat("x"), function (t) { void 0 === t && (t = n), e.textStyle.setOffsetX(t), i.skipEvent() }).on("-".concat("x"), function () { e.textStyle.setOffsetX(0), i.skipEvent() }).on("complete", function () { e.textStyle.setOffsetX(0) }) }, function (e, i) { var n; i.on("start", function () { n = e.textStyle.leftSpace, e.textStyle.setLeftSpace(0) }).on("+".concat("left"), function (t) { void 0 === t && (t = n), e.textStyle.setLeftSpace(t), i.skipEvent() }).on("-".concat("left"), function () { e.textStyle.setLeftSpace(0), i.skipEvent() }).on("complete", function () { e.textStyle.setLeftSpace(0) }) }, function (e, i) { var n; i.on("start", function () { n = e.textStyle.rightSpace, e.textStyle.setRightSpace(0) }).on("+".concat("right"), function (t) { void 0 === t && (t = n), e.textStyle.setRightSpace(t), i.skipEvent() }).on("-".concat("right"), function () { e.textStyle.setRightSpace(0), i.skipEvent() }).on("complete", function () { e.textStyle.setRightSpace(0) }) }, function (i, n) { n.on("+".concat("img"), function (t) { var e = i.imageManager.get(t); wr.call(i, e.key, e.frame, { width: e.width, hieght: e.height, leftSpace: e.left, rightSpace: e.right }), n.skipEvent() }).on("-".concat("img"), function () { n.skipEvent() }) }, function (e, i) { i.on("+".concat("speed"), function (t) { vo(e, t), i.skipEvent() }).on("-".concat("speed"), function () { vo(e, void 0), i.skipEvent() }) }, function (i, n) { n.on("+".concat("se"), function (t, e) { Sr.call(i, "se", go, [t, e], i), n.skipEvent() }).on("-".concat("se"), function () { n.skipEvent() }) }, function (e, i) { i.on("+".concat("se.fadein"), function (t) { Sr.call(e, "se.fadein", yo, t, e), i.skipEvent() }).on("-".concat("se.fadein"), function () { i.skipEvent() }) }, function (i, n) { var t = "se.fadeout"; n.on("+".concat(t), function (t, e) { Sr.call(i, "se.fadeout", mo, [t, e = "stop" === e], i), n.skipEvent() }).on("-".concat(t), function () { n.skipEvent() }) }, function (e, i) { i.on("+".concat("se.volume"), function (t) { Sr.call(e, "se.volume", ko, t, e), i.skipEvent() }).on("-".concat("se.volume"), function () { i.skipEvent() }) }, function (i, n) { n.on("+".concat("bgm"), function (t, e) { Sr.call(i, "bgm", bo, [t, e], i), n.skipEvent() }).on("-".concat("bgm"), function () { Sr.call(i, "bgm.stop", xo, void 0, i), n.skipEvent() }) }, function (e, i) { var t = "bgm.fadein"; i.on("+".concat(t), function (t) { Sr.call(e, "bgm.fadein", Co, t, e), i.skipEvent() }).on("-".concat(t), function () { i.skipEvent() }) }, function (i, n) { var t = "bgm.fadeout"; n.on("+".concat(t), function (t, e) { Sr.call(i, "bgm.fadeout", wo, [t, e = "stop" === e], i), n.skipEvent() }).on("-".concat(t), function () { n.skipEvent() }) }, function (i, n) { n.on("+".concat("bgm.cross"), function (t, e) { Sr.call(i, "bgm.cross", So, [t, e], i), n.skipEvent() }).on("-".concat("bgm.cross"), function () { n.skipEvent() }) }, function (t, e) { e.on("+".concat("bgm.pause"), function () { Sr.call(t, "bgm.pause", Wo, void 0, t), e.skipEvent() }).on("-".concat("bgm.pause"), function () { Sr.call(t, "bgm.resume", Vo, void 0, t), e.skipEvent() }) }, function (s, r) { r.on("+".concat("camera.fadein"), function (t, e, i, n) { Sr.call(s, "camera.fadein", Xo, [t, e, i, n], s), r.skipEvent() }) }, function (s, r) { r.on("+".concat("camera.fadeout"), function (t, e, i, n) { Sr.call(s, "camera.fadeout", Go, [t, e, i, n], s), r.skipEvent() }) }, function (i, n) { n.on("+".concat("camera.shake"), function (t, e) { Sr.call(i, "camera.shake", Uo, [t, e], i), n.skipEvent() }) }, function (s, r) { r.on("+".concat("camera.flash"), function (t, e, i, n) { Sr.call(s, "camera.flash", Ho, [t, e, i, n], s), r.skipEvent() }) }, function (n, s) { var t = "camera.zoom"; s.on("+".concat(t), function (t) { Sr.call(n, "camera.zoom", No, t, n), s.skipEvent() }).on("+".concat(t, ".to"), function (t, e, i) { Sr.call(n, "camera.zoom.to", Jo, [t, e, i], n), s.skipEvent() }) }, function (n, s) { var t = "camera.rotate"; s.on("+".concat(t), function (t) { t = Ko(t), Sr.call(n, "camera.rotate", qo, t, n), s.skipEvent() }).on("+".concat(t, ".to"), function (t, e, i) { t = Ko(t), Sr.call(n, "camera.rotate.to", $o, [t, e, i], n), s.skipEvent() }) }, function (s, r) { var t = "camera.scroll"; r.on("+".concat(t), function (t, e) { Sr.call(s, "camera.scroll", Zo, [t, e], s), r.skipEvent() }).on("+".concat(t, ".to"), function (t, e, i, n) { Sr.call(s, "camera.scroll.to", Qo, [t, e, i, n], s), r.skipEvent() }) }, function (e, i) { i.on("+".concat("wait"), function (t) { ta(e, t), i.skipEvent() }).on("-".concat("wait"), function () { i.skipEvent() }).on("+".concat("click"), function () { ta(e, "click"), i.skipEvent() }).on("-".concat("click"), function () { i.skipEvent() }) }, function (o, a) { a.on("+", function (t) { if (!a.skipEventFlag) { var e = t.split("."); if (To(e, "sprite")) { for (var i = e[1], n = arguments.length, s = new Array(1 < n ? n - 1 : 0), r = 1; r < n; r++)s[r - 1] = arguments[r]; Sr.call(o, "sprite.add", ea, [i].concat(s), o), a.skipEvent() } } }).on("-", function (t) { if (!a.skipEventFlag) { var e = t.split("."); if (To(e, "sprite")) { var i = e[1]; Sr.call(o, "sprite.remove", ia, i, o), a.skipEvent() } } }) }, function (e, i) { i.on("-", function (t) { i.skipEventFlag || "sprite" === t && (Sr.call(e, "sprite.removeall", na, void 0, e), i.skipEvent()) }) }, function (a, h) { h.on("+", function (t, e, i) { if (!h.skipEventFlag) { var n = t.split("."); if (r = "sprite", 3 === (s = n).length && s[0] === r && "texture" === s[2]) { var s, r, o = n[1]; Sr.call(a, "sprite.texture", sa, [o, e, i], a), h.skipEvent() } } }) }, function (r, o) { var a = "sprite"; o.on("+", function (t) { if (!o.skipEventFlag) { var e, i = t.split("."); if (Oo(i, a)) { e = i[1]; var n = Array.prototype.slice.call(arguments, 1); Sr.call(r, "sprite.play", ra, [e, n], r), o.skipEvent() } } }).on("+", function (t) { if (!o.skipEventFlag) { var e, i, n, s = t.split("."); if (n = a, 3 === (i = s).length && i[0] === n && "stop" === i[2]) e = s[1], Sr.call(r, "sprite.stop", oa, e, r), o.skipEvent() } }).on("-", function (t) { if (!o.skipEventFlag) { var e, i = t.split("."); Oo(i, a) && (e = i[1], Sr.call(r, "sprite.stop", oa, e, r), o.skipEvent()) } }) }, function (o, a) { a.on("+", function (t) { if (!a.skipEventFlag) { var e, i = t.split("."); if (s = "sprite", 3 === (n = i).length && n[0] === s && "chain" === n[2]) { var n, s; e = i[1]; var r = Array.prototype.slice.call(arguments, 1); Sr.call(o, "sprite.chain", aa, [e, r], o), a.skipEvent() } } }) }, function (r, o) { o.on("+", function (t) { if (!o.skipEventFlag) { var e, i, n, s = t.split("."); if (n = "sprite", 3 === (i = s).length && i[0] === n && "pause" === i[2]) e = s[1], Sr.call(r, "sprite.pause", ha, e, r), o.skipEvent() } }) }, function (a, h) { h.on("+", function (t, e) { if (!h.skipEventFlag) { var i, n, s, r, o = t.split("."); if (r = "sprite", 3 === (s = o).length && s[0] === r) i = o[1], n = o[2], Sr.call(a, "sprite.set", la, [i, n, e], a), h.skipEvent() } }) }, function (c, d) { d.on("+", function (t, e, i, n, s) { if (!d.skipEventFlag) { var r, o, a, h, l, u = t.split("."); if (l = "sprite", 4 === (h = u).length && h[0] === l && ua[h[3]]) r = u[1], o = u[2], a = "yoyo" === u[3], "number" == typeof n && (s = n, n = void 0), Sr.call(c, "sprite.ease", ca, [r, o, e, i, n, s, a], c), d.skipEvent() } }) }, function (t, e) { e.on("+".concat("r"), function () { Cr.call(t, "\n"), e.skipEvent() }).on("-".concat("r"), function () { e.skipEvent() }) }, function (t, e) { e.on("+".concat("content.off"), function () { e.setContentOutputEnable(!1), e.skipEvent() }) }, function (t, e) { e.on("+".concat("content.on"), function () { e.setContentOutputEnable(), e.skipEvent() }) }, function (i, n) { n.on("content", function (t) { if (n.contentOutputEnable) Cr.call(i, t); else { var e = "+".concat(n.lastTagStart); i.emit("parser.".concat(e, "#content"), n, t) } }) }, function (o, a) { a.on("start", function () { o.emit("parser.start", a) }).on("+", function (t) { if (!a.skipEventFlag) { for (var e = "+".concat(t), i = arguments.length, n = new Array(1 < i ? i - 1 : 0), s = 1; s < i; s++)n[s - 1] = arguments[s]; var r = n; o.emit.apply(o, ["parser.".concat(e), a].concat(n, [r])), da(o, e, r) } }).on("-", function (t) { if (!a.skipEventFlag) { var e = "-".concat(t), i = []; o.emit("parser.".concat(e), a, i), da(o, e, i) } }).on("complete", function () { o.emit("parser.complete", a) }) }], pa = Phaser.Utils.Objects.GetValue, va = function () { w(s, fo); var n = T(s); function s(t, e) { var i; return z(this, s), void 0 === e && (e = {}), e.hasOwnProperty("delimiters") || (e.delimiters = "[]"), function (t, e, i) { for (var n = 0, s = fa.length; n < s; n++)fa[n](t, e, i) }(t, j(i = n.call(this, e)), e), i.setCommentLineStartSymbol(pa(e, "comment", "//")), i.setContentOutputEnable(), i } return k(s, [{ key: "setCommentLineStartSymbol", value: function (t) { return this.commentLineStart = t, this } }, { key: "setContentOutputEnable", value: function (t) { return void 0 === t && (t = !0), this.contentOutputEnable = t, this } }, { key: "start", value: function (t) { return O(C(s.prototype), "start", this).call(this, function (t, e) { for (var i = t.commentLineStart, n = e.split("\n"), s = 0, r = n.length; s < r; s++) { var o = n[s]; "" === o || (0 === o.trim().length || i && o.startsWith(i)) && (n[s] = "") } return n.join("") }(this, t)), this } }]), s }(), ga = { setDefaultTypingSpeed: function (t) { return this.defaultSpeed = t, this }, setTypingSpeed: function (t) { return void 0 === t && (t = this.defaultSpeed), this.speed = t, this } }, ya = "_remove.wait", ma = "_remove.play", ka = [ya, ma], ba = Phaser.Input.Keyboard.KeyCodes, xa = { start: function (t) { return this.children = t, this.index = 0, this.isPageTyping = !0, this.onTypeStart && this.onTypeStart(t), this.typing(), _o(this) }, typing: function n(t) { void 0 === t && (t = 0); var e = 0; for (this.inTypingProcessLoop = !0; this.inTypingProcessLoop;) { var i = this.getNextChild(); if (!i) { this.timeline.isRunning ? this.timeline.once("complete", function () { this.isPageTyping = !1, this.emit("complete") }, this) : (this.isPageTyping = !1, this.emit("complete")); break } if (br(i)) { var s = this.animationConfig; if (0 < s.duration) { var r = this.timeline.addTimer({ name: "anim", target: i, duration: s.duration, yoyo: s.yoyo, onStart: s.onStart, onProgress: s.onProgress, onComplete: s.onComplete }); this.skipTypingAnimation && r.seek(1) } else s.onStart && s.onStart(i, 0); this.textPlayer.emit("typing", i), e += this.speed + t, t = 0; var o = this.index === this.children.length; if (0 < e && !o) { this.typingTimer = this.timeline.addTimer({ name: "delay", target: this, duration: e, onComplete: function (t, e, i) { t.typingTimer = void 0, n.call(t, i.remainder) } }); break } } else i.type === Xr && i.exec() } this.inTypingProcessLoop = !1 }, pause: function () { return this.timeline.pause(), this }, resume: function () { return this.timeline.resume(), this }, pauseTyping: function () { return this.isTypingPaused || (this.typingTimer ? (this.typingTimer.pause(), this.isTypingPaused = !0) : this.inTypingProcessLoop && (this.inTypingProcessLoop = !1, this.isTypingPaused = !0)), this }, resumeTyping: function (t) { return this.isTypingPaused && (void 0 === t && (t = 0), this.typingTimer ? (this.isTypingPaused = !1, this.typingTimer.resume(), this.typingTimer.remainder += t) : this.isTypingPaused && (this.isTypingPaused = !1, this.typing(t))), this }, wait: function (t) { return this.ignoreWait || (this.pauseTyping(), Yo(this.textPlayer, t, this.resumeTyping, [], this)), this }, setTimeScale: function (t) { return this.timeScale = t, this }, setIgnoreWait: function (t) { return void 0 === t && (t = !0), this.ignoreWait = t, this }, setSkipTypingAnimation: function (t) { if (void 0 === t && (t = !0), this.skipTypingAnimation = t) for (var e = this.timeline.getTimers("anim"), i = 0, n = e.length; i < n; i++)e[i].seek(1); return this }, setSkipSoundEffect: function (t) { if (void 0 === t && (t = !0), this.skipSoundEffect = t) { var e = this.textPlayer._soundManager; e && e.fadeOutAllSoundEffects(100, !0) } return this }, skipCurrentTypingDelay: function () { return this.typingTimer && this.typingTimer.seek(1), this } }; Object.assign(xa, ga); function Ca(t) { return t instanceof Sa } function wa(t) { return null == t || "object" !== P(t) ? null : Ca(t) ? t : t.scene && Ca(t.scene) ? t.scene : t.parent && t.parent.scene && Ca(t.parent.scene) ? t.parent.scene : void 0 } var Sa = Phaser.Scene, Pa = Phaser.Utils.Objects.GetValue, Ta = function () { function i(t, e) { z(this, i), this.parent = t, this.scene = wa(t), this.isShutdown = !1, this.setEventEmitter(Pa(e, "eventEmitter", !0)), this.parent && this.parent === this.scene ? this.scene.sys.events.once("shutdown", this.onSceneDestroy, this) : this.parent && this.parent.once && this.parent.once("destroy", this.onParentDestroy, this) } return k(i, [{ key: "shutdown", value: function () { this.isShutdown || (this.parent && this.parent === this.scene ? this.scene.sys.events.off("shutdown", this.onSceneDestroy, this) : this.parent && this.parent.once && this.parent.off("destroy", this.onParentDestroy, this), this.destroyEventEmitter(), this.parent = void 0, this.scene = void 0, this.isShutdown = !0) } }, { key: "destroy", value: function (t) { this.shutdown(t) } }, { key: "onSceneDestroy", value: function () { this.destroy(!0) } }, { key: "onParentDestroy", value: function (t, e) { this.destroy(e) } }]), i }(); Object.assign(Ta.prototype, ho); var Oa = Phaser.Utils.Objects.GetValue, Ma = function () { w(s, Ta); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, t, e))._isRunning = !1, i.isPaused = !1, i.tickingState = !1, i.setTickingMode(Oa(e, "tickingMode", 1)), i } return k(s, [{ key: "boot", value: function () { 2 !== this.tickingMode || this.tickingState || this.startTicking() } }, { key: "shutdown", value: function (t) { this.isShutdown || (this.stop(), this.tickingState && this.stopTicking(), O(C(s.prototype), "shutdown", this).call(this, t)) } }, { key: "setTickingMode", value: function (t) { "string" == typeof t && (t = Ea[t]), this.tickingMode = t } }, { key: "startTicking", value: function () { this.tickingState = !0 } }, { key: "stopTicking", value: function () { this.tickingState = !1 } }, { key: "isRunning", get: function () { return this._isRunning }, set: function (t) { this._isRunning !== t && (this._isRunning = t, 1 === this.tickingMode && t != this.tickingState && (t ? this.startTicking() : this.stopTicking())) } }, { key: "start", value: function () { return this.isPaused = !1, this.isRunning = !0, this } }, { key: "pause", value: function () { return this.isRunning && (this.isPaused = !0, this.isRunning = !1), this } }, { key: "resume", value: function () { return this.isPaused && (this.isRunning = !0), this } }, { key: "stop", value: function () { return this.isPaused = !1, this.isRunning = !1, this } }, { key: "complete", value: function () { this.isPaused = !1, this.isRunning = !1, this.emit("complete", this.parent, this) } }]), s }(), Ea = { no: 0, lazy: 1, always: 2 }, _a = Phaser.Utils.Objects.GetValue, Ba = function () { w(s, Ma); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, t, e)).resetFromJSON(e), i.boot(), i } return k(s, [{ key: "resetFromJSON", value: function (t) { return this.isRunning = _a(t, "isRunning", !1), this.timeScale = _a(t, "timeScale", 1), this.now = _a(t, "now", 0), this } }, { key: "toJSON", value: function () { return { isRunning: this.isRunning, timeScale: this.timeScale, now: this.now, tickingMode: this.tickingMode } } }, { key: "start", value: function (t) { return void 0 === t && (t = 0), this.delta = 0, this.now = t, O(C(s.prototype), "start", this).call(this), this } }, { key: "seek", value: function (t) { return this.now = t, this } }, { key: "setTimeScale", value: function (t) { return this.timeScale = t, this } }, { key: "tick", value: function (t) { return t *= this.timeScale, this.now += t, this.delta = t, this.emit("update", this.now, this.delta), this } }]), s }(), Ia = function () { w(e, Ba); var t = T(e); function e() { return z(this, e), t.apply(this, arguments) } return k(e, [{ key: "startTicking", value: function () { O(C(e.prototype), "startTicking", this).call(this), this.scene.sys.events.on("update", this.update, this) } }, { key: "stopTicking", value: function () { O(C(e.prototype), "stopTicking", this).call(this), this.scene && this.scene.sys.events.off("update", this.update, this) } }, { key: "update", value: function (t, e) { return this.isRunning && 0 !== this.timeScale && this.tick(e), this } }]), e }(), Ra = Phaser.Math.Clamp, Aa = function () { function i(t, e) { z(this, i), this.setTimeline(t).reset(e) } return k(i, [{ key: "setTimeline", value: function (t) { return this.timeline = t, this } }, { key: "setName", value: function (t) { return this.name = t, this } }, { key: "setCallbacks", value: function (t, e, i, n) { return this.target = t, this.onStart = e, this.onProgress = i, this.onComplete = n, this } }, { key: "setDuration", value: function (t, e) { return void 0 === e && (e = !1), this.duration = t, this.remainder = t, this.t = 0, this.yoyo = e, this } }, { key: "setPaused", value: function (t) { return this.isPaused = t, this } }, { key: "pause", value: function () { return this.isPaused = !0, this } }, { key: "resume", value: function () { return this.isPaused = !1, this } }, { key: "setRemoved", value: function (t) { return this.removed = t, this } }, { key: "remove", value: function () { return this.removed = !0, this } }, { key: "seek", value: function (t) { return this.remainder = this.duration * (1 - t), this } }, { key: "reset", value: function (t) { return this.setName(t.name).setDuration(t.duration, t.yoyo).setCallbacks(t.target, t.onStart, t.onProgress, t.onComplete).setPaused(!1).setRemoved(!1), this } }, { key: "onFree", value: function () { this.setTimeline().setCallbacks() } }, { key: "getProgress", value: function () { var t, e, i = 1 - this.remainder / this.duration; return i = Ra(i, 0, 1), this.yoyo && (void 0 === e && (e = .5), (t = i) <= e ? t /= e : t = 1 - (t - e) / (1 - e), i = t), i } }, { key: "setProgress", value: function (t) { t = Ra(t, 0, 1), this.remainder = this.duration * (1 - t) } }, { key: "runCallback", value: function (t) { t && t(this.target, this.t, this) } }, { key: "update", value: function (t, e) { if (this.removed) return !0; if (this.isPaused) return !1; this.remainder -= e, this.t = this.getProgress(), this.runCallback(this.onProgress); var i = this.remainder <= 0; return i && this.runCallback(this.onComplete), i } }]), i }(), Da = function () { w(e, G); var t = T(e); function e() { return z(this, e), t.apply(this, arguments) } return k(e, [{ key: "allocate", value: function () { return this.pop() } }, { key: "free", value: function (t) { t.onFree(), this.push(t) } }, { key: "freeMultiple", value: function (t) { for (var e = 0, i = t.length; e < i; e++)this.free(t[e]); return this } }]), e }(), La = Phaser.Utils.Objects.GetValue, za = new Da, ja = function () { w(a, Ia); var n = T(a); function a(t, e) { var i; return z(this, a), (i = n.call(this, t, e)).addedTimers = [], i.timers = [], i.timerPool = La(e, "pool", za), i } return k(a, [{ key: "shutdown", value: function () { this.isShutdown || (this.timerPool.freeMultiple(this.addedTimers).freeMultiple(this.timers), this.timerPool = void 0, this.addedTimers = void 0, this.timers = void 0, O(C(a.prototype), "shutdown", this).call(this)) } }, { key: "addTimer", value: function (t) { var e = this.timerPool.allocate(); return e ? e.setTimeline(this).reset(t) : e = new Aa(this, t), this.addedTimers.push(e), e.runCallback(e.onStart), this.isRunning || this.start(), e } }, { key: "delayCall", value: function (t, n, s, r) { return this.addTimer({ duration: t, onComplete: function (t, e, i) { void 0 === s && (s = []), s.push(i), n.apply(r, s) } }) } }, { key: "getTimers", value: function (t) { for (var e = [], i = [this.addedTimers, this.timers], n = 0, s = i.length; n < s; n++)for (var r = i[n], o = 0, a = r.length; o < a; o++) { var h = r[o]; h.name === t && e.push(h) } return e } }, { key: "update", value: function (t, e) { var i; O(C(a.prototype), "update", this).call(this, t, e), (i = this.timers).push.apply(i, M(this.addedTimers)); for (var n = [], s = this.addedTimers.length = 0, r = this.timers.length; s < r; s++) { var o = this.timers[s]; o.update(this.now, this.delta) ? this.timerPool.free(o) : n.push(o) } this.timers = n, 0 === this.timers.length && 0 === this.addedTimers.length && this.complete() } }]), a }(), Fa = Phaser.Utils.Objects.GetValue, Ya = function () { function i(t, e) { z(this, i), this.setEventEmitter(), this.textPlayer = t, this.isPageTyping = !1, this.timeline = new ja(t), this.typingTimer = void 0, this.pauseTypingTimer = void 0, this.inTypingProcessLoop = !1, this.isTypingPaused = !1, this.setIgnoreWait(!1), this.setSkipTypingAnimation(!1), this.setTypingStartCallback(Fa(e, "onTypingStart", Va)), this.setDefaultTypingSpeed(Fa(e, "speed", 250)), this.setTypingSpeed(), this.setAnimationConfig(Fa(e, "animation", void 0)) } return k(i, [{ key: "destroy", value: function () { this.destroyEventEmitter(), this.textPlayer = void 0, this.timeline.destroy(), this.timeline = void 0, this.typingTimer = void 0, this.pauseTypingTimer = void 0, this.onTypeStart = void 0, this.animationConfig = void 0 } }, { key: "timeScale", get: function () { return this.timeline.timeScale }, set: function (t) { this.timeline.timeScale = t } }, { key: "setTypingStartCallback", value: function (t) { return this.onTypeStart = t, this } }, { key: "setAnimationConfig", value: function (t) { return (t = t || {}).hasOwnProperty("duration") || (t.duration = 0), t.hasOwnProperty("onStart") || (t.onStart = Wa), this.animationConfig = t, this } }, { key: "getNextChild", value: function () { var t = this.children[this.index]; return this.index = Math.min(this.index + 1, this.children.length), t } }]), i }(), Wa = function (t) { t.setVisible && t.setVisible() }, Va = function (t) { for (var e = 0, i = t.length; e < i; e++) { var n = t[e]; n.setVisible && n.setVisible(!1) } }; Object.assign(Ya.prototype, ho, xa); function Xa(t, e, i, n, s) { void 0 === n && (n = 1), void 0 === s && (s = 0); var r, o = { mode: 0, volume: { start: s, end: n }, duration: i }; return "string" == typeof e && (e = t.sys.sound.add(e)), e.hasOwnProperty("_fade") ? (r = e._fade).stop().resetFromJSON(o) : (r = new ch(t, e, o), e._fade = r), r.start(), e.isPlaying || e.setVolume(s).play(), e } function Ga(t, e, i, n) { void 0 === n && (n = !0); var s, r = { mode: n ? 2 : 1, volume: { start: e.volume, end: 0 }, duration: i }; return e.hasOwnProperty("_fade") ? (s = e._fade).stop().resetFromJSON(r) : (s = new ch(t, e, r), e._fade = s), s.start(), e.isPlaying || e.play(), e } function Ua(t) { return t >> 16 & 255 } function Ha(t) { return t >> 8 & 255 } function Na(t) { return 255 & t } function Ja(t, e, i, n, s) { if (t.hasOwnProperty("vp")) return t; void 0 === i && (i = .5), void 0 === n && (n = .5), void 0 === s && (s = mh), function (e) { if (e.events) return; var i = new yh, n = e.x; Object.defineProperty(e, "x", { get: function () { return n }, set: function (t) { n !== t && (n = t, i.emit("update", e)) } }); var s = e.y; Object.defineProperty(e, "y", { get: function () { return s }, set: function (t) { s !== t && (s = t, i.emit("update", e)) } }); var r = e.width; Object.defineProperty(e, "width", { get: function () { return r }, set: function (t) { r !== t && (r = t, i.emit("update", e)) } }); var o = e.height; Object.defineProperty(e, "height", { get: function () { return o }, set: function (t) { o !== t && (o = t, i.emit("update", e)) } }), e.events = i }(e); var r = e.events; function o() { s(t, e, i, n) } t.vp = e, r.on("update", o), t.once("destroy", function () { r.off("update", o), t.vp = void 0 }), Object.defineProperty(t, "vpx", { get: function () { return i }, set: function (t) { i !== t && (i = t, o()) } }), Object.defineProperty(t, "vpy", { get: function () { return n }, set: function (t) { n !== t && (n = t, o()) } }), o() } var Ka = function () { w(e, Ma); var t = T(e); function e() { return z(this, e), t.apply(this, arguments) } return k(e, [{ key: "startTicking", value: function () { O(C(e.prototype), "startTicking", this).call(this), this.scene.sys.events.on("update", this.update, this) } }, { key: "stopTicking", value: function () { O(C(e.prototype), "stopTicking", this).call(this), this.scene && this.scene.sys.events.off("update", this.update, this) } }]), e }(), qa = Phaser.Utils.Objects.GetValue, $a = Phaser.Math.Clamp, Za = function () { function e(t) { z(this, e), this.resetFromJSON(t) } return k(e, [{ key: "resetFromJSON", value: function (t) { this.state = qa(t, "state", Qa), this.timeScale = qa(t, "timeScale", 1), this.delay = qa(t, "delay", 0), this.repeat = qa(t, "repeat", 0), this.repeatCounter = qa(t, "repeatCounter", 0), this.duration = qa(t, "duration", 0), this.nowTime = qa(t, "nowTime", 0), this.justRestart = qa(t, "justRestart", !1) } }, { key: "toJSON", value: function () { return { state: this.state, timeScale: this.timeScale, delay: this.delay, repeat: this.repeat, repeatCounter: this.repeatCounter, duration: this.duration, nowTime: this.nowTime, justRestart: this.justRestart } } }, { key: "destroy", value: function () { } }, { key: "setTimeScale", value: function (t) { return this.timeScale = t, this } }, { key: "setDelay", value: function (t) { return void 0 === t && (t = 0), this.delay = t, this } }, { key: "setDuration", value: function (t) { return this.duration = t, this } }, { key: "setRepeat", value: function (t) { return this.repeat = t, this } }, { key: "setRepeatInfinity", value: function () { return this.repeat = -1, this } }, { key: "start", value: function () { return this.nowTime = 0 < this.delay ? -this.delay : 0, this.state = 0 <= this.nowTime ? eh : th, this.repeatCounter = 0, this } }, { key: "stop", value: function () { return this.state = Qa, this } }, { key: "update", value: function (t, e) { this.state !== Qa && this.state !== ih && 0 !== e && 0 !== this.timeScale && (this.nowTime += e * this.timeScale, this.state = 0 <= this.nowTime ? eh : th, this.justRestart = !1, this.nowTime >= this.duration && (-1 === this.repeat || this.repeatCounter < this.repeat ? (this.repeatCounter++, this.justRestart = !0, this.nowTime -= this.duration) : (this.nowTime = this.duration, this.state = ih))) } }, { key: "t", get: function () { var t; switch (this.state) { case Qa: case th: t = 0; break; case eh: t = this.nowTime / this.duration; break; case ih: t = 1 }return $a(t, 0, 1) }, set: function (t) { (t = $a(t, -1, 1)) < 0 ? (this.state = th, this.nowTime = -this.delay * t) : (this.state = eh, this.nowTime = this.duration * t, 1 === t && 0 !== this.repeat && this.repeatCounter++) } }, { key: "setT", value: function (t) { return this.t = t, this } }, { key: "isIdle", get: function () { return this.state === Qa } }, { key: "isDelay", get: function () { return this.state === th } }, { key: "isCountDown", get: function () { return this.state === eh } }, { key: "isRunning", get: function () { return this.state === th || this.state === eh } }, { key: "isDone", get: function () { return this.state === ih } }, { key: "isOddIteration", get: function () { return 1 == (1 & this.repeatCounter) } }, { key: "isEvenIteration", get: function () { return 0 == (1 & this.repeatCounter) } }]), e }(), Qa = 0, th = 1, eh = 2, ih = -1, nh = function () { w(s, Ka); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, t, e)).timer = new Za, i } return k(s, [{ key: "shutdown", value: function (t) { this.isShutdown || (O(C(s.prototype), "shutdown", this).call(this, t), this.timer.destroy(), this.timer = void 0) } }, { key: "start", value: function () { return this.timer.start(), O(C(s.prototype), "start", this).call(this), this } }, { key: "stop", value: function () { return this.timer.stop(), O(C(s.prototype), "stop", this).call(this), this } }, { key: "complete", value: function () { return this.timer.stop(), O(C(s.prototype), "complete", this).call(this), this } }]), s }(), sh = Phaser.Utils.Objects.GetValue, rh = Phaser.Utils.Objects.GetAdvancedValue, oh = Phaser.Tweens.Builders.GetEaseFunction, ah = function () { w(e, nh); var t = T(e); function e() { return z(this, e), t.apply(this, arguments) } return k(e, [{ key: "resetFromJSON", value: function (t) { return this.timer.resetFromJSON(sh(t, "timer")), this.setEnable(sh(t, "enable", !0)), this.setTarget(sh(t, "target", this.parent)), this.setDelay(rh(t, "delay", 0)), this.setDuration(rh(t, "duration", 1e3)), this.setEase(sh(t, "ease", "Linear")), this.setRepeat(sh(t, "repeat", 0)), this } }, { key: "setEnable", value: function (t) { return null == t && (t = !0), this.enable = t, this } }, { key: "setTarget", value: function (t) { return void 0 === t && (t = this.parent), this.target = t, this } }, { key: "setDelay", value: function (t) { return this.delay = t, this } }, { key: "setDuration", value: function (t) { return this.duration = t, this } }, { key: "setEase", value: function (t) { return void 0 === t && (t = "Linear"), this.ease = t, this.easeFn = oh(t), this } }, { key: "setRepeat", value: function (t) { return this.repeat = t, this } }, { key: "start", value: function () { return this.timer.isRunning || O(C(e.prototype), "start", this).call(this), this } }, { key: "restart", value: function () { return this.timer.stop(), this.start.apply(this, arguments), this } }, { key: "stop", value: function (t) { return void 0 === t && (t = !1), O(C(e.prototype), "stop", this).call(this), t && (this.timer.setT(1), this.updateGameObject(this.target, this.timer), this.complete()), this } }, { key: "update", value: function (t, e) { if (!this.isRunning || !this.enable || !this.parent.active) return this; var i = this.target, n = this.timer; return n.update(t, e), n.isDelay || this.updateGameObject(i, n), this.emit("update", i, this), n.isDone && this.complete(), this } }, { key: "updateGameObject", value: function () { } }]), e }(), hh = Phaser.Utils.Objects.GetValue, lh = Phaser.Utils.Objects.GetAdvancedValue, uh = Phaser.Math.Linear, ch = function () { w(r, ah); var s = T(r); function r(t, e, i) { var n; return z(this, r), e.scene = t, e.active = !0, (n = s.call(this, e, i)).volume = {}, n.resetFromJSON(i), n } return k(r, [{ key: "resetFromJSON", value: function (t) { return O(C(r.prototype), "resetFromJSON", this).call(this, t), this.setMode(hh(t, "mode", 0)), this.setEnable(hh(t, "enable", !0)), this.setVolumeRange(lh(t, "volume.start", this.parent.volume), lh(t, "volume.end", 0)), this } }, { key: "setMode", value: function (t) { return "string" == typeof t && (t = dh[t]), this.mode = t, this } }, { key: "setVolumeRange", value: function (t, e) { return this.volume.start = t, this.volume.end = e, this } }, { key: "start", value: function () { return this.timer.isRunning || (this.parent.setVolume(this.volume.start), this.timer.setDelay(this.delay).setDuration(this.duration), O(C(r.prototype), "start", this).call(this)), this } }, { key: "updateGameObject", value: function (t, e) { t.volume = uh(this.volume.start, this.volume.end, e.t) } }, { key: "complete", value: function () { switch (O(C(r.prototype), "complete", this).call(this), this.mode) { case 1: this.parent.stop(); break; case 2: this.parent.destroy() }return this } }]), r }(), dh = { stop: 1, destroy: 2 }, fh = Phaser.Utils.Objects.GetValue, ph = Phaser.Utils.Array.Remove, vh = function () { function n(t, e) { z(this, n), this.scene = t, this.soundEffects = [], this.backgroundMusic = void 0, this.setBackgroundMusicLoopValue(fh(e, "bgm.loop", !0)), this.setBackgroundMusicFadeTime(fh(e, "bgm.fade", 500)); var i = fh(e, "bgm.initial", void 0); i && this.setCurrentBackgroundMusic(i) } return k(n, [{ key: "destroy", value: function (t) { if (this.soundEffects.length && !t) for (var e = this.soundEffects.length - 1; 0 <= e; e--)this.soundEffects[e].destroy(); this.soundEffects.length = 0, this.backgroundMusic && !t && this.backgroundMusic.destroy(), this.backgroundMusic = void 0, this.scene = void 0 } }, { key: "setBackgroundMusicLoopValue", value: function (t) { return this.backgroundMusicLoopValue = t, this } }, { key: "setBackgroundMusicFadeTime", value: function (t) { return this.backgroundMusicFadeTime = t, this } }, { key: "getSoundEffects", value: function () { return this.soundEffects } }, { key: "getLastSoundEffect", value: function () { return this.soundEffects[this.soundEffects.length - 1] } }, { key: "getBackgroundMusic", value: function () { return this.backgroundMusic } }, { key: "playSoundEffect", value: function (t) { var e = this.scene.sys.sound.add(t); return this.soundEffects.push(e), e.once("complete", function () { e.destroy(), this.scene && ph(this.soundEffects, e) }, this).once("destroy", function () { this.scene && ph(this.soundEffects, e) }, this).play(), this } }, { key: "setSoundEffectVolume", value: function (t) { var e = this.getLastSoundEffect(); return e && e.setVolume(t), this } }, { key: "fadeInSoundEffect", value: function (t) { var e = this.getLastSoundEffect(); return e && Xa(this.scene, e, t), this } }, { key: "fadeOutSoundEffect", value: function (t, e) { var i = this.getLastSoundEffect(); return i && Ga(this.scene, i, t, e), this } }, { key: "fadeOutAllSoundEffects", value: function (t, e) { for (var i = this.soundEffects.length - 1; 0 <= i; i--)Ga(this.scene, this.soundEffects[i], t, e); return this } }, { key: "setCurrentBackgroundMusic", value: function (t) { (this.backgroundMusic = t) && (t.setLoop(this.backgroundMusicLoopValue), t.once("complete", function () { this.backgroundMusic.destroy(), this.backgroundMusic = void 0 }, this).once("destroy", function () { this.backgroundMusic = void 0 }, this), t.isPlaying || t.play()) } }, { key: "playBackgroundMusic", value: function (t) { return this.backgroundMusic && this.backgroundMusic.key === t || (this.stopBackgroundMusic(), this.setCurrentBackgroundMusic(this.scene.sys.sound.add(t)), 0 < this.backgroundMusicFadeTime && this.fadeInBackgroundMusic(this.backgroundMusicFadeTime)), this } }, { key: "pauseBackgroundMusic", value: function () { return this.backgroundMusic && this.backgroundMusic.pause(), this } }, { key: "resumeBackgroundMusic", value: function () { return this.backgroundMusic && this.backgroundMusic.resume(), this } }, { key: "stopBackgroundMusic", value: function () { return this.backgroundMusic && (0 < this.backgroundMusicFadeTime ? this.fadeOutBackgroundMusic(this.backgroundMusicFadeTime, !0) : (this.backgroundMusic.stop(), this.backgroundMusic.destroy(), this.backgroundMusic = void 0)), this } }, { key: "fadeInBackgroundMusic", value: function (t) { return this.backgroundMusic && Xa(this.scene, this.backgroundMusic, t), this } }, { key: "fadeOutBackgroundMusic", value: function (t, e) { return this.backgroundMusic && Ga(this.scene, this.backgroundMusic, t, e), this } }, { key: "crossFadeBackgroundMusic", value: function (t, e) { var i = this.backgroundMusicFadeTime; return this.backgroundMusicFadeTime = 0, this.fadeOutBackgroundMusic(e, !0).playBackgroundMusic(t).fadeInBackgroundMusic(e), this.backgroundMusicFadeTime = i, this } }]), n }(), gh = function () { function n(t, e, i) { z(this, n), this.GOManager = t, this.tweens = {}, this.setGO(e, i) } return k(n, [{ key: "scene", get: function () { return this.GOManager.scene } }, { key: "timeScale", get: function () { return this.GOManager.timeScale } }, { key: "destroy", value: function () { this.freeGO(), this.GOManager = void 0 } }, { key: "freeTweens", value: function () { var t = this.tweens; for (var e in t) t[e].remove(), delete t[e]; return this } }, { key: "freeGO", value: function () { return this.freeTweens(), this.gameObject.destroy(), this.gameObject = void 0, this } }, { key: "setGO", value: function (t, e) { return this.gameObject = t.setName(e), this.name = e, this.freeTweens(), this } }, { key: "setProperty", value: function (t, e) { return this.gameObject[t] = e, this } }, { key: "easeProperty", value: function (t, e, i, n, s, r, o) { var a = this.tweens; a.hasOwnProperty(t) && a[t].remove(); var h = this.gameObject, l = { targets: h, duration: i, ease: n, repeat: s, yoyo: r, onComplete: function () { a[t].remove(), delete a[t], o && o(h, t) }, onCompleteScope: this }; l[t] = e; var u = this.scene.tweens.add(l); return u.timeScale = this.timeScale, a[t] = u, this } }, { key: "setTimeScale", value: function (t) { var e = this.tweens; for (var i in e) e[i].timeScale = t; return this } }]), n }(), yh = Phaser.Events.EventEmitter, mh = function (t, e, i, n) { t.x = e.x + e.width * i, t.y = e.y + e.height * n }, kh = Phaser.Utils.Array.Remove, bh = { has: function (t) { return this.bobs.hasOwnProperty(t) }, get: function (t) { return this.bobs[t] }, getGO: function (t) { return this.get(t).gameObject }, add: function (t) { this.remove(t); for (var e = arguments.length, i = new Array(1 < e ? e - 1 : 0), n = 1; n < e; n++)i[n - 1] = arguments[n]; var s = this.createGameObjectCallback.apply(this, [this.scene].concat(i)), r = !!s.setTint && 0 < this.fadeTime, o = !!s.setAlpha && 0 < this.fadeTime; r && function (e, i) { if (e.hasOwnProperty("tintR")) return; void 0 === i && (i = 16777215); var n = Ua(i), s = Ha(i), r = Na(i); Object.defineProperty(e, "tint", { get: function () { return i }, set: function (t) { t = 16777215 & Math.floor(t), e.setTint(t), i !== t && (n = Ua(i = t), s = Ha(i), r = Na(i)) } }), Object.defineProperty(e, "tintR", { get: function () { return n }, set: function (t) { t = 255 & Math.floor(t), n !== t && (n = t, e.tint = (255 & t) << 16 | 65535 & i) } }), Object.defineProperty(e, "tintG", { get: function () { return s }, set: function (t) { t = 255 & Math.floor(t), s !== t && (s = t, e.tint = (255 & t) << 8 | 16711935 & i) } }), Object.defineProperty(e, "tintB", { get: function () { return r }, set: function (t) { t = 255 & Math.floor(t), r !== t && (r = t, e.tint = 255 & t | 16776960 & i) } }), Object.defineProperty(e, "tintGray", { get: function () { return Math.floor((n + s + r) / 3) }, set: function (t) { t = 255 & Math.floor(t), n === t && s === t && r === t || (r = s = n = t, e.tint = (255 & t) << 16 | (255 & t) << 8 | 255 & t) } }), e.tint = i }(s), this.viewportCoordinateEnable && Ja(s), s.once("destroy", function () { kh(this.removedGOs, s), this.isEmpty && this.emit("empty") }, this); var a = new this.BobClass(this, s, t); return this.bobs[t] = a, r ? a.setProperty("tintGray", 0).easeProperty("tintGray", 255, this.fadeTime) : o && a.setProperty("alpha", 0).easeProperty("alpha", 1, this.fadeTime), this } }, xh = { remove: function (t) { if (!this.has(t)) return this; var e = this.get(t); delete this.bobs[t], this.removedGOs.push(e.gameObject); var i = !!e.gameObject.setTint && 0 < this.fadeTime, n = !!gameObject.setAlpha && 0 < this.fadeTime; return i ? e.easeProperty("tintGray", 0, this.fadeTime, "Linear", 0, !1, function () { e.destroy() }) : n ? e.easeProperty("alpha", 0, this.fadeTime, "Linear", 0, !1, function () { e.destroy() }) : e.destroy(), this }, removeAll: function () { var t = this.bobs; for (var e in t) this.remove(e); return this }, clear: function (t) { void 0 === t && (t = !0); var e = this.bobs; for (var i in e) t && e[i].destroy(), delete e[i]; return this.removedGOs.length = 0, this } }, Ch = { setProperty: function (t, e, i) { return this.has(t) && this.get(t).setProperty(e, i), this }, easeProperty: function (t, e, i, n, s, r, o, a) { return this.has(t) && (void 0 === n && (n = 1e3), void 0 === s && (s = "Linear"), void 0 === r && (r = 0), void 0 === o && (o = !1), this.get(t).easeProperty(e, i, n, s, r, o, a)), this }, getTweenTask: function (t, e) { if (this.has(t)) { var i = this.get(t).tweens; if (i.hasOwnProperty(e)) return i[e] } return null } }, wh = {}; Object.assign(wh, bh, xh, Ch); var Sh = Phaser.Utils.Objects.GetValue, Ph = function () { function i(t, e) { z(this, i), this.scene = t, this.BobClass = Sh(e, "BobClass", gh), this.setCreateGameObjectCallback(Sh(e, "createGameObject")), this.setEventEmitter(Sh(e, "eventEmitter", void 0)), this.setGOFadeTime(Sh(e, "fade", 500)), this.setViewportCoordinateEnable(Sh(e, "viewportCoordinate", !1)), this.bobs = {}, this.removedGOs = [], this._timeScale = 1 } return k(i, [{ key: "destroy", value: function (t) { this.clear(!t), this.createGameObjectCallback = void 0, this.scene = void 0 } }, { key: "timeScale", get: function () { return this._timeScale }, set: function (t) { if (this._timeScale !== t) { this._timeScale = t; var e = this.bobs; for (var i in e) e[i].setTimeScale(t) } } }, { key: "setTimeScale", value: function (t) { return this.timeScale = t, this } }, { key: "setCreateGameObjectCallback", value: function (t) { return this.createGameObjectCallback = t, this } }, { key: "setGOFadeTime", value: function (t) { return this.fadeTime = t, this } }, { key: "setViewportCoordinateEnable", value: function (t) { return void 0 === t && (t = !0), this.viewportCoordinateEnable = t, this } }, { key: "isEmpty", get: function () { return function (t) { for (var e in t) return !1; return !0 }(this.bobs) && 0 === this.removedGOs.length } }]), i }(); Object.assign(Ph.prototype, ho, wh); var Th = function () { w(e, gh); var t = T(e); function e() { return z(this, e), t.apply(this, arguments) } return k(e, [{ key: "setTexture", value: function (t, e) { return this.gameObject.setTexture(t, e), this } }, { key: "playAnimation", value: function (t) { return this.gameObject.anims.timeScale = this.timeScale, this.gameObject.play(t), this } }, { key: "stopAnimation", value: function () { return this.gameObject.stop(), this } }, { key: "chainAnimation", value: function (t) { return this.gameObject.chain(t), this } }, { key: "pauseAnimation", value: function () { return this.gameObject.anims.pause(), this } }, { key: "setTimeScale", value: function (t) { return O(C(e.prototype), "setTimeScale", this).call(this, t), this.gameObject.anims && (this.gameObject.anims.timeScale = t), this } }]), e }(), Oh = {}; Object.assign(Oh, { playAnimation: function (t, e) { return this.has(t) || this.add(t), this.get(t).playAnimation(e), this }, stopAnimation: function (t) { return this.has(t) && this.get(t).stopAnimation(), this }, chainAnimation: function (t, e) { return this.has(t) && this.get(t).chainAnimation(e), this }, pauseAnimation: function (t) { return this.has(t) && this.get(t).pauseAnimation(), this }, setTexture: function (t, e, i) { return this.has(t) && this.get(t).setTexture(e, i), this } }); var Mh = function () { w(n, Ph); var i = T(n); function n(t, e) { return z(this, n), void 0 === e && (e = {}), e.BobClass = Th, i.call(this, t, e) } return k(n, [{ key: "setCreateGameObjectCallback", value: function (t) { return t && "sprite" !== t ? "image" === t && (t = _h) : t = Eh, O(C(n.prototype), "setCreateGameObjectCallback", this).call(this, t), this } }]), n }(), Eh = function (t, e, i) { return t.add.sprite(0, 0, e, i) }, _h = function (t, e, i) { return t.add.image(0, 0, e, i) }; Object.assign(Mh.prototype, Oh); var Bh = Phaser.Utils.Objects.GetValue, Ih = { setClickTarget: function (t) { return (this.clickTarget = t) ? Ca(t) ? this.clickEE = t.input : this.clickEE = t.setInteractive() : this.clickEE = null, this }, setTargetCamera: function (t) { return this.camera = t, this }, setNextPageInput: function (s) { var r = this; this.nextPageInput = s ? "function" == typeof s ? function (t, e, i) { var n = Bo(r, t, e, i); s.call(r, n) } : function (t, e, i) { Yo(r, s, t, e, i) } : null }, addImage: function (t, e) { return this.imageManager.add(t, e), this }, play: function (t) { return this.isPlaying || (this.removeChildren(), this.parser.start(t), this.isPlaying = !0, this.once("complete", function () { this.isPlaying = !1 }, this), this.lastWrapResult = void 0, this.typingNextPage()), this }, playPromise: function (t) { var e = _o(this); return this.play(t), e }, typingNextPage: function t() { if (!this.isPlaying || this.isPageTyping) return this; var e = Bh(this.wrapConfig, "callback", this.runWordWrap); "string" == typeof e && (e = this[e]); var i = e.call(this, this.lastWrapResult); this.lastWrapResult = i, this.emit("page.start"); function n() { this.emit(ma), i.isLastPage ? this.emit("complete") : (this.emit("page.complete"), this.ignoreNextPageInput ? t.call(this) : this.nextPageInput && this.nextPageInput(t, [], this)) } this.once(ma, function () { this.typeWriter.off("complete", n, this) }), this.typeWriter.once("complete", n, this).start(i.children) }, pause: function () { return this.typeWriter.pauseTyping().pause(), this }, pauseTyping: function () { return this.typeWriter.pauseTyping(), this }, resume: function () { return this.typeWriter.resume().resumeTyping(), this }, wait: function (t) { return this.typeWriter.wait(t), this }, setTimeScale: function (t) { return this.timeScale = t, this }, setIgnoreWait: function (t) { return this.typeWriter.setIgnoreWait(t), this }, setIgnoreNextPageInput: function (t) { return void 0 === t && (t = !0), this.ignoreNextPageInput = t, this }, showPage: function () { if (!this.isPlaying || !this.isPageTyping) return this; var t = this.typeWriter.speed, e = this.typeWriter.ignoreWait, i = this.typeWriter.skipTypingAnimation, n = this.typeWriter.skipSoundEffect; return this.typeWriter.once("complete", function () { this.typeWriter.setTypingSpeed(t).setIgnoreWait(e).setSkipTypingAnimation(i).setSkipSoundEffect(n) }, this).setTypingSpeed(0).skipCurrentTypingDelay().setIgnoreWait(!0).setSkipTypingAnimation(!0).setSkipSoundEffect(!0), this } }; Object.assign(Ih, { setDefaultTypingSpeed: function (t) { return this.defaultTypingSpeed = t, this }, setTypingSpeed: function (t) { return this.typingSpeed = t, this } }); var Rh = Phaser.Utils.Objects.IsPlainObject, Ah = Phaser.Utils.Objects.GetValue, Dh = function () { w(d, so); var c = T(d); function d(t, e, i, n, s, r) { var o; z(this, d), Rh(e) ? r = e : Rh(n) && (r = n), void 0 === r && (r = {}); var a = r.text; delete r.text, (o = c.call(this, t, e, i, n, s, r)).type = "rexTextPlayer", o.parser = new va(j(o), Ah(r, "parser", void 0)), o.typeWriter = new Ya(j(o), Ah(r, "typing", void 0)), o._imageManager = void 0; var h = Ah(r, "images", void 0); h && o.addImage(h), o._soundManager = void 0; var l = Ah(r, "sounds", void 0); l && (o._soundManager = new vh(o.scene, l)), o.setTargetCamera(Ah(r, "camera", o.scene.sys.cameras.main)), o._spriteManager = void 0; var u = Ah(r, "sprites", void 0); return u && (o._spriteManager = new Mh(o.scene, u)), o.setIgnoreNextPageInput(Ah(r, "ignoreNextPageInput", !1)), o.setClickTarget(Ah(r, "clickTarget", j(o))), o.setNextPageInput(Ah(r, "nextPageInput", null)), o.isPlaying = !1, a && o.play(a), o } return k(d, [{ key: "imageManager", get: function () { return void 0 === this._imageManager && (this._imageManager = new ui(this.scene)), this._imageManager } }, { key: "soundManager", get: function () { return void 0 === this._soundManager && (this._soundManager = new vh(this.scene)), this._soundManager } }, { key: "spriteManager", get: function () { return void 0 === this._spriteManager && (this._spriteManager = new Mh(this.scene)), this._spriteManager } }, { key: "destroy", value: function (t) { this.scene && (function (t) { for (var e = 0, i = ka.length; e < i; e++)t.emit(ka[e]) }(this), this.parser.destroy(), this.parser = void 0, this.typeWriter.destroy(t), this.typeWriter = void 0, this._imageManager && this._imageManager.destroy(t), this._imageManager = void 0, this._soundManager && this._soundManager.destroy(t), this._soundManager = void 0, this.camera = void 0, this._spriteManager && this._spriteManager.destroy(t), this._spriteManager = void 0, this.clickEE = void 0, O(C(d.prototype), "destroy", this).call(this, t)) } }, { key: "isPageTyping", get: function () { return this.typeWriter.isPageTyping } }, { key: "defaultTypingSpeed", get: function () { return this.typeWriter.defaultTypingSpeed }, set: function (t) { this.typeWriter.setDefaultTypingSpeed(t) } }, { key: "typingSpeed", get: function () { return this.typeWriter.speed }, set: function (t) { this.typeWriter.setTypingSpeed(t) } }, { key: "timeScale", get: function () { return this.typeWriter.timeScale }, set: function (t) { this.typeWriter.timeScale = t, void 0 !== this._spriteManager && this._spriteManager.setTimeScale(t) } }]), d }(); Object.assign(Dh.prototype, Ih), c.register("textPlayer", function (t, e, i, n, s) { var r = new Dh(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r }), R(window, "RexPlugins.UI.TextPlayer", Dh); function Lh(t, e, i, n, s, r, o, a, h, l, u, c) { void 0 === l && (l = 0), void 0 === u && (u = 2 * Math.PI), void 0 === c && (c = !1), e.beginPath(), e.ellipse(i, n, s, r, 0, l, u, c), null != o && (e.fillStyle = o, e.fill()), null != a && (e.strokeStyle = a, e.lineWidth = h, e.stroke()) } var zh = Phaser.Utils.Objects.GetValue, jh = Phaser.Math.Linear, Fh = function () { w(s, ah); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, t, e)).resetFromJSON(), i.boot(), i } return k(s, [{ key: "start", value: function (t) { if (this.timer.isRunning) return this; var e = this.target; this.propertyKey = zh(t, "key", "value"); var i = e[this.propertyKey]; return this.fromValue = zh(t, "from", i), this.toValue = zh(t, "to", i), this.setEase(zh(t, "ease", this.ease)), this.setDuration(zh(t, "duration", this.duration)), this.timer.setDuration(this.duration), e[this.propertyKey] = this.fromValue, O(C(s.prototype), "start", this).call(this), this } }, { key: "updateGameObject", value: function (t, e) { var i = e.t; i = this.easeFn(i), t[this.propertyKey] = jh(this.fromValue, this.toValue, i) } }]), s }(), Yh = Phaser.Math.Percent, Wh = { setEaseValuePropName: function (t) { return this.easeValuePropName = t, this }, setEaseValueDuration: function (t) { return this.easeValueDuration = t, this }, setEaseValueFunction: function (t) { return this.easeFunction = t, this }, stopEaseValue: function () { return this.easeValueTask && this.easeValueTask.stop(), this }, easeValueTo: function (t, e, i) { return null == t || (void 0 !== e && (t = Yh(t, e, i)), void 0 === this.easeValueTask && (this.easeValueTask = new Fh(this, { eventEmitter: null })), this.easeValueTask.restart({ key: this.easeValuePropName, to: t, duration: this.easeValueDuration, ease: this.easeFunction })), this } }, Vh = Phaser.Utils.Objects.GetValue, Xh = Phaser.Utils.Objects.IsPlainObject, Gh = Phaser.Math.Clamp, Uh = Phaser.Math.Linear, Hh = Phaser.Math.Percent, Nh = Phaser.Math.DegToRad(270), Jh = function () { w(f, $t); var d = T(f); function f(t, e, i, n, s, r, o) { var a; z(this, f), Xh(e) && (e = Vh(o = e, "x", 0), i = Vh(o, "y", 0), n = Vh(o, "radius", 1), s = Vh(o, "barColor", void 0), r = Vh(o, "value", 0)); var h = 2 * n; (a = d.call(this, t, e, i, h, h)).type = "rexCircularProgressCanvas", a.eventEmitter = Vh(o, "eventEmitter", j(a)), a.setRadius(n), a.setTrackColor(Vh(o, "trackColor", void 0)), a.setBarColor(s), a.setCenterColor(Vh(o, "centerColor", void 0)), a.setThickness(Vh(o, "thickness", .2)), a.setStartAngle(Vh(o, "startAngle", Nh)), a.setAnticlockwise(Vh(o, "anticlockwise", !1)), a.setTextColor(Vh(o, "textColor", void 0)), a.setTextStrokeColor(Vh(o, "textStrokeColor", void 0), Vh(o, "textStrokeThickness", void 0)); var l = Vh(o, "textFont", void 0); l ? a.setTextFont(l) : a.setTextFont(Vh(o, "textSize", "16px"), Vh(o, "textFamily", "Courier"), Vh(o, "textStyle", "")), a.setTextFormatCallback(Vh(o, "textFormatCallback", void 0), Vh(o, "textFormatCallbackScope", void 0)); var u = Vh(o, "valuechangeCallback", null); if (null !== u) { var c = Vh(o, "valuechangeCallbackScope", void 0); a.eventEmitter.on("valuechange", u, c) } return a.setEaseValuePropName("value").setEaseValueDuration(Vh(o, "easeValue.duration", 0)).setEaseValueFunction(Vh(o, "easeValue.ease", "Linear")), a.setValue(r), a } return k(f, [{ key: "resize", value: function (t, e) { return (t = Math.floor(Math.min(t, e))) === this.width || (O(C(f.prototype), "resize", this).call(this, t, t), this.setRadius(t / 2)), this } }, { key: "value", get: function () { return this._value }, set: function (t) { t = Gh(t, 0, 1); var e = this._value, i = e != t; this.dirty = this.dirty || i, this._value = t, i && this.eventEmitter.emit("valuechange", this._value, e, this.eventEmitter) } }, { key: "setValue", value: function (t, e, i) { return null == t || (void 0 !== e && (t = Hh(t, e, i)), this.value = t), this } }, { key: "addValue", value: function (t, e, i) { return void 0 !== e && (t = Hh(t, e, i)), this.value += t, this } }, { key: "getValue", value: function (t, e) { var i = this.value; return void 0 !== t && (i = Uh(t, e, i)), i } }, { key: "radius", get: function () { return this._radius }, set: function (t) { this.dirty = this.dirty || this._radius != t; var e = 2 * (this._radius = t); this.resize(e, e) } }, { key: "setRadius", value: function (t) { return this.radius = t, this } }, { key: "trackColor", get: function () { return this._trackColor }, set: function (t) { t = Qt(t, this.canvas, this.context), this.dirty = this.dirty || this._trackColor != t, this._trackColor = t } }, { key: "setTrackColor", value: function (t) { return this.trackColor = t, this } }, { key: "barColor", get: function () { return this._barColor }, set: function (t) { t = Qt(t, this.canvas, this.context), this.dirty = this.dirty || this._barColor != t, this._barColor = t } }, { key: "setBarColor", value: function (t) { return this.barColor = t, this } }, { key: "startAngle", get: function () { return this._startAngle }, set: function (t) { this.dirty = this.dirty || this._startAngle != t, this._startAngle = t } }, { key: "setStartAngle", value: function (t) { return this.startAngle = t, this } }, { key: "anticlockwise", get: function () { return this._anticlockwise }, set: function (t) { this.dirty = this.dirty || this._anticlockwise != t, this._anticlockwise = t } }, { key: "setAnticlockwise", value: function (t) { return void 0 === t && (t = !0), this.anticlockwise = t, this } }, { key: "thickness", get: function () { return this._thickness }, set: function (t) { t = Gh(t, 0, 1), this.dirty = this.dirty || this._thickness != t, this._thickness = t } }, { key: "setThickness", value: function (t) { return this.thickness = t, this } }, { key: "centerColor", get: function () { return this._centerColor }, set: function (t) { t = Qt(t, this.canvas, this.context), this.dirty = this.dirty || this._centerColor != t, this._centerColor = t } }, { key: "centerColor2", get: function () { return this._centerColor2 }, set: function (t) { t = Qt(t, this.canvas, this.context), this.dirty = this.dirty || this._centerColor2 != t, this._centerColor2 = t } }, { key: "setCenterColor", value: function (t, e) { return this.centerColor = t, this.centerColor2 = e, this } }, { key: "textColor", get: function () { return this._textColor }, set: function (t) { t = Qt(t, this.canvas, this.context), this.dirty = this.dirty || this._textColor != t, this._textColor = t } }, { key: "setTextColor", value: function (t) { return this.textColor = t, this } }, { key: "textStrokeColor", get: function () { return this._textStrokeColor }, set: function (t) { t = Qt(t, this.canvas, this.context), this.dirty = this.dirty || this._textStrokeColor != t, this._textStrokeColor = t } }, { key: "textStrokeThickness", get: function () { return this._textStrokeThickness }, set: function (t) { this.dirty = this.dirty || this._textStrokeThickness != t, this._textStrokeThickness = t } }, { key: "setTextStrokeColor", value: function (t, e) { return void 0 === e && (e = 2), this.textStrokeColor = t, this.textStrokeThickness = e, this } }, { key: "textFont", get: function () { return this._textFont }, set: function (t) { this.dirty = this.dirty || this._textFont != t, this._textFont = t } }, { key: "setTextFont", value: function (t, e, i) { var n; return n = void 0 === e ? t : i + " " + t + " " + e, this.textFont = n, this } }, { key: "setTextFormatCallback", value: function (t, e) { return this.textFormatCallback = t, this.textFormatCallbackScope = e, this } }, { key: "updateTexture", value: function () { return this.clear(), function () { var t, e, i, n, s, r, o, a, h, l, u, c = this.radius, d = this.thickness * this.radius, f = this.radius - d / 2, p = this.radius - d, v = (this.canvas, this.context); if (this.trackColor && 0 < d && (v.save(), Lh(0, v, c, c, f, f, void 0, this.trackColor, d), v.restore()), this.barColor && 0 < f) { var g, y, m; if (1 === this.value) g = !1, y = 0, m = 2 * Math.PI; else g = this.anticlockwise, y = this.startAngle, m = 2 * Math.PI * (g ? 1 - this.value : this.value) + y; v.save(), Lh(0, v, c, c, f, f, void 0, this.barColor, d, y, m, g), v.restore() } this.centerColor && 0 < p && (this.centerColor2 ? ((t = this.context.createRadialGradient(c, c, 0, c, c, p)).addColorStop(0, this.centerColor), t.addColorStop(1, this.centerColor2)) : t = this.centerColor, v.save(), Lh(0, v, c, c, p, p, t), v.restore()); this.textFormatCallback && (this.textColor || this.textStrokeColor) && (v.save(), e = v, n = i = c, s = this.getFormatText(), r = this.textFont, o = this.textColor, a = this.textStrokeColor, void 0 === (h = this.textStrokeThickness) && null != a && (h = 2), void 0 === (l = "center") && (l = "start"), void 0 === (u = "middle") && (u = "alphabetic"), e.font = r, e.textAlign = l, e.textBaseline = u, e.fillStyle = o, e.strokeStyle = a, e.lineWidth = h, e.lineCap = "round", e.lineJoin = "round", null != a && "none" !== a && 0 < h && e.strokeText(s, i, n), null != o && "none" !== o && e.fillText(s, i, n), v.restore()) }.call(this), O(C(f.prototype), "updateTexture", this).call(this), this } }, { key: "getFormatText", value: function (t) { return void 0 === t && (t = this.value), this.textFormatCallbackScope ? this.textFormatCallback(t) : this.textFormatCallback.call(this.textFormatCallbackScope, t) } }]), f }(); Object.assign(Jh.prototype, Wh), c.register("circularProgressCanvas", function (t, e, i, n, s, r) { var o = new Jh(this.scene, t, e, i, n, s, r); return this.scene.add.existing(o), o }), R(window, "RexPlugins.UI.CircularProgressCanvas", Jh); var Kh = Phaser.GameObjects.GetCalcMatrix, qh = Phaser.Renderer.Canvas.SetTransform, $h = { renderWebGL: function (t, e, i, n) { e.updateData(), i.addToRenderList(e); var s = t.pipelines.set(e.pipeline), r = Kh(e, i, n), o = s.calcMatrix.copyFrom(r.calc), a = e._displayOriginX, h = e._displayOriginY, l = i.alpha * e.alpha; t.pipelines.preBatch(e); for (var u = e.geom, c = 0, d = u.length; c < d; c++)u[c].webglRender(s, o, l, a, h); t.pipelines.postBatch(e) }, renderCanvas: function (t, e, i, n) { e.updateData(), i.addToRenderList(e); var s = t.currentContext; if (qh(t, s, e, i, n)) { for (var r = e._displayOriginX, o = e._displayOriginY, a = e.geom, h = 0, l = a.length; h < l; h++)a[h].canvasRender(s, r, o); s.restore() } } }, Zh = Phaser.GameObjects.Shape, Qh = Phaser.Utils.Array.Remove, tl = function () { w(a, Zh); var o = T(a); function a(t, e, i, n, s) { var r; return z(this, a), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = n), (r = o.call(this, t, "rexShapes", []))._width = -1, r._height = -1, r.dirty = !0, r.isSizeChanged = !0, r.shapes = {}, r.setPosition(e, i), r.setSize(n, s), r.updateDisplayOrigin(), r } return k(a, [{ key: "width", get: function () { return this._width }, set: function (t) { this.setSize(t, this._height) } }, { key: "height", get: function () { return this._height }, set: function (t) { this.setSize(this._width, t) } }, { key: "setDirty", value: function (t) { return void 0 === t && (t = !0), this.dirty = t, this } }, { key: "setSize", value: function (t, e) { this.isSizeChanged = this.isSizeChanged || this._width !== t || this._height !== e, this.dirty = this.dirty || this.isSizeChanged, this._width = t, this._height = e, this.updateDisplayOrigin(); var i = this.input; return i && !i.customHitArea && (i.hitArea.width = t, i.hitArea.height = e), this } }, { key: "resize", value: function (t, e) { return this.setSize(t, e), this } }, { key: "fillColor", get: function () { return this._fillColor }, set: function (t) { this.setFillStyle(t, this._fillAlpha) } }, { key: "fillAlpha", get: function () { return this._fillAlpha }, set: function (t) { this.setFillStyle(this._fillColor, t) } }, { key: "setFillStyle", value: function (t, e) { return void 0 === e && (e = 1), this.dirty = this.dirty || this.fillColor !== t || this.fillAlpha !== e, this._fillColor = t, this._fillAlpha = e, this } }, { key: "lineWidth", get: function () { return this._lineWidth }, set: function (t) { this.setStrokeStyle(t, this._strokeColor, this._strokeAlpha) } }, { key: "strokeColor", get: function () { return this._strokeColor }, set: function (t) { this.setStrokeStyle(this._lineWidth, t, this._strokeAlpha) } }, { key: "strokeAlpha", get: function () { return this._strokeAlpha }, set: function (t) { this.setStrokeStyle(this._lineWidth, this._strokeColor, t) } }, { key: "setStrokeStyle", value: function (t, e, i) { return void 0 === i && (i = 1), this.dirty = this.dirty || this.lineWidth !== t || this.strokeColor !== e || this.strokeAlpha !== i, this._lineWidth = t, this._strokeColor = e, this._strokeAlpha = i, this } }, { key: "updateShapes", value: function () { } }, { key: "updateData", value: function () { if (!this.dirty) return this; this.updateShapes(); for (var t = this.geom, e = 0, i = t.length; e < i; e++) { var n = t[e]; n.dirty && n.updateData() } return this.isSizeChanged = !1, this.dirty = !1, this } }, { key: "clear", value: function () { return this.geom.length = 0, st(this.shapes), this } }, { key: "getShape", value: function (t) { return this.shapes[t] } }, { key: "getShapes", value: function () { return this.geom } }, { key: "addShape", value: function (t) { this.geom.push(t); var e = t.name; return e && (this.shapes[e] = t), this.dirty = !0, this } }, { key: "deleteShape", value: function (t) { var e = this.getShape(t); return e && (delete this.shapes[t], Qh(this.geom, e)), this } }]), a }(); Object.assign(tl.prototype, $h); var el = { fillStyle: function (t, e) { return void 0 === t ? this.isFilled = !1 : (void 0 === e && (e = 1), this.isFilled = !0, this.fillColor = t, this.fillAlpha = e), this }, lineStyle: function (t, e, i) { return void 0 === t || void 0 === e ? this.isStroked = !1 : (void 0 === i && (i = 1), this.isStroked = !0, this.lineWidth = t, this.strokeColor = e, this.strokeAlpha = i), this } }, il = function () { function t() { z(this, t), this.name = void 0, this.dirty = !0, this.data = void 0, this.isFilled = !1, this.fillColor = void 0, this.fillAlpha = 1, this.isStroked = !1, this.lineWidth = 1, this.strokeColor = void 0, this.strokeAlpha = 1 } return k(t, [{ key: "setName", value: function (t) { return this.name = t, this } }, { key: "reset", value: function () { return this.fillStyle().lineStyle(), this } }, { key: "webglRender", value: function () { } }, { key: "canvasRender", value: function () { } }, { key: "updateData", value: function () { this.dirty = !1 } }]), t }(); Object.assign(il.prototype, el, ot); function nl(t, e, i, n, s, r) { for (var o = r.length, a = r[o - 2], h = r[o - 1], l = 1, u = s - 1; l <= u; l++) { var c = l / u; r.push(dl(c, a, t, i), dl(c, h, e, n)) } return r } var sl = Phaser.Geom.Polygon.Earcut, rl = function () { w(i, il); var e = T(i); function i() { var t; return z(this, i), (t = e.call(this)).pathData = [], t.pathIndexes = [], t.closePath = !1, t } return k(i, [{ key: "updateData", value: function () { return this.pathIndexes = sl(this.pathData), O(C(i.prototype), "updateData", this).call(this), this } }, { key: "webglRender", value: function (t, e, i, n, s) { this.isFilled && wt(t, e, this, i, n, s), this.isStroked && St(t, this, i, n, s) } }, { key: "canvasRender", value: function (t, e, i) { var n = this.pathData, s = n.length - 1, r = n[0] - e, o = n[1] - i; t.beginPath(), t.moveTo(r, o), this.closePath || (s -= 2); for (var a = 2; a < s; a += 2) { var h = n[a] - e, l = n[a + 1] - i; t.lineTo(h, l) } this.closePath && t.closePath(), this.isFilled && (Pt(t, this), t.fill()), this.isStroked && (Tt(t, this), t.stroke()) } }]), i }(), ol = Phaser.Math.DegToRad, al = function () { w(u, rl); var l = T(u); function u(t, e, i, n, s, r, o, a) { var h; return z(this, u), void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 360), void 0 === o && (o = !1), void 0 === a && (a = !1), (h = l.call(this)).setCenterPosition(t, e), h.setRadius(i, n), h.setAngle(s, r, o), h.setPie(a), h.setIterations(32), h } return k(u, [{ key: "x", get: function () { return this._x }, set: function (t) { this.dirty = this.dirty || this._x !== t, this._x = t } }, { key: "y", get: function () { return this._y }, set: function (t) { this.dirty = this.dirty || this._y !== t, this._y = t } }, { key: "setCenterPosition", value: function (t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this } }, { key: "radiusX", get: function () { return this._radiusX }, set: function (t) { this.dirty = this.dirty || this._radiusX !== t, this._radiusX = t } }, { key: "radiusY", get: function () { return this._radiusY }, set: function (t) { this.dirty = this.dirty || this._radiusY !== t, this._radiusY = t } }, { key: "setRadius", value: function (t, e) { return void 0 === e && (e = t), this.radiusX = t, this.radiusY = e, this } }, { key: "startAngle", get: function () { return this._startAngle }, set: function (t) { this.dirty = this.dirty || this._startAngle !== t, this._startAngle = t } }, { key: "endAngle", get: function () { return this._endAngle }, set: function (t) { this.dirty = this.dirty || this._endAngle !== t, this._endAngle = t } }, { key: "anticlockwise", get: function () { return this._anticlockwise }, set: function (t) { this.dirty = this.dirty || this._anticlockwise !== t, this._anticlockwise = t } }, { key: "setAngle", value: function (t, e, i) { return void 0 === i && (i = !1), this.startAngle = t, this.endAngle = e, this.anticlockwise = i, this } }, { key: "pie", get: function () { return this._pie }, set: function (t) { this.dirty = this.dirty || this._pie !== t, this._pie = t } }, { key: "setPie", value: function (t) { return void 0 === t && (t = !0), this.pie = t, this } }, { key: "iterations", get: function () { return this._iterations }, set: function (t) { this.dirty = this.dirty || this._iterations !== t, this._iterations = t } }, { key: "setIterations", value: function (t) { return this.iterations = t, this } }, { key: "updateData", value: function () { return this.pathData.length = 0, this.pie && this.pathData.push(this.x, this.y), Ct(this.x, this.y, this.radiusX, this.radiusY, this.startAngle, this.endAngle, this.anticlockwise, this.iterations, this.pathData), this.pie && this.pathData.push(this.x, this.y), this.pathData.push(this.pathData[0], this.pathData[1]), O(C(u.prototype), "updateData", this).call(this), this } }, { key: "canvasRender", value: function (t, e, i) { t.beginPath(); var n = this.x - e, s = this.y - i, r = ol(this.startAngle), o = ol(this.endAngle); this.pie && (t.moveTo(n, s), t.lineTo(n + Math.cos(r) * this.radiusX, s + Math.sin(r) * this.radiusY)), t.ellipse(n, s, this.radiusX, this.radiusY, 0, r, o, this.anticlockwise), this.pie && t.lineTo(n, s), this.isFilled && (Pt(t, this), t.fill()), this.isStroked && (Tt(t, this), t.stroke()) } }]), u }(), hl = function () { w(s, al); var n = T(s); function s(t, e, i) { return z(this, s), n.call(this, t, e, i, i, 0, 360) } return k(s) }(), ll = function () { w(n, rl); var i = T(n); function n(t) { var e; return z(this, n), (e = i.call(this)).setCurve(t), e.setIterations(32), e } return k(n, [{ key: "curve", get: function () { return this._curve }, set: function (t) { this.dirty = this.dirty || this._curve !== t, this._curve = t } }, { key: "setCurve", value: function (t) { return this.curve = t, this } }, { key: "iterations", get: function () { return this._iterations }, set: function (t) { this.dirty = this.dirty || this._iterations !== t, this._iterations = t } }, { key: "setIterations", value: function (t) { return this.iterations = t, this } }, { key: "updateData", value: function () { this.pathData.length = 0; for (var t = this.curve.getPoints(this.iterations), e = 0, i = t.length; e < i; e++)this.pathData.push(t[e].x, t[e].y); return this.pathData.push(t[0].x, t[0].y), O(C(n.prototype), "updateData", this).call(this), this } }]), n }(), ul = function () { w(r, al); var s = T(r); function r(t, e, i, n) { return z(this, r), s.call(this, t, e, i, n, 0, 360) } return k(r) }(), cl = function () { w(o, rl); var r = T(o); function o(t, e, i, n) { var s; return z(this, o), void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), (s = r.call(this)).setP0(t, e), s.setP1(i, n), s } return k(o, [{ key: "x0", get: function () { return this._x0 }, set: function (t) { this.dirty = this.dirty || this._x0 !== t, this._x0 = t } }, { key: "y0", get: function () { return this._y0 }, set: function (t) { this.dirty = this.dirty || this._y0 !== t, this._y0 = t } }, { key: "setP0", value: function (t, e) { return this.x0 = t, this.y0 = e, this } }, { key: "x1", get: function () { return this._x1 }, set: function (t) { this.dirty = this.dirty || this._x1 !== t, this._x1 = t } }, { key: "y1", get: function () { return this._y1 }, set: function (t) { this.dirty = this.dirty || this._y1 !== t, this._y1 = t } }, { key: "setP1", value: function (t, e) { return this.x1 = t, this.y1 = e, this } }, { key: "updateData", value: function () { return this.pathData.length = 0, this.pathData.push(this.x0, this.y0), this.pathData.push(this.x1, this.y1), this.pathData.push(this.x0, this.y0), O(C(o.prototype), "updateData", this).call(this), this } }]), o }(), dl = Phaser.Math.Interpolation.QuadraticBezier, fl = Phaser.Math.RotateAround, pl = Phaser.Geom.Polygon, vl = Phaser.Math.DegToRad, gl = function () { function e(t) { z(this, e), void 0 === t && (t = []), this.pathData = t, this.closePath = !1, this.setIterations(32), this.lastPointX = void 0, this.lastPointY = void 0 } return k(e, [{ key: "setIterations", value: function (t) { return this.iterations = t, this } }, { key: "startAt", value: function (t, e) { var i, n, s; return i = t, n = e, (s = this.pathData).length = 0, s.push(i, n), this.lastPointX = t, this.lastPointY = e, this } }, { key: "lineTo", value: function (t, e, i) { return void 0 === i && (i = !1), i && (t += this.lastPointX, e += this.lastPointY), xt(t, e, this.pathData), this.lastPointX = t, this.lastPointY = e, this } }, { key: "verticalLineTo", value: function (t, e) { return this.lineTo(t, this.lastPointY, e), this } }, { key: "horizontalLineTo", value: function (t, e) { return this.lineTo(this.lastPointX, t, e), this } }, { key: "ellipticalArc", value: function (t, e, i, n, s, r, o) { void 0 === o && (o = !1), Ct(t, e, i, n, s, r, o, this.iterations, this.pathData); var a = this.pathData.length; return this.lastPointX = this.pathData[a - 2], this.lastPointY = this.pathData[a - 1], this } }, { key: "arc", value: function (t, e, i, n, s, r) { return this.ellipticalArc(t, e, i, i, n, s, r), this } }, { key: "quadraticBezierTo", value: function (t, e, i, n) { return nl(t, e, i, n, this.iterations, this.pathData), this.lastPointX = i, this.lastPointY = n, this.lastCX = t, this.lastCY = e, this } }, { key: "smoothQuadraticBezierTo", value: function (t, e) { var i = 2 * this.lastPointX - this.lastCX, n = 2 * this.lastPointY - this.lastCY; return this.quadraticBezierTo(i, n, t, e), this } }, { key: "cubicBezierCurveTo", value: function (t, e, i, n, s, r) { return nl(t, e, i, n, s, r, this.iterations, this.pathData), this.lastPointX = s, this.lastPointY = r, this.lastCX = i, this.lastCY = n, this } }, { key: "smoothCubicBezierCurveTo", value: function (t, e, i, n) { var s = 2 * this.lastPointX - this.lastCX, r = 2 * this.lastPointY - this.lastCY; return this.cubicBezierCurveTo(s, r, t, e, i, n), this } }, { key: "close", value: function () { return this.closePath = !0, this } }, { key: "end", value: function () { return this.pathData.push(this.lastPointX, this.lastPointY), this } }, { key: "rotateAround", value: function (t, e, i) { if (0 === this.pathData.length) return this; !function (t, e, i, n) { for (var s = { x: 0, y: 0 }, r = 0, o = n.length - 1; r < o; r += 2)s.x = n[r], s.y = n[r + 1], fl(s, t, e, i), n[r] = s.x, n[r + 1] = s.y }(t, e, i = vl(i), this.pathData); var n = this.pathData.length; if (this.lastPointX = this.pathData[n - 2], this.lastPointY = this.pathData[n - 1], void 0 !== this.lastCX) { var s = { x: this.lastCX, y: this.lastCY }; PointRotateAround(s, t, e, i), this.lastCX = s.x, this.lastCY = s.y } return this } }, { key: "offset", value: function (t, e) { return function (t, e, i) { for (var n = 0, s = i.length - 1; n < s; n += 2)i[n] += t, i[n + 1] += e }(t, e, this.pathData), this } }, { key: "toPoints", value: function () { return function (t, e) { void 0 === e && (e = []); for (var i = 0, n = t.length - 1; i < n; i += 2)e.push({ x: t[i], y: t[i + 1] }); return e }(this.pathData) } }, { key: "toPolygon", value: function (t) { return e = this.pathData, void 0 === (i = t) && (i = new pl), i.setTo(e), i; var e, i } }, { key: "draw", value: function (t, e, i) { var n = this.toPoints(); return e && t.fillPoints(n, this.closePath, this.closePath), i && t.strokePoints(n, this.closePath, this.closePath), this } }]), e }(), yl = function () { w(i, rl); var e = T(i); function i() { var t; return z(this, i), (t = e.call(this)).builder = new gl(t.pathData), t } return k(i, [{ key: "iterations", get: function () { return this.builder.iterations }, set: function (t) { this.dirty = this.dirty || this.builder.iterations !== t, this.builder.setIterations(t) } }, { key: "setIterations", value: function (t) { return this.iterations = t, this } }, { key: "lastPointX", get: function () { return this.builder.lastPointX } }, { key: "lastPointY", get: function () { return this.builder.lastPointY } }, { key: "startAt", value: function (t, e) { return this.builder.startAt(t, e), this.dirty = !0, this } }, { key: "lineTo", value: function (t, e, i) { return this.builder.lineTo(t, e, i), this.dirty = !0, this } }, { key: "verticalLineTo", value: function (t, e) { return this.builder.verticalLineTo(t, e), this.dirty = !0, this } }, { key: "horizontalLineTo", value: function (t, e) { return this.builder.horizontalLineTo(t, e), this.dirty = !0, this } }, { key: "ellipticalArc", value: function (t, e, i, n, s, r, o) { return this.builder.ellipticalArc(t, e, i, n, s, r, o), this.dirty = !0, this } }, { key: "arc", value: function (t, e, i, n, s, r) { return this.builder.arc(t, e, i, n, s, r), this.dirty = !0, this } }, { key: "quadraticBezierTo", value: function (t, e, i, n) { return this.builder.quadraticBezierTo(t, e, i, n), this.dirty = !0, this } }, { key: "smoothQuadraticBezierTo", value: function (t, e) { return this.builder.smoothQuadraticBezierTo(t, e), this.dirty = !0, this } }, { key: "cubicBezierCurveTo", value: function (t, e, i, n, s, r) { return this.builder.cubicBezierCurveTo(t, e, i, n, s, r), this.dirty = !0, this } }, { key: "smoothCubicBezierCurveTo", value: function (t, e, i, n) { return this.builder.smoothCubicBezierCurveTo(t, e, i, n), this.dirty = !0, this } }, { key: "close", value: function () { return this.builder.close(), this.closePath = this.builder.closePath, this.dirty = !0, this } }, { key: "end", value: function () { return this.builder.end(), this.dirty = !0, this } }, { key: "rotateAround", value: function (t, e, i) { return this.builder.rotateAround(t, e, i), this.dirty = !0, this } }, { key: "offset", value: function (t, e) { return this.builder.offset(t, e), this.dirty = !0, this } }, { key: "toPolygon", value: function (t) { return this.builder.toPolygon(t) } }]), i }(), ml = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha, kl = function () { w(o, il); var r = T(o); function o(t, e, i, n) { var s; return z(this, o), void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = i), (s = r.call(this)).pathData = [], s.closePath = !0, s.setTopLeftPosition(t, e), s.setSize(i, n), s } return k(o, [{ key: "x", get: function () { return this._x }, set: function (t) { this.dirty = this.dirty || this._x !== t, this._x = t } }, { key: "y", get: function () { return this._y }, set: function (t) { this.dirty = this.dirty || this._y !== t, this._y = t } }, { key: "setTopLeftPosition", value: function (t, e) { return this.x = t, this.y = e, this } }, { key: "width", get: function () { return this._width }, set: function (t) { this.dirty = this.dirty || this._width !== t, this._width = t } }, { key: "height", get: function () { return this._height }, set: function (t) { this.dirty = this.dirty || this._height !== t, this._height = t } }, { key: "setSize", value: function (t, e) { return this.width = t, this.height = e, this } }, { key: "updateData", value: function () { this.pathData.length = 0; var t = this.x, e = t + this.width, i = this.y, n = i + this.height; return this.pathData.push(t, i), this.pathData.push(e, i), this.pathData.push(e, n), this.pathData.push(t, n), this.pathData.push(t, i), O(C(o.prototype), "updateData", this).call(this), this } }, { key: "webglRender", value: function (t, e, i, n, s) { if (this.isFilled) { var r = t.fillTint, o = ml(this.fillColor, this.fillAlpha * i); r.TL = o, r.TR = o, r.BL = o, r.BR = o, t.batchFillRect(-n + this.x, -s + this.y, this.width, this.height) } this.isStroked && St(t, this, i, n, s) } }, { key: "canvasRender", value: function (t, e, i) { this.isFilled && (Pt(t, this), t.fillRect(-e, -i, this.width, this.height)), this.isStroked && (Tt(t, this), t.beginPath(), t.rect(-e, -i, this.width, this.height), t.stroke()) } }]), o }(), bl = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha, xl = function () { w(h, il); var a = T(h); function h(t, e, i, n, s, r) { var o; return z(this, h), void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 0), (o = a.call(this)).pathData = [], o.closePath = !0, o.setP0(t, e), o.setP1(i, n), o.setP2(s, r), o } return k(h, [{ key: "x0", get: function () { return this._x0 }, set: function (t) { this.dirty = this.dirty || this._x0 !== t, this._x0 = t } }, { key: "y0", get: function () { return this._y0 }, set: function (t) { this.dirty = this.dirty || this._y0 !== t, this._y0 = t } }, { key: "setP0", value: function (t, e) { return this.x0 = t, this.y0 = e, this } }, { key: "x1", get: function () { return this._x1 }, set: function (t) { this.dirty = this.dirty || this._x1 !== t, this._x1 = t } }, { key: "y1", get: function () { return this._y1 }, set: function (t) { this.dirty = this.dirty || this._y1 !== t, this._y1 = t } }, { key: "setP1", value: function (t, e) { return this.x1 = t, this.y1 = e, this } }, { key: "x2", get: function () { return this._x2 }, set: function (t) { this.dirty = this.dirty || this._x2 !== t, this._x2 = t } }, { key: "y2", get: function () { return this._y2 }, set: function (t) { this.dirty = this.dirty || this._y2 !== t, this._y2 = t } }, { key: "setP2", value: function (t, e) { return this.dirty = this.dirty || this.x2 !== t || this.y2 !== e, this.x2 = t, this.y2 = e, this } }, { key: "updateData", value: function () { return this.pathData.length = 0, this.pathData.push(this.x0, this.y0), this.pathData.push(this.x1, this.y1), this.pathData.push(this.x2, this.y2), this.pathData.push(this.x0, this.y0), O(C(h.prototype), "updateData", this).call(this), this } }, { key: "webglRender", value: function (t, e, i, n, s) { if (this.isFilled) { var r = bl(this.fillColor, this.fillAlpha * i), o = this.x0 - n, a = this.y0 - s, h = this.x1 - n, l = this.y1 - s, u = this.x2 - n, c = this.y2 - s, d = e.getX(o, a), f = e.getY(o, a), p = e.getX(h, l), v = e.getY(h, l), g = e.getX(u, c), y = e.getY(u, c); t.batchTri(d, f, p, v, g, y, r, r, r) } this.isStroked && St(t, this, i, n, s) } }, { key: "canvasRender", value: function (t, e, i) { var n = this.x1 - e, s = this.y1 - i, r = this.x2 - e, o = this.y2 - i, a = this.x3 - e, h = this.y3 - i; t.beginPath(), t.moveTo(n, s), t.lineTo(r, o), t.lineTo(a, h), t.closePath(), this.isFilled && (Pt(t, this), t.fill()), this.isStroked && (Tt(t, this), t.stroke()) } }]), h }(), Cl = Phaser.Utils.Objects.GetValue, wl = Phaser.Utils.Objects.IsPlainObject, Sl = Phaser.Math.Clamp, Pl = Phaser.Math.Linear, Tl = Phaser.Math.Percent, Ol = Phaser.Math.DegToRad(270), Ml = Phaser.Math.RadToDeg, El = function () { w(d, tl); var c = T(d); function d(t, e, i, n, s, r, o) { var a; z(this, d), wl(e) && (e = Cl(o = e, "x", 0), i = Cl(o, "y", 0), n = Cl(o, "radius", 1), s = Cl(o, "barColor", void 0), r = Cl(o, "value", 0)); var h = 2 * n; (a = c.call(this, t, e, i, h, h)).type = "rexCircularProgress", a.eventEmitter = Cl(o, "eventEmitter", j(a)), a.addShape((new hl).setName("track")).addShape((new al).setName("bar")).addShape((new hl).setName("center")), a.setRadius(n), a.setTrackColor(Cl(o, "trackColor", void 0)), a.setBarColor(s), a.setCenterColor(Cl(o, "centerColor", void 0)), a.setThickness(Cl(o, "thickness", .2)), a.setStartAngle(Cl(o, "startAngle", Ol)), a.setAnticlockwise(Cl(o, "anticlockwise", !1)); var l = Cl(o, "valuechangeCallback", null); if (null !== l) { var u = Cl(o, "valuechangeCallbackScope", void 0); a.eventEmitter.on("valuechange", l, u) } return a.setEaseValuePropName("value").setEaseValueDuration(Cl(o, "easeValue.duration", 0)).setEaseValueFunction(Cl(o, "easeValue.ease", "Linear")), a.setValue(r), a } return k(d, [{ key: "resize", value: function (t, e) { return (t = Math.floor(Math.min(t, e))) === this.width || (O(C(d.prototype), "resize", this).call(this, t, t), this.setRadius(t / 2)), this } }, { key: "value", get: function () { return this._value }, set: function (t) { t = Sl(t, 0, 1); var e = this._value, i = e != t; this.dirty = this.dirty || i, this._value = t, i && this.eventEmitter.emit("valuechange", this._value, e, this.eventEmitter) } }, { key: "setValue", value: function (t, e, i) { return null == t || (void 0 !== e && (t = Tl(t, e, i)), this.value = t), this } }, { key: "addValue", value: function (t, e, i) { return void 0 !== e && (t = Tl(t, e, i)), this.value += t, this } }, { key: "getValue", value: function (t, e) { var i = this.value; return void 0 !== t && (i = Pl(t, e, i)), i } }, { key: "radius", get: function () { return this._radius }, set: function (t) { this.dirty = this.dirty || this._radius != t; var e = 2 * (this._radius = t); this.resize(e, e) } }, { key: "setRadius", value: function (t) { return this.radius = t, this } }, { key: "trackColor", get: function () { return this._trackColor }, set: function (t) { this.dirty = this.dirty || this._trackColor != t, this._trackColor = t } }, { key: "setTrackColor", value: function (t) { return this.trackColor = t, this } }, { key: "barColor", get: function () { return this._barColor }, set: function (t) { this.dirty = this.dirty || this._barColor != t, this._barColor = t } }, { key: "setBarColor", value: function (t) { return this.barColor = t, this } }, { key: "startAngle", get: function () { return this._startAngle }, set: function (t) { this.dirty = this.dirty || this._startAngle != t, this._startAngle = t } }, { key: "setStartAngle", value: function (t) { return this.startAngle = t, this } }, { key: "anticlockwise", get: function () { return this._anticlockwise }, set: function (t) { this.dirty = this.dirty || this._anticlockwise != t, this._anticlockwise = t } }, { key: "setAnticlockwise", value: function (t) { return void 0 === t && (t = !0), this.anticlockwise = t, this } }, { key: "thickness", get: function () { return this._thickness }, set: function (t) { t = Sl(t, 0, 1), this.dirty = this.dirty || this._thickness != t, this._thickness = t } }, { key: "setThickness", value: function (t) { return this.thickness = t, this } }, { key: "centerColor", get: function () { return this._centerColor }, set: function (t) { this.dirty = this.dirty || this._centerColor != t, this._centerColor = t } }, { key: "setCenterColor", value: function (t) { return this.centerColor = t, this } }, { key: "updateShapes", value: function () { var t = this.radius, e = this.thickness * this.radius, i = this.radius - e / 2, n = this.radius - e, s = this.getShape("track"); null != this.trackColor && 0 < e ? s.setCenterPosition(t, t).setRadius(i).lineStyle(e, this.trackColor) : s.reset(); var r = this.getShape("bar"); if (null != this.barColor && 0 < i) { var o, a, h; if (1 === this.value) o = !1, a = 0, h = 361; else o = this.anticlockwise, a = Ml(this.startAngle), h = 360 * (o ? 1 - this.value : this.value) + a; r.setCenterPosition(t, t).setRadius(i).setAngle(a, h, o).lineStyle(e, this.barColor) } else r.reset(); var l = this.getShape("center"); this.centerColor && 0 < n ? l.setCenterPosition(t, t).setRadius(n).fillStyle(this.centerColor) : l.reset() } }]), d }(); Object.assign(El.prototype, Wh), c.register("circularProgress", function (t, e, i, n, s, r) { var o = new El(this.scene, t, e, i, n, s, r); return this.scene.add.existing(o), o }), R(window, "RexPlugins.UI.CircularProgress", El); function _l(t) { return t.hasOwnProperty("rexSizer") || (t.rexSizer = {}), t.rexSizer } function Bl(t, e, i) { e instanceof Il || (i = e, e = void 0), void 0 === i ? i = new Rl : !0 === i && (i = Al); var n, s, r = t.sys.scale, o = r.baseSize, a = r.parentSize, h = r.canvasBounds, l = r.displayScale, u = 0 <= h.x ? 0 : -(h.x * l.x), c = 0 <= h.y ? 0 : -(h.y * l.y); if (n = a.width >= h.width ? o.width : o.width - (h.width - a.width) * l.x, s = a.height >= h.height ? o.height : o.height - (h.height - a.height) * l.y, i.setTo(u, c, n, s), e) { var d = e.scrollX, f = e.scrollY, p = 1 / e.zoomX, v = 1 / e.zoomY; i.width *= p, i.height *= v, i.centerX = e.centerX + d, i.centerY = e.centerY + f } return i } var Il = Phaser.Cameras.Scene2D.BaseCamera, Rl = Phaser.Geom.Rectangle, Al = new Rl, Dl = Phaser.Display.Align, Ll = { center: Dl.CENTER, left: Dl.LEFT_CENTER, right: Dl.RIGHT_CENTER, top: Dl.TOP_CENTER, bottom: Dl.BOTTOM_CENTER, "left-top": Dl.TOP_LEFT, "left-center": Dl.LEFT_CENTER, "left-bottom": Dl.BOTTOM_LEFT, "center-top": Dl.TOP_CENTER, "center-center": Dl.CENTER, "center-bottom": Dl.BOTTOM_CENTER, "right-top": Dl.TOP_RIGHT, "right-center": Dl.RIGHT_CENTER, "right-bottom": Dl.BOTTOM_RIGHT }, zl = new Phaser.GameObjects.Zone({ sys: { queueDepthSort: _, events: { once: _ } } }, 0, 0, 1, 1); zl.setOrigin(0); function jl(t) { return void 0 !== t.displayWidth ? t.displayWidth : t.width } function Fl(t) { return void 0 !== t.displayHeight ? t.displayHeight : t.height } function Yl(t) { var e = Fl(t); return t.y + e - e * t.originY } function Wl(t) { var e = jl(t); return t.x - e * t.originX + .5 * e } function Vl(t, e) { var i = Fl(t); return t.y = e - i + i * t.originY, t } function Xl(t, e) { var i = jl(t), n = i * t.originX; return t.x = e + n - .5 * i, t } function Gl(t) { var e = jl(t); return t.x - e * t.originX } function Ul(t, e) { var i = jl(t); return t.x = e + i * t.originX, t } function Hl(t) { var e = jl(t); return t.x + e - e * t.originX } function Nl(t, e) { var i = jl(t); return t.x = e - i + i * t.originX, t } function Jl(t, e) { var i = Fl(t), n = i * t.originY; return t.y = e + n - .5 * i, t } function Kl(t) { var e = Fl(t); return t.y - e * t.originY + .5 * e } function ql(t) { var e = Fl(t); return t.y - e * t.originY } function $l(t, e) { var i = Fl(t); return t.y = e + i * t.originY, t } var Zl = 0, Ql = 1, tu = 2, eu = 4, iu = 6, nu = 8, su = 10, ru = 12, ou = []; ou[11] = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), Xl(t, Wl(e) + i), Vl(t, Yl(e) + n), t }, ou[su] = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), Ul(t, Gl(e) - i), Vl(t, Yl(e) + n), t }, ou[ru] = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), Nl(t, Hl(e) + i), Vl(t, Yl(e) + n), t }, ou[iu] = function (t, e, i, n) { var s, r, o; return void 0 === i && (i = 0), void 0 === n && (n = 0), s = t, r = Wl(e) + i, o = Kl(e) + n, Xl(s, r), Jl(s, o), t }, ou[eu] = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), Ul(t, Gl(e) - i), Jl(t, Kl(e) + n), t }, ou[nu] = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), Nl(t, Hl(e) + i), Jl(t, Kl(e) + n), t }, ou[Ql] = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), Xl(t, Wl(e) + i), $l(t, ql(e) - n), t }, ou[Zl] = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), Ul(t, Gl(e) - i), $l(t, ql(e) - n), t }, ou[tu] = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), Nl(t, Hl(e) + i), $l(t, ql(e) - n), t }; function au(t, e, i, n, s) { return ou[i](t, e, n, s) } function hu(t, e, i, n, s, r) { zl.setPosition(e, i).setSize(n, s), au(t, zl, r) } function lu(t, e) { if (void 0 === e ? e = new Fu : !0 === e && (void 0 === Vu && (Vu = new Fu), e = Vu), t.getBounds) return t.getBounds(e); var i, n, s, r, o, a, h, l; if (t.parentContainer) { var u = t.parentContainer.getBoundsTransformMatrix(); Xu(t, e), u.transformPoint(e.x, e.y, e), i = e.x, n = e.y, Gu(t, e), u.transformPoint(e.x, e.y, e), s = e.x, r = e.y, Uu(t, e), u.transformPoint(e.x, e.y, e), o = e.x, a = e.y, Hu(t, e), u.transformPoint(e.x, e.y, e), h = e.x, l = e.y } else Xu(t, e), i = e.x, n = e.y, Gu(t, e), s = e.x, r = e.y, Uu(t, e), o = e.x, a = e.y, Hu(t, e), h = e.x, l = e.y; return e.x = Math.min(i, s, o, h), e.y = Math.min(n, r, a, l), e.width = Math.max(i, s, o, h) - e.x, e.height = Math.max(n, r, a, l) - e.y, e } function uu(t, e) { return void 0 === e && (e = {}), "number" == typeof t ? (e.left = t, e.right = t, e.top = t, e.bottom = t) : (e.left = Qu(t, "left", 0), e.right = Qu(t, "right", 0), e.top = Qu(t, "top", 0), e.bottom = Qu(t, "bottom", 0)), e } function cu(t) { return tc.call(this, t), this.sizerEventsEnable && (t.emit("sizer.add", t, this), this.emit("add", t, this)), this } function du(t, e) { return void 0 === this.childrenMap && (this.childrenMap = {}), this.childrenMap[t] = e, this } function fu(t) { return void 0 === t && (t = Math.max(this.childrenWidth, this.minWidth)), t } function pu(t) { var e = Math.max(this.childrenHeight, this.minHeight); return void 0 === t && (t = e), t } function vu() { this._childrenWidth = void 0, this._childrenHeight = void 0; for (var t, e = this.getChildrenSizers(), i = 0, n = e.length; i < n; i++)(t = e[i]).ignoreLayout || t.preLayout() } function gu(t) { var e, i; for (var n in this.sizerChildren) !(e = this.sizerChildren[n]) || e.isRexSizer && e.ignoreLayout || !e.runWidthWrap || (i = this.getExpandedChildWidth(e, t), e.isRexSizer && (i = e.resolveWidth(i)), e.runWidthWrap(i)); return this } function yu(t, e, i, n, s) { var r, o; switch (void 0 === n && (n = "Cubic"), i) { case 0: case "x": r = { x: 0 }, o = { x: t.scaleX }; break; case 1: case "y": r = { y: 0 }, o = { y: t.scaleY }; break; default: r = 0, o = t.scale }var a = { mode: 0, start: r, end: o, duration: e, ease: n }; return void 0 === s ? s = new lc(t, a) : s.resetFromJSON(a), s.restart(), s } function mu(t, e, i, n, s, r) { void 0 === n && (n = "Linear"), s instanceof lc && (r = s, s = void 0), void 0 === s && (s = !0); var o = {}; switch (o.mode = s ? 1 : 0, i) { case 0: case "x": o.end = { x: 0 }; break; case 1: case "y": o.end = { y: 0 }; break; default: o.end = 0 }return o.duration = e, o.ease = n, void 0 === r ? r = new lc(t, o) : r.resetFromJSON(o), r.restart(), r } function ku(e, t) { t.completeEventName = void 0, t.on("complete", function () { t.completeEventName && (e.emit(t.completeEventName, e), t.completeEventName = void 0) }), t.on("update", function () { var t = e.getParentSizer(); t && t.resetChildPositionState(e) }) } function bu(t, e, i, n) { var s, r; r = mc(i) ? (s = i.start, i.end) : i, void 0 === s && (s = 0), void 0 === r && (r = 1); var o = { mode: 0, start: s, end: r, duration: e }; return void 0 === n ? n = new gc(t, o) : n.resetFromJSON(o), n.restart(), n } function xu(t, e, i, n) { i instanceof gc && (n = i, i = void 0), void 0 === i && (i = !0); var s = { mode: i ? 1 : 0, end: 0, duration: e }; return void 0 === n ? n = new gc(t, s) : n.resetFromJSON(s), n.restart(), n } function Cu(e, t) { t.completeEventName = void 0, t.on("complete", function () { t.completeEventName && (e.emit(t.completeEventName, e), t.completeEventName = void 0) }), t.on("update", function () { var t = e.getParentSizer(); t && t.resetChildAlphaState(e) }) } function wu(t, e) { if ("number" == typeof t) return t; var i = t[0], n = parseFloat(t.substr(2)); switch (i) { case "+": return e + n; case "-": return e - n; case "*": return e * n; case "/": return e / n } } function Su(t, e, i, n, s, r, o) { r instanceof Sc && (o = r, r = void 0), void 0 === r && (r = !1); var a = {}; return a.mode = r ? 1 : 0, void 0 !== i && (a.startX = t.x, a.endX = wu(i, t.x)), void 0 !== n && (a.startY = t.y, a.endY = wu(n, t.y)), a.duration = e, a.ease = void 0 === s ? "Linear" : s, void 0 === o ? o = new Sc(t, a) : o.resetFromJSON(a), o.restart(), o } function Pu(t, e, i, n, s, r, o) { r instanceof Sc && (o = r, r = void 0), void 0 === r && (r = !1); var a = {}; return a.mode = r ? 1 : 0, void 0 !== i && (a.startX = wu(i, t.x), a.endX = t.x), void 0 !== n && (a.startY = wu(n, t.y), a.endY = t.y), a.duration = e, a.ease = void 0 === s ? "Linear" : s, void 0 === o ? o = new Sc(t, a) : o.resetFromJSON(a), o.restart(), o } function Tu(e, t) { t.completeEventName = void 0, t.on("complete", function () { t.completeEventName && (e.emit(t.completeEventName, e), t.completeEventName = void 0) }), t.on("update", function () { var t = e.getParentSizer(); t && t.resetChildPositionState(e) }) } function Ou(t) { jc(t, !1) } function Mu(t) { jc(t, !0) } function Eu(t) { return !!t && !_l(t).hidden } function _u(t, e, i, n, s) { return !(!t || !t.getBounds) && (!(n && !n(t, e, i)) && (!!lu(t, !0).contains(e, i) && !(s && !s(t, e, i)))) } function Bu(t, e, i, n) { if (e) return _u(t, e.worldX, e.worldY, i, n); for (var s = t.scene.input.manager, r = s.pointersTotal, o = s.pointers, a = 0; a < r; a++)if (e = o[a], _u(t, e.worldX, e.worldY, i, n)) return !0; return !1 } function Iu(t) { return t && "function" == typeof t } function Ru(t) { return "[object Array]" === Object.prototype.toString.call(t) } function Au(t, e, i, n, s) { return _u(t, e, i, Yc(n), Wc(s)) } function Du(t) { return !(t.rexSizer && t.rexSizer.hidden) } function Lu(t, e, i) { !t || void 0 === e && void 0 === i || (t.resize ? (void 0 === e && (e = t.width), void 0 === i && (i = t.height), t.resize(e, i)) : (void 0 !== e && (t.displayWidth = e), void 0 !== i && (t.displayHeight = i))) } function zu(t) { var e, i; this.sizerEventsEnable && (e = t, void 0 === (i = this.getChildPrevState(t)) ? i = {} : !0 === i && (i = Vc), i.x = e.x, i.y = e.y, i.scaleX = e.scaleX, i.scaleY = e.scaleY, i.width = e.width, i.height = e.height, i.displayWidth = e.displayWidth, i.displayHeight = e.displayHeight, this.layoutedChildren.push(t)) } function ju(t, e, i, n, s, r, o, a) { hu(t, e, i, n, s, r), void 0 !== o && (t.x += o), void 0 !== a && (t.y += a), this.resetChildPositionState(t), this.sizerEventsEnable && t.emit("sizer.postlayout", t, this) } var Fu = Phaser.Geom.Rectangle, Yu = Phaser.Math.Vector2, Wu = Phaser.Math.RotateAround, Vu = void 0, Xu = function (t, e, i) { return void 0 === e ? e = new Yu : !0 === e && (void 0 === Nu && (Nu = new Yu), e = Nu), t.getTopLeft ? t.getTopLeft(e) : (e.x = t.x - jl(t) * t.originX, e.y = t.y - Fl(t) * t.originY, Ju(t, e, i)) }, Gu = function (t, e, i) { return void 0 === e ? e = new Yu : !0 === e && (void 0 === Nu && (Nu = new Yu), e = Nu), t.getTopRight ? t.getTopRight(e) : (e.x = t.x - jl(t) * t.originX + jl(t), e.y = t.y - Fl(t) * t.originY, Ju(t, e, i)) }, Uu = function (t, e, i) { return void 0 === e ? e = new Yu : !0 === e && (void 0 === Nu && (Nu = new Yu), e = Nu), t.getBottomLeft ? t.getBottomLeft(e) : (e.x = t.x - jl(t) * t.originX, e.y = t.y - Fl(t) * t.originY + Fl(t), Ju(t, e, i)) }, Hu = function (t, e, i) { return void 0 === e ? e = new Yu : !0 === e && (void 0 === Nu && (Nu = new Yu), e = Nu), t.getBottomRight ? t.getBottomRight(e) : (e.x = t.x - jl(t) * t.originX + jl(t), e.y = t.y - Fl(t) * t.originY + Fl(t), Ju(t, e, i)) }, Nu = void 0, Ju = function (t, e, i) { void 0 === i && (i = !1), 0 !== t.rotation && Wu(e, t.x, t.y, t.rotation), i && t.parentContainer && t.parentContainer.getBoundsTransformMatrix().transformPoint(e.x, e.y, e); return e }, Ku = Phaser.Utils.Objects.GetValue, qu = Phaser.GameObjects.Group, $u = function (t) { return t.add.text(0, 0, "") }, Zu = void 0, Qu = Phaser.Utils.Objects.GetValue, tc = dr.prototype.add, ec = { addBackground: function (t, e, i) { return void 0 === this.backgroundChildren && (this.backgroundChildren = []), "string" == typeof e && (i = e, e = void 0), void 0 === e && (e = 0), cu.call(this, t), this.backgroundChildren.push(t), this.getSizerConfig(t).padding = uu(e), void 0 !== i && this.addChildrenMap(i, t), this }, isBackground: function (t) { return void 0 !== this.backgroundChildren && -1 !== this.backgroundChildren.indexOf(t) } }, ic = /(\S+)\[(\d+)\]/i, nc = { getInnerPadding: function (t) { return mr(this.space, t) }, setInnerPadding: function (t, e) { return kr(this.space, t, e), this }, getOuterPadding: function (t) { return mr(this.getSizerConfig(this).padding, t) }, setOuterPadding: function (t, e) { return kr(this.getSizerConfig(this).padding, t, e), this }, getChildOuterPadding: function (t, e) { return "string" == typeof t && (t = this.getElement(t)), mr(this.getSizerConfig(t).padding, e) }, setChildOuterPadding: function (t, e, i) { return "string" == typeof t && (t = this.getElement(t)), kr(this.getSizerConfig(t).padding, e, i), this } }, sc = { getShownChildren: function (t) { void 0 === t && (t = []); for (var e, i = this.children, n = 0, s = i.length; n < s; n++)(e = i[n]).rexSizer && e.rexSizer.hidden || t.push(e); return t }, getAllShownChildren: function (t) { void 0 === t && (t = []); for (var e, i = this.children, n = 0, s = i.length; n < s; n++) { if (!(e = i[n]).rexSizer || !e.rexSizer.hidden) if (t.push(e), e.hasOwnProperty("isRexContainerLite")) t.push.apply(t, M(e.getAllShownChildren())) } return t } }, rc = function () { w(s, Ta); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, t, { eventEmitter: !1 })).viewport = void 0, i.resetFromJSON(e), i } return k(s, [{ key: "resetFromJSON", value: function (t) { var e, i, n, s, r, o, a, h; void 0 === t && (t = {}), void 0 !== t.x ? (e = null, i = t.x) : void 0 !== t.left ? (e = 0, i = t.left) : void 0 !== t.right ? (e = 1, i = t.right) : void 0 !== t.centerX && (e = .5, i = t.centerX), void 0 !== t.y ? (n = null, s = t.y) : void 0 !== t.top ? (n = 0, s = t.top) : void 0 !== t.bottom ? (n = 1, s = t.bottom) : void 0 !== t.centerY && (n = .5, s = t.centerY), void 0 !== i && (i = i.replace("left", "0%").replace("right", "100%").replace("center", "50%").split("%"), r = parseFloat(i[0]) / 100, o = "" === i[1] ? 0 : parseFloat(i[1])), void 0 !== s && (s = s.replace("top", "0%").replace("bottom", "100%").replace("center", "50%").split("%"), a = parseFloat(s[0]) / 100, h = "" === s[1] ? 0 : parseFloat(s[1])); var l, u, c = t.width; void 0 !== c && (c = c.split("%"), l = parseFloat(c[0]) / 100, u = "" === c[1] ? 0 : parseFloat(c[1])); var d, f, p = t.height; void 0 !== p && (p = p.split("%"), d = parseFloat(p[0]) / 100, f = "" === p[1] ? 0 : parseFloat(p[1])), this.setAlign(e, n), this.setPercentage(r, a), this.setOffset(o, h), this.setSizePercentage(l, d), this.setSizePadding(u, f); var v = t.onResizeCallback, g = t.onResizeCallbackScope; void 0 !== v && this.setResizeCallback(v, g); var y = t.onUpdateViewportCallback, m = t.onUpdateViewportCallbackScope; return void 0 !== y && this.setUpdateViewportCallback(y, m), this.autoAnchor(t.enable), this } }, { key: "shutdown", value: function (t) { this.isShutdown || (this.autoAnchor(!1), this.viewport = void 0, this.onUpdateViewportCallback = void 0, this.onUpdateViewportCallbackScope = void 0, this.onResizeCallback = void 0, this.onResizeCallbackScope = void 0, O(C(s.prototype), "shutdown", this).call(this, t)) } }, { key: "autoAnchor", value: function (t) { return void 0 === t && (t = !0), t = !!t, this.autoAnchorEnable === t || (t ? (this.scene.sys.scale.on("resize", this.anchor, this), this.anchor()) : this.scene.sys.scale.off("resize", this.anchor, this), this.autoAnchorEnable = t), this } }, { key: "setAlign", value: function (t, e) { return this.alignX = t, this.alignY = e, this } }, { key: "setPercentage", value: function (t, e) { return this.percentageX = t, this.percentageY = e, this } }, { key: "setOffset", value: function (t, e) { return this.offsetX = t, this.offsetY = e, this } }, { key: "setSizePercentage", value: function (t, e) { return this.percentageWidth = t, this.percentageHeight = e, this } }, { key: "setSizePadding", value: function (t, e) { return this.paddingWidth = t, this.paddingHeight = e, this } }, { key: "setResizeCallback", value: function (t, e) { return this.onResizeCallback = t, this.onResizeCallbackScope = e, this } }, { key: "setUpdateViewportCallback", value: function (t, e) { return this.onUpdateViewportCallback = t, this.onUpdateViewportCallbackScope = e, this } }, { key: "anchor", value: function () { return this.updateViewport(), this.updateSize(), this.updatePosition(), this } }, { key: "updateSize", value: function () { var t = this.onResizeCallback, e = this.onResizeCallbackScope, i = this.anchorWidth, n = this.anchorHeight; if ((void 0 !== i || void 0 !== n) && t) { var s = this.parent; void 0 === i && (i = s.width), void 0 === n && (n = s.height), e ? t.call(e, i, n, s, this) : t(i, n, s, this) } } }, { key: "updatePosition", value: function () { var t = this.parent; return null === this.alignX ? t.x = this.anchorX : void 0 !== this.alignX && (t.x = this.anchorX + t.displayWidth * (t.originX - this.alignX)), null === this.alignY ? t.y = this.anchorY : void 0 !== this.alignY && (t.y = this.anchorY + t.displayHeight * (t.originY - this.alignY)), this } }, { key: "anchorX", get: function () { return this.viewport.x + this.viewport.width * this.percentageX + this.offsetX } }, { key: "anchorY", get: function () { return this.viewport.y + this.viewport.height * this.percentageY + this.offsetY } }, { key: "anchorWidth", get: function () { if (void 0 !== this.percentageWidth) return this.viewport.width * this.percentageWidth + this.paddingWidth } }, { key: "anchorHeight", get: function () { if (void 0 !== this.percentageHeight) return this.viewport.height * this.percentageHeight + this.paddingHeight } }, { key: "updateViewport", value: function () { var t = this.parent.scene.cameras.main; this.viewport = Bl(this.scene, t, this.viewport); var e = this.viewport, i = this.onUpdateViewportCallback, n = this.onUpdateViewportCallbackScope; i && (n ? i.call(n, e, this.parent, this) : i(e, this.parent, this)) } }]), s }(), oc = Phaser.Utils.Objects.GetValue, ac = Phaser.Utils.Objects.GetAdvancedValue, hc = Phaser.Math.Linear, lc = function () { w(s, ah); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, t, e)).scaleStart = {}, i.scaleEnd = {}, i.resetFromJSON(e), i.boot(), i } return k(s, [{ key: "resetFromJSON", value: function (t) { return O(C(s.prototype), "resetFromJSON", this).call(this, t), this.setMode(oc(t, "mode", 0)), this.setScaleRange(ac(t, "start", void 0), ac(t, "end", 0)), this } }, { key: "setMode", value: function (t) { return "string" == typeof t && (t = uc[t]), this.mode = t, this } }, { key: "setScaleRange", value: function (t, e) { return "number" == typeof t ? (this.startX = t, this.startY = t) : (this.startX = ac(t, "x", this.parent.scaleX), this.startY = ac(t, "y", this.parent.scaleY)), "number" == typeof e ? (this.endX = e, this.endY = e) : (this.endX = ac(e, "x", void 0), this.endY = ac(e, "y", void 0)), this.hasScaleX = void 0 !== this.startX && void 0 !== this.endX, this.hasScaleY = void 0 !== this.startY && void 0 !== this.endY, this } }, { key: "start", value: function () { if (this.timer.isRunning) return this; var t = this.parent; this.hasScaleX && (t.scaleX = this.startX), this.hasScaleY && (t.scaleY = this.startY); var e = this.repeat; return 2 === this.mode && -1 !== e && (e = 2 * (e + 1) - 1), this.timer.setDelay(this.delay).setDuration(this.duration).setRepeat(e), O(C(s.prototype), "start", this).call(this), this } }, { key: "updateGameObject", value: function (t, e) { var i = e.t; e.isOddIteration && (i = 1 - i), i = this.easeFn(i), this.hasScaleX && (t.scaleX = hc(this.startX, this.endX, i)), this.hasScaleY && (t.scaleY = hc(this.startY, this.endY, i)) } }, { key: "complete", value: function () { return O(C(s.prototype), "complete", this).call(this), 1 === this.mode && this.parent.destroy(), this } }]), s }(), uc = { stop: 0, destroy: 1, yoyo: 2 }, cc = Phaser.Utils.Objects.IsPlainObject, dc = { popUp: function (t, e, i) { if (cc(t)) { var n = t; t = n.duration, e = n.orientation, i = n.ease } var s = void 0 === this._scale; return this._scale = yu(this, t, e, i, this._scale), s && ku(this, this._scale), this._scale.completeEventName = "popup.complete", this }, popUpPromise: function (t, e, i) { return this.popUp(t, e, i), _o(this._scale) }, scaleDownDestroy: function (t, e, i, n) { if (cc(t)) { var s = t; t = s.duration, e = s.orientation, i = s.ease, n = s.destroy } var r = void 0 === this._scale; return this._scale = mu(this, t, e, i, n, this._scale), r && ku(this, this._scale), this._scale.completeEventName = "scaledown.complete", this }, scaleDownDestroyPromise: function (t, e, i, n) { return this.scaleDownDestroy(t, e, i, n), _o(this._scale) }, scaleDown: function (t, e, i) { return this.scaleDownDestroy(t, e, i, !1), this }, scaleDownPromise: function (t, e, i) { return this.scaleDown(t, e, i), _o(this._scale) }, scaleYoyo: function (t, e, i, n, s) { if (cc(t)) { var r = t; t = r.duration, e = r.peakValue, i = r.repeat, n = r.orientation, s = r.ease } var o = void 0 === this._scale; return this._scale = function (t, e, i, n, s, r, o) { var a, h; switch (void 0 === i && (i = 1.2), void 0 === n && (n = 0), void 0 === r && (r = "Cubic"), s) { case 0: case "x": a = { x: t.scaleX }, h = { x: i }; break; case 1: case "y": a = { y: t.scaleX }, h = { y: i }; break; default: a = t.scaleX, h = i }var l = { mode: 2, start: a, end: h, duration: e / 2, ease: r, repeat: n }; return void 0 === o ? o = new lc(t, l) : o.resetFromJSON(l), o.restart(), o }(this, t, e, i, n, s, this._scale), o && ku(this, this._scale), this._scale.completeEventName = "scaleyoyo.complete", this }, scaleYoyoPromise: function (t, e, i, n, s) { return this.scaleYoyo(t, e, i, n, s), _o(this._scale) } }, fc = Phaser.Utils.Objects.GetValue, pc = Phaser.Utils.Objects.GetAdvancedValue, vc = Phaser.Math.Linear, gc = function () { w(s, ah); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, t, e)).resetFromJSON(e), i.boot(), i } return k(s, [{ key: "resetFromJSON", value: function (t) { return O(C(s.prototype), "resetFromJSON", this).call(this, t), this.setMode(fc(t, "mode", 0)), this.setAlphaRange(pc(t, "start", this.parent.alpha), pc(t, "end", 0)), this } }, { key: "setMode", value: function (t) { return "string" == typeof t && (t = yc[t]), this.mode = t, this } }, { key: "setAlphaRange", value: function (t, e) { return this.alphaStart = t, this.alphaEnd = e, this } }, { key: "start", value: function () { return this.timer.isRunning || (this.parent.setAlpha(this.alphaStart), this.timer.setDelay(this.delay).setDuration(this.duration).setRepeat(2 === this.mode ? -1 : 0), O(C(s.prototype), "start", this).call(this)), this } }, { key: "updateGameObject", value: function (t, e) { var i = e.t; e.isOddIteration && (i = 1 - i), t.alpha = vc(this.alphaStart, this.alphaEnd, i) } }, { key: "complete", value: function () { return O(C(s.prototype), "complete", this).call(this), 1 === this.mode && this.parent.destroy(), this } }]), s }(), yc = { stop: 0, destroy: 1, yoyo: 2 }, mc = Phaser.Utils.Objects.IsPlainObject, kc = Phaser.Utils.Objects.IsPlainObject, bc = { fadeIn: function (t, e) { if (kc(t)) { var i = t; t = i.duration, e = i.alpha } var n = void 0 === this._fade; return this._fade = bu(this, t, e, this._fade), n && Cu(this, this._fade), this._fade.completeEventName = "fadein.complete", this }, fadeInPromise: function (t, e) { return this.fadeIn(t, e), _o(this._fade) }, fadeOutDestroy: function (t, e) { if (kc(t)) { var i = t; t = i.duration, e = i.destroy } var n = void 0 === this._fade; return this._fade = xu(this, t, e, this._fade), n && Cu(this, this._fade), this._fade.completeEventName = "fadeout.complete", this }, fadeOutDestroyPromise: function (t, e) { return this.fadeOutDestroy(t, e), _o(this._fade) }, fadeOut: function (t) { return this.fadeOutDestroy(t, !1), this }, fadeOutPromise: function (t) { return this.fadeOut(t), _o(this._fade) } }, xc = Phaser.Utils.Objects.GetValue, Cc = Phaser.Utils.Objects.GetAdvancedValue, wc = Phaser.Math.Linear, Sc = function () { w(s, ah); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, t, e)).resetFromJSON(e), i.boot(), i } return k(s, [{ key: "resetFromJSON", value: function (t) { if (O(C(s.prototype), "resetFromJSON", this).call(this, t), this.setMode(xc(t, "mode", 0)), t && (t.hasOwnProperty("x") || t.hasOwnProperty("y"))) { var e = Cc(t, "x", void 0), i = Cc(t, "y", void 0); this.setTargetPosition(e, i) } else this.setTargetPosition(t); return this } }, { key: "setMode", value: function (t) { return "string" == typeof t && (t = Pc[t]), this.mode = t, this } }, { key: "setTargetPosition", value: function (t, e) { if ("number" == typeof t || "number" == typeof e) this.startX = this.parent.x, this.startY = this.parent.y, this.endX = t, this.endY = e; else { var i = t; this.startX = Cc(i, "startX", void 0), this.startY = Cc(i, "startY", void 0), this.endX = Cc(i, "endX", void 0), this.endY = Cc(i, "endY", void 0) } return this.hasMoveX = void 0 !== this.startX && void 0 !== this.endX, this.hasMoveY = void 0 !== this.startY && void 0 !== this.endY, this } }, { key: "start", value: function () { if (this.timer.isRunning) return this; var t = this.parent; return this.hasMoveX && (t.x = this.startX), this.hasMoveY && (t.y = this.startY), this.timer.setDelay(this.delay).setDuration(this.duration).setRepeat(2 === this.mode ? -1 : 0), O(C(s.prototype), "start", this).call(this), this } }, { key: "updateGameObject", value: function (t, e) { var i = e.t; e.isOddIteration && (i = 1 - i), i = this.easeFn(i), this.hasMoveX && (t.x = wc(this.startX, this.endX, i)), this.hasMoveY && (t.y = wc(this.startY, this.endY, i)) } }, { key: "complete", value: function () { return O(C(s.prototype), "complete", this).call(this), 1 === this.mode && this.parent.destroy(), this } }]), s }(), Pc = { stop: 0, destroy: 1, yoyo: 2 }, Tc = Phaser.Utils.Objects.IsPlainObject, Oc = Phaser.Math.Distance.Between, Mc = { moveFrom: function (t, e, i, n, s) { if (Tc(t)) { var r = t; e = r.x, i = r.y, t = r.hasOwnProperty("speed") ? 1e3 * Oc(e, i, this.x, this.y) / r.speed : r.duration, n = r.ease } var o = void 0 === this._easeMove; return this._easeMove = Pu(this, t, e, i, n, s, this._easeMove), o && Tu(this, this._easeMove), this._easeMove.completeEventName = "movefrom.complete", this }, moveFromPromise: function (t, e, i, n, s) { return this.moveFrom(t, e, i, n, s), _o(this._easeMove) }, moveFromDestroy: function (t, e, i, n) { return this.moveFrom(t, e, i, n, !0), this }, moveFromDestroyPromise: function (t, e, i, n) { return this.moveFromDestroy(t, e, i, n), _o(this._easeMove) }, moveTo: function (t, e, i, n, s) { if (Tc(t)) { var r = t; e = r.x, i = r.y, t = r.hasOwnProperty("speed") ? 1e3 * Oc(e, i, this.x, this.y) / r.speed : r.duration, n = r.ease } var o = void 0 === this._easeMove; return this._easeMove = Su(this, t, e, i, n, s, this._easeMove), o && Tu(this, this._easeMove), this._easeMove.completeEventName = "moveto.complete", this }, moveToPromise: function (t, e, i, n, s) { return this.moveTo(t, e, i, n, s), _o(this._easeMove) }, moveToDestroy: function (t, e, i, n) { return this.moveTo(t, e, i, n, !0), this }, moveToDestroyPromise: function (t, e, i, n) { return this.moveToDestroy(t, e, i, n, !0), _o(this._easeMove) }, moveStop: function (t) { return this._easeMove && this._easeMove.stop(t), this } }, Ec = Phaser.Utils.Objects.GetValue, _c = function () { w(s, Ma); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, t, e)).timer = new Za, i.resetFromJSON(e), i.boot(), i } return k(s, [{ key: "resetFromJSON", value: function (t) { return this.timer.resetFromJSON(Ec(t, "timer")), this.setEnable(Ec(t, "enable", !0)), this.setMode(Ec(t, "mode", 1)), this.isRunning = Ec(t, "isRunning", !1), this.setMagnitudeMode(Ec(t, "magnitudeMode", 1)), this.setDuration(Ec(t, "duration", 500)), this.setMagnitude(Ec(t, "magnitude", 10)), this.ox = Ec(t, "ox", void 0), this.oy = Ec(t, "oy", void 0), this } }, { key: "toJSON", value: function () { return { timer: this.timer.toJSON(), enable: this.enable, mode: this.mode, isRunning: this.isRunning, magnitudeMode: magnitudeMode, duration: this.duration, magnitude: this.magnitude, ox: this.ox, oy: this.oy } } }, { key: "shutdown", value: function (t) { this.isShutdown || (O(C(s.prototype), "shutdown", this).call(this, t), this.timer.destroy(), this.timer = void 0) } }, { key: "startTicking", value: function () { O(C(s.prototype), "startTicking", this).call(this), 0 === this.mode ? (this.scene.game.events.on("poststep", this.update, this), this.scene.game.events.on("prestep", this.backToOrigin, this)) : this.scene.sys.events.on("preupdate", this.update, this) } }, { key: "stopTicking", value: function () { O(C(s.prototype), "stopTicking", this).call(this), this.scene && (0 === this.mode ? (this.scene.game.events.off("poststep", this.update, this), this.scene.game.events.off("prestep", this.backToOrigin, this)) : this.scene.sys.events.off("preupdate", this.update, this)) } }, { key: "setEnable", value: function (t) { return null == t && (t = !0), this.enable = t, this } }, { key: "setMode", value: function (t) { return "string" == typeof t && (t = Bc[t]), this.mode = t, this } }, { key: "setMagnitudeMode", value: function (t) { return "string" == typeof t && (t = Ic[t]), this.magnitudeMode = t, this } }, { key: "setDuration", value: function (t) { return this.duration = t, this } }, { key: "setMagnitude", value: function (t) { return this.magnitude = t, this } }, { key: "start", value: function (t, e) { if ("number" != typeof t) { var i = t; e = Ec(i, "magnitude", void 0), t = Ec(i, "duration", void 0) } return void 0 !== e && this.setMagnitude(e), void 0 !== t && this.setDuration(t), this.timer.setDuration(this.duration).start(), O(C(s.prototype), "start", this).call(this), this } }, { key: "shake", value: function (t, e) { return this.start(t, e), this } }, { key: "update", value: function (t, e) { if (!this.isRunning || !this.enable) return this; var i = this.parent; if (!i.active) return this; if (this.timer.update(t, e), this.timer.isDone) this.backToOrigin(), this.complete(); else { void 0 === this.ox && (this.ox = i.x, this.oy = i.y); var n = this.magnitude; 1 === this.magnitudeMode && (n *= 1 - this.timer.t); var s = Math.random() * Math.PI * 2, r = Math.cos(s) * n, o = Math.sin(s) * n; i.setPosition(this.ox + r, this.oy + o) } return this } }, { key: "backToOrigin", value: function () { if (!this.isRunning || !this.enable) return this; if (void 0 === this.ox) return this; var t = this.parent; return this.ox === t.x && this.oy === t.y || (t.setPosition(this.ox, this.oy), this.ox = void 0, this.oy = void 0), this } }]), s }(), Bc = { effect: 0, behavior: 1 }, Ic = { constant: 0, decay: 1 }, Rc = Phaser.Utils.Objects.IsPlainObject, Ac = { shake: function (t, e, i) { if (Rc(t)) { var n = t; t = n.duration, e = n.magnitude, i = n.magnitudeMode } var s; return void 0 === this._shake && (this._shake = new _c(this, { mode: 0, magnitudeMode: 1 }), (s = this)._shake.on("complete", function () { s.emit("shake.complete", s) })), void 0 !== t && this._shake.setDuration(t), void 0 !== e && this._shake.setMagnitude(e), void 0 !== i && this._shake.setMagnitudeMode(i), this._shake.shake(), this }, shakePromise: function (t, e) { return this.shake(t, e), _o(this._shake) } }, Dc = Phaser.Utils.Objects.IsPlainObject, Lc = function () { w(s, Ta); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, t, e)).parent.setDataEnabled(), i.easeTasks = {}, i } return k(s, [{ key: "complete", value: function (t) { this.emit("complete-".concat(t), this.parent, this), this.emit("complete", t, this.parent, this) } }, { key: "getEaseTask", value: function (t) { var e = this.easeTasks[t]; return void 0 === e && (e = new Fh(this.parent), (this.easeTasks[t] = e).setTarget(this.parent.data.values).on("complete", function () { this.complete(t) }, this)), e } }, { key: "easeTo", value: function (t, e, i, n) { if (Dc(t)) { var s = t; t = s.key, e = s.value, i = s.duration, n = s.ease; var r = s.speed; void 0 === i && void 0 !== r && (i = Math.abs(e - this.parent.data.values[t]) / r * 1e3) } return void 0 === i && (i = 1e3), void 0 === n && (n = "Linear"), this.getEaseTask(t).restart({ key: t, to: e, duration: i, ease: n }), this } }, { key: "easeFrom", value: function (t, e, i, n) { if (Dc(t)) { var s = t; t = s.key, e = s.value, i = s.duration, n = s.ease; var r = s.speed; void 0 === i && void 0 !== r && (i = Math.abs(e - this.parent.data.values[t]) / r * 1e3) } return void 0 === i && (i = 1e3), void 0 === n && (n = "Linear"), this.getEaseTask(t).restart({ key: t, from: e, duration: i, ease: n }), this } }, { key: "stopEase", value: function (t, e) { void 0 === e && (e = !0); var i = this.easeTasks[t]; return i && i.stop(e), this } }, { key: "stopAll", value: function (t) { for (var e in void 0 === t && (t = !0), this.easeTasks) this.stopEase(e, t); return this } }]), s }(), zc = { easeDataTo: function (t, e, i, n) { var s; return this._easeData || (this._easeData = new Lc(this), (s = this)._easeData.on("complete", function (t) { s.emit("easedata.".concat(t, ".complete"), s), s.emit("easedata.complete", t, s) })), this._easeData.easeTo(t, e, i, n), this }, easeDataToPromise: function (t, e, i, n) { return this.easeDataTo(t, e, i, n), Eo(this._easeData, "complete-".concat(t)) }, stopEaseData: function (t, e) { return this._easeData && this._easeData.stopEase(t, e), this }, stopAllEaseData: function (t) { return this._easeData && this._easeData.stopAll(t), this } }, jc = function (t, e) { if (t) { _l(t).hidden = e; var i = Ts(t); i ? i.setChildVisible(t, !e) : t.setVisible(!e) } }, Fc = { show: function (t) { return void 0 === t && (t = this), Ou(t), this }, hide: function (t) { return void 0 === t && (t = this), Mu(t), this }, isShow: function (t) { return void 0 === t && (t = this), Eu(t) } }, Yc = function (n) { return n ? function (t, e, i) { return !!Du(t) && (n(t, e, i), !0) } : Du }, Wc = function (t) { return t }, Vc = {}, Xc = Phaser.Display.Align.CENTER, Gc = Phaser.Utils.Objects.GetValue, Uc = function () { w(s, Ta); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, t, e))._enable = void 0, t.setInteractive(Gc(e, "inputConfig", void 0)), i.resetFromJSON(e), i.boot(), i } return k(s, [{ key: "resetFromJSON", value: function (t) { return this.pointer = void 0, this.lastClickTime = void 0, this.setEnable(Gc(t, "enable", !0)), this.setMode(Gc(t, "mode", 1)), this.setClickInterval(Gc(t, "clickInterval", 100)), this.setDragThreshold(Gc(t, "threshold", void 0)), this } }, { key: "boot", value: function () { var t = this.parent; t.on("pointerdown", this.onPress, this), t.on("pointerup", this.onRelease, this), t.on("pointerout", this.onPointOut, this), t.on("pointermove", this.onMove, this), t.on("pointerover", this.onOver, this), t.on("pointeroutr", this.onOut, this) } }, { key: "shutdown", value: function (t) { this.isShutdown || (this.pointer = null, O(C(s.prototype), "shutdown", this).call(this, t)) } }, { key: "enable", get: function () { return this._enable }, set: function (t) { if (this._enable !== t) { t || this.cancel(); var e = (this._enable = t) ? "enable" : "disable"; this.emit(e, this, this.parent) } } }, { key: "setEnable", value: function (t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "toggleEnable", value: function () { return this.setEnable(!this.enable), this } }, { key: "setMode", value: function (t) { return "string" == typeof t && (t = Hc[t]), this.mode = t, this } }, { key: "setClickInterval", value: function (t) { return this.clickInterval = t, this } }, { key: "setDragThreshold", value: function (t) { return this.dragThreshold = t, this } }, { key: "onPress", value: function (t, e, i, n) { void 0 === this.pointer && (this.pointer = t, 0 === this.mode && this.click(t.downTime, t, n)) } }, { key: "onRelease", value: function (t, e, i, n) { this.pointer === t && (1 === this.mode && this.click(t.upTime, t, n), this.pointer = void 0) } }, { key: "onPointOut", value: function (t) { this.pointer === t && this.cancel() } }, { key: "onMove", value: function (t) { this.pointer === t && void 0 !== this.dragThreshold && t.getDistance() >= this.dragThreshold && this.cancel() } }, { key: "click", value: function (t, e, i) { if (!this.enable) return this; if (void 0 === t) return this.emit("click", this, this.parent, e, i), this; this.pointer = void 0; var n = this.lastClickTime; return void 0 !== n && t - n <= this.clickInterval || (this.lastClickTime = t, this.emit("click", this, this.parent, e, i)), this } }, { key: "cancel", value: function () { return this.pointer = void 0, this } }, { key: "onOver", value: function (t, e, i, n) { return this.enable && this.emit("over", this, this.parent, t, n), this } }, { key: "onOut", value: function (t, e) { return this.enable && this.emit("out", this, this.parent, t, e), this } }]), s }(), Hc = { press: 0, pointerdown: 0, release: 1, pointerup: 1 }, Nc = { onClick: function (t, e, i) { return t && (void 0 === this._click && (this._click = new Uc(this, i)), this._click.on("click", t, e)), this }, offClick: function (t, e) { return void 0 === this._click || this._click.off("click", t, e), this }, enableClick: function (t) { return void 0 === this._click || this._click.setEnable(t), this }, disableClick: function () { return void 0 === this._click || this._click.setEnable(!1), this } }, Jc = Phaser.Utils.Objects.GetValue, Kc = function () { w(r, Ta); var s = T(r); function r(t, e) { var i; z(this, r), (i = s.call(this, t, e))._enable = void 0; var n = Jc(e, "inputConfig", void 0); return n && t.setInteractive(n), i.resetFromJSON(e), i.boot(), i } return k(r, [{ key: "resetFromJSON", value: function (t) { return this.setEnable(Jc(t, "enable", !0)), this.setMode(Jc(t, "mode", 1)), this.setClickInterval(Jc(t, "clickInterval", 100)), this } }, { key: "boot", value: function () { var t = this.parent.scene; t.input.on("pointerdown", this.onPress, this), t.input.on("pointerup", this.onRelease, this) } }, { key: "shutdown", value: function (t) { if (!this.isShutdown) { var e = this.parent.scene; e.input.off("pointerdown", this.onPress, this), e.input.off("pointerup", this.onRelease, this), O(C(r.prototype), "shutdown", this).call(this, t) } } }, { key: "enable", get: function () { return this._enable }, set: function (t) { if (this._enable !== t) { var e = (this._enable = t) ? "enable" : "disable"; this.emit(e, this, this.parent) } } }, { key: "setEnable", value: function (t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "toggleEnable", value: function () { return this.setEnable(!this.enable), this } }, { key: "setMode", value: function (t) { return "string" == typeof t && (t = qc[t]), this.mode = t, this } }, { key: "setClickInterval", value: function (t) { return this.clickInterval = t, this } }, { key: "isPointerInside", value: function (t) { var e = this.parent; return (e.input ? ds : Bu)(e, t) } }, { key: "onPress", value: function (t) { if (0 === this.mode) { if (!this.parent.willRender(t.camera)) return; this.isPointerInside(t) || this.click(t.downTime, t) } } }, { key: "onRelease", value: function (t) { if (1 === this.mode) { if (!this.parent.willRender(t.camera)) return; this.isPointerInside(t) || this.click(t.upTime, t) } } }, { key: "click", value: function (t, e) { if (!this.enable) return this; if (void 0 === t) return this.emit("clickoutside", this, this.parent, e), this; var i = this.lastClickTime; return void 0 !== i && t - i <= this.clickInterval || (this.lastClickTime = t, this.emit("clickoutside", this, this.parent, e)), this } }]), r }(), qc = { press: 0, pointerdown: 0, release: 1, pointerup: 1 }, $c = { onClickOutside: function (t, e, i) { return t && (void 0 === this._clickOutside && (this._clickOutside = new Kc(this, i)), this._clickOutside.on("clickoutside", t, e)), this }, offClickOutside: function (t, e) { return void 0 === this._clickOutside || this._clickOutside.off("clickoutside", t, e), this }, enableClickOutside: function (t) { return void 0 === this._clickOutside || this._clickOutside.setEnable(t), this }, disableClickOutside: function () { return void 0 === this._clickOutside || this._clickOutside.setEnable(!1), this } }, Zc = function () { function o(t) { z(this, o); var e = nt(t, "states", void 0); e && this.addStates(e); var i = nt(t, "extend", void 0); if (i) for (var n in i) this.hasOwnProperty(n) && void 0 !== this[n] || (this[n] = i[n]); var s = nt(t, "eventEmitter", void 0), r = nt(t, "EventEmitterClass", void 0); this.setEventEmitter(s, r), this._stateLock = !1, this.resetFromJSON(t) } return k(o, [{ key: "shutdown", value: function () { this.destroyEventEmitter() } }, { key: "destroy", value: function () { this.shutdown() } }, { key: "resetFromJSON", value: function (t) { this.setEnable(nt(t, "enable", !0)), this.start(nt(t, "start", void 0)); var e = nt(t, "init", void 0); return e && e.call(this), this } }, { key: "toJSON", value: function () { return { curState: this.state, prevState: this.prevState, enable: this.enable, start: this._start } } }, { key: "setEnable", value: function (t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "toggleEnable", value: function () { return this.setEnable(!this.enable), this } }, { key: "state", get: function () { return this._state }, set: function (t) { if (this.enable && !this._stateLock && this._state !== t) { if (this._prevState = this._state, this._state = t, this._stateLock = !0, this.emit("statechange", this), null != this._prevState) { var e = "exit_" + this._prevState, i = this[e]; i && i.call(this), this.emit(e, this) } if (this._stateLock = !1, null != this._state) { var n = "enter_" + this._state, s = this[n]; s && s.call(this), this.emit(n, this) } } } }, { key: "prevState", get: function () { return this._prevState } }, { key: "start", value: function (t) { return this._start = t, this._prevState = void 0, this._state = t, this } }, { key: "goto", value: function (t) { return null != t && (this.state = t), this } }, { key: "next", value: function () { var t, e = this["next_" + this.state]; return e && (t = "string" == typeof e ? e : e.call(this)), this.goto(t), this } }, { key: "addState", value: function (t, e) { "string" != typeof t && (t = (e = t).name); var i = e.next; i && (this["next_" + t] = i); var n = e.exit; n && (this["exit_" + t] = n); var s = e.enter; return s && (this["enter_" + t] = s), this } }, { key: "addStates", value: function (t) { if (Array.isArray(t)) for (var e = 0, i = t.length; e < i; e++)this.addState(t[e]); else for (var n in t) this.addState(n, t[n]); return this } }, { key: "runMethod", value: function (t, e, i, n, s, r) { var o = this[t + "_" + this.state]; if (o) { var a = arguments.length; switch (a) { case 1: return o.call(this); case 2: return o.call(this, e); case 3: return o.call(this, e, i); case 4: return o.call(this, e, i, n); case 5: return o.call(this, e, i, n, s); case 6: return o.call(this, e, i, n, s, r) }for (var h = new Array(a - 1), l = 1; l < a; l++)h[l - 1] = arguments[l]; return o.apply(this, h) } } }, { key: "update", value: function (t, e) { this.runMethod("update", t, e) } }, { key: "preupdate", value: function (t, e) { this.runMethod("preupdate", t, e) } }, { key: "postupdate", value: function (t, e) { this.runMethod("postupdate", t, e) } }]), o }(); Object.assign(Zc.prototype, ho); function Qc(t, e, i) { for (var n, s = 0, r = t.length; s < r; s++)if (n = t[s], Au(n, e, i)) return n.pointToChild(e, i); return null } function td(t, e, i, n, s, r, o) { var a; (a = void 0 === s ? n : Qc(i, n, s)) && t.emit(e, a, r, o) } var ed = function () { w(i, Zc); var e = T(i); function i() { var t; return z(this, i), (t = e.call(this, { eventEmitter: !1 })).goto("IDLE"), t } return k(i, [{ key: "setCooldownTime", value: function (t) { return this.cooldownTime = t, this.cooldownMode = void 0 !== t, this } }, { key: "request", value: function () { return this.runMethod("request") } }, { key: "update_IDLE", value: function () { this.compensationTime = 0 } }, { key: "request_IDLE", value: function () { return this.next(), !0 } }, { key: "next_IDLE", value: function () { if (this.cooldownMode) return "COOLDOWN" } }, { key: "enter_COOLDOWN", value: function () { this.remainderTime = this.cooldownTime + this.compensationTime } }, { key: "update_COOLDOWN", value: function (t, e) { this.remainderTime -= e, this.remainderTime < 0 && (this.compensationTime = this.cooldownTime > e ? -this.remainderTime : 0, this.goto("IDLE")) } }, { key: "request_COOLDOWN", value: function () { return !1 } }]), i }(), id = Phaser.Utils.Objects.GetValue, nd = function () { w(s, Ta); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, t, e))._enable = void 0, i.cooldown = new ed, i.parent.setInteractive(id(e, "inputConfig", void 0)), i.resetFromJSON(e), i.boot(), i } return k(s, [{ key: "resetFromJSON", value: function (t) { return this.pointer = void 0, this.isInTouching = !1, this.setEnable(id(t, "enable", !0)), this.setCooldown(id(t, "cooldown", void 0)), this } }, { key: "boot", value: function () { var t = this.parent; t.on("pointerdown", this.onPointIn, this), t.on("pointerover", this.onPointIn, this), t.on("pointerup", this.onPointOut, this), t.on("pointerout", this.onPointOut, this), this.scene.sys.events.on("preupdate", this.preupdate, this) } }, { key: "shutdown", value: function (t) { this.isShutdown || (this.scene.sys.events.off("preupdate", this.preupdate, this), this.pointer = void 0, O(C(s.prototype), "shutdown", this).call(this, t)) } }, { key: "enable", get: function () { return this._enable }, set: function (t) { if (this._enable !== t) return t || (this.isInTouching = !1, this.pointer = void 0), this._enable = t, this } }, { key: "setEnable", value: function (t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "cooldownTime", get: function () { return this.cooldown.cooldownTime }, set: function (t) { this.cooldown.setCooldownTime(t) } }, { key: "setCooldown", value: function (t) { return this.cooldownTime = t, this } }, { key: "toggleEnable", value: function () { return this.setEnable(!this.enable), this } }, { key: "onPointIn", value: function (t) { this.enable && t.isDown && void 0 === this.pointer && (this.pointer = t, this.isInTouching = !0) } }, { key: "onPointOut", value: function (t) { this.enable && this.pointer === t && (this.pointer = void 0, this.isInTouching = !1) } }, { key: "preupdate", value: function (t, e) { this.cooldown.update(t, e), this.isInTouching && this.cooldown.request() && this.emit("intouch", this, this.parent, this.pointer) } }]), s }(), sd = { onTouching: function (t, e, i) { return t && (void 0 === this._inTouching && (this._inTouching = new nd(this, i)), this._inTouching.on("intouch", t, e)), this }, offTouching: function (t, e) { return void 0 === this._inTouching || this._inTouching.off("intouch", t, e), this }, enableTouching: function (t) { return void 0 === this._inTouching || this._inTouching.setEnable(t), this }, disableTouching: function () { return void 0 === this._inTouching || this._inTouching.setEnable(!1), this } }, rd = Phaser.Utils.Objects.GetValue, od = function (t, e, i, n) { var s = this._childrenInteractive; td(s.eventEmitter, "".concat(s.eventNamePrefix, "down"), s.targetSizers, t.worldX, t.worldY, t, n) }, ad = Phaser.Utils.Objects.GetValue, hd = function (t, e, i, n) { var s = this._childrenInteractive; td(s.eventEmitter, "".concat(s.eventNamePrefix, "up"), s.targetSizers, t.worldX, t.worldY, t, n) }, ld = Phaser.Utils.Objects.GetValue, ud = function (t, e, i, n) { var s = this._childrenInteractive, r = Qc(s.targetSizers, t.worldX, t.worldY), o = s.lastOverChild; r && o && r === o || (s.lastOverChild = r, td(s.eventEmitter, "".concat(s.eventNamePrefix, "out"), s.targetSizers, o, void 0, t, n), td(s.eventEmitter, "".concat(s.eventNamePrefix, "over"), s.targetSizers, r, void 0, t, n)) }, cd = function (t, e) { var i = this._childrenInteractive, n = i.lastOverChild; i.lastOverChild = null, td(i.eventEmitter, "".concat(i.eventNamePrefix, "out"), i.targetSizers, n, void 0, t, e) }, dd = Phaser.Utils.Objects.GetValue, fd = Phaser.Utils.Objects.GetValue, pd = function () { w(r, Ma); var s = T(r); function r(t, e) { var i; z(this, r); var n = wa(t); return n === t && (t = void 0), ((i = s.call(this, n, e)).gameObject = t) && t.setInteractive(fd(e, "inputConfig", void 0)), i._enable = void 0, i.resetFromJSON(e), i.boot(), i } return k(r, [{ key: "resetFromJSON", value: function (t) { return this.setEnable(fd(t, "enable", !0)), this.setDetectBounds(), void 0 === this.gameObject ? this.setDetectBounds(fd(t, "bounds", void 0)) : this.setDetectBounds(), this.tracerState = vd, this.pointer = void 0, this.lastPointer = void 0, this.movedState = !1, this.isTouchingAnyObject = !1, this } }, { key: "boot", value: function () { O(C(r.prototype), "boot", this).call(this), this.gameObject ? this.gameObject.on("pointerdown", this.onPointerDown, this) : this.scene.input.on("pointerdown", this.onPointerDown, this), this.scene.input.on("pointerup", this.onPointerUp, this), this.scene.input.on("gameout", this.dragCancel, this), this.scene.input.on("pointermove", this.onPointerMove, this), this.scene.sys.events.once("shutdown", this.destroy, this) } }, { key: "shutdown", value: function (t) { this.scene && (this.gameObject || this.scene.input.off("pointerdown", this.onPointerDown, this), this.scene.input.off("pointerup", this.onPointerUp, this), this.scene.input.off("gameout", this.dragCancel, this), this.scene.input.off("pointermove", this.onPointerMove, this), this.scene.sys.events.off("shutdown", this.destroy, this), this.gameObject = void 0, this.bounds = void 0, this.pointer = void 0, this.lastPointer = void 0, this.movedState = !1, O(C(r.prototype), "shutdown", this).call(this, t)) } }, { key: "enable", get: function () { return this._enable }, set: function (t) { if (this._enable !== t) return t || this.dragCancel(), this._enable = t, this } }, { key: "setEnable", value: function (t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "setDetectBounds", value: function (t) { return this.bounds = t, this } }, { key: "toggleEnable", value: function () { return this.setEnable(!this.enable), this } }, { key: "onPointerDown", value: function (t, e) { this.enable && void 0 === this.pointer && (this.bounds && !this.bounds.contains(t.x, t.y) || this.pointer === t || (this.pointer = t, this.lastPointer = t, this.movedState = !1, this.tracerState = gd, void 0 === this.gameObject && (this.isTouchingAnyObject = 0 < e.length), this.onDragStart())) } }, { key: "onPointerUp", value: function (t) { this.enable && (this.bounds && !this.bounds.contains(t.x, t.y) || this.pointer !== t || (this.pointer = void 0, this.movedState = !1, this.tracerState = vd, this.onDragEnd())) } }, { key: "onPointerMove", value: function (t) { if (this.enable && t.isDown) { var e = !this.bounds || this.bounds.contains(t.x, t.y), i = this.pointer === t; !i && e || (i && !e ? this.onPointerUp(t) : (this.movedState || (this.movedState = t.x !== t.downX || t.y !== t.downY), this.movedState && this.onDrag())) } } }, { key: "dragCancel", value: function () { return this.tracerState === gd && this.onDragEnd(), this.pointer = void 0, this.tracerState = vd, this } }, { key: "onDragStart", value: function () { this.emit("dragstart", this) } }, { key: "onDragEnd", value: function () { this.emit("dragend", this) } }, { key: "onDrag", value: function () { this.emit("drag", this) } }, { key: "preUpdate", value: function () { } }, { key: "postUpdate", value: function () { } }, { key: "startTicking", value: function () { O(C(r.prototype), "startTicking", this).call(this), this.scene.sys.events.on("preupdate", this.preUpdate, this), this.scene.sys.events.on("postupdate", this.postUpdate, this) } }, { key: "stopTicking", value: function () { O(C(r.prototype), "stopTicking", this).call(this), this.scene && (this.scene.sys.events.off("preupdate", this.preUpdate, this), this.scene.sys.events.off("postupdate", this.postUpdate, this)) } }, { key: "setRecongizedStateObject", value: function (t) { return this.recongizedState = t, this } }, { key: "state", get: function () { return this.recongizedState.state }, set: function (t) { this.recongizedState.state = t } }, { key: "cancel", value: function () { return this.state = yd, this } }]), r }(), vd = 0, gd = 1, yd = "IDLE", md = Phaser.Utils.Objects.GetValue, kd = Phaser.Math.Distance.Between, bd = function () { w(o, pd); var r = T(o); function o(t, e) { var i; z(this, o); var n = j(i = r.call(this, t, e)), s = { states: { IDLE: { enter: function () { n.stop(), n.tapsCount = 0, n.x = 0, n.y = 0, n.worldX = 0, n.worldY = 0 }, exit: function () { var t = n.lastPointer; n.x = t.x, n.y = t.y, n.worldX = t.worldX, n.worldY = t.worldY } }, BEGIN: { enter: function () { n.start(), n.tapsCount = 0, n.emit("tappingstart", n, n.gameObject, n.lastPointer) } }, RECOGNIZED: { enter: function () { n.start(), n.emit("tap", n, n.gameObject, n.lastPointer), n.emit("".concat(n.tapsCount, "tap"), n, n.gameObject, n.lastPointer) } } }, init: function () { this.state = xd }, eventEmitter: !1 }; return i.setRecongizedStateObject(new Zc(s)), i } return k(o, [{ key: "resetFromJSON", value: function (t) { O(C(o.prototype), "resetFromJSON", this).call(this, t), this.setHoldTime(md(t, "time", 250)), this.setTapInterval(md(t, "tapInterval", 200)), this.setDragThreshold(md(t, "threshold", 9)), this.setTapOffset(md(t, "tapOffset", 10)); var e = md(t, "taps", void 0); return void 0 !== e ? this.setTaps(e) : (this.setMaxTaps(md(t, "maxTaps", void 0)), this.setMinTaps(md(t, "minTaps", void 0))), this } }, { key: "onDragStart", value: function () { switch (this.state) { case xd: this.state = Cd; break; case Cd: var t = this.lastPointer; kd(t.upX, t.upY, t.x, t.y) > this.tapOffset && (this.state = wd, this.state = Cd); break; case wd: this.state = Cd } } }, { key: "onDragEnd", value: function () { this.state === Cd && (this.tapsCount++, this.emit("tapping", this, this.gameObject, this.lastPointer), void 0 !== this.maxTaps && this.tapsCount === this.maxTaps && (this.state = wd)) } }, { key: "onDrag", value: function () { this.state !== xd && this.pointer.getDistance() > this.dragThreshold && (this.state = xd) } }, { key: "preUpdate", value: function (t) { if (this.isRunning && this.enable && this.state === Cd) { var e = this.lastPointer; if (e.isDown) t - e.downTime > this.holdTime && (this.state = xd); else t - e.upTime > this.tapInterval && (void 0 === this.minTaps || this.tapsCount >= this.minTaps ? this.state = wd : this.state = xd) } } }, { key: "postUpdate", value: function () { this.isRunning && this.enable && this.state === wd && (this.state = xd) } }, { key: "isTapped", get: function () { return this.state === wd } }, { key: "setHoldTime", value: function (t) { return this.holdTime = t, this } }, { key: "setTapInterval", value: function (t) { return this.tapInterval = t, this } }, { key: "setDragThreshold", value: function (t) { return this.dragThreshold = t, this } }, { key: "setTapOffset", value: function (t) { return this.tapOffset = t, this } }, { key: "setMaxTaps", value: function (t) { return this.maxTaps = t, this } }, { key: "setMinTaps", value: function (t) { return this.minTaps = t, this } }, { key: "setTaps", value: function (t, e) { return void 0 === e && (e = t), this.setMinTaps(t).setMaxTaps(e), this } }]), o }(), xd = "IDLE", Cd = "BEGIN", wd = "RECOGNIZED", Sd = Phaser.Utils.Objects.GetValue, Pd = function () { w(o, pd); var r = T(o); function o(t, e) { var i; z(this, o); var n = j(i = r.call(this, t, e)), s = { states: { IDLE: { enter: function () { n.x = 0, n.y = 0, n.worldX = 0, n.worldY = 0 }, exit: function () { var t = n.lastPointer; n.x = t.x, n.y = t.y, n.worldX = t.worldX, n.worldY = t.worldY } }, BEGIN: { enter: function () { n.start() }, exit: function () { n.stop() } }, RECOGNIZED: { enter: function () { n.emit("pressstart", n, n.gameObject, n.lastPointer) }, exit: function () { n.emit("pressend", n, n.gameObject, n.lastPointer) } } }, init: function () { this.state = Td }, eventEmitter: !1 }; return i.setRecongizedStateObject(new Zc(s)), i } return k(o, [{ key: "resetFromJSON", value: function (t) { return O(C(o.prototype), "resetFromJSON", this).call(this, t), this.setDragThreshold(Sd(t, "threshold", 9)), this.setHoldTime(Sd(t, "time", 251)), this } }, { key: "onDragStart", value: function () { this.state = Od, 0 === this.holdTime && (this.state = Md) } }, { key: "onDragEnd", value: function () { this.state = Td } }, { key: "onDrag", value: function () { this.state !== Td && this.pointer.getDistance() > this.dragThreshold && (this.state = Td) } }, { key: "preUpdate", value: function (t) { this.isRunning && this.enable && this.state === Od && t - this.pointer.downTime >= this.holdTime && (this.state = Md) } }, { key: "isPressed", get: function () { return this.state === Md } }, { key: "setHoldTime", value: function (t) { return this.holdTime = t, this } }, { key: "setDragThreshold", value: function (t) { return this.dragThreshold = t, this } }]), o }(), Td = "IDLE", Od = "BEGIN", Md = "RECOGNIZED", Ed = Phaser.Utils.Objects.GetValue, _d = function () { w(o, pd); var r = T(o); function o(t, e) { var i; z(this, o); var n = j(i = r.call(this, t, e)), s = { states: { IDLE: {}, BEGIN: { enter: function () { var t = n.pointer; n.startX = t.x, n.startY = t.y, n.startWorldX = t.worldX, n.startWorldY = t.worldY } }, RECOGNIZED: { enter: function () { n.emit("panstart", n, n.gameObject, n.lastPointer) }, exit: function () { var t = n.lastPointer; n.endX = t.x, n.endY = t.y, n.endWorldX = t.worldX, n.endWorldY = t.worldY, n.emit("panend", n, n.gameObject, n.lastPointer) } } }, init: function () { this.state = Bd }, eventEmitter: !1 }; return i.setRecongizedStateObject(new Zc(s)), i } return k(o, [{ key: "resetFromJSON", value: function (t) { return O(C(o.prototype), "resetFromJSON", this).call(this, t), this.setDragThreshold(Ed(t, "threshold", 10)), this } }, { key: "onDragStart", value: function () { this.state = Id, 0 === this.dragThreshold && (this.state = Rd) } }, { key: "onDragEnd", value: function () { this.state = Bd } }, { key: "onDrag", value: function () { switch (this.state) { case Id: this.pointer.getDistance() >= this.dragThreshold && (this.state = Rd); break; case Rd: var t = this.pointer.position, e = this.pointer.prevPosition; this.dx = t.x - e.x, this.dy = t.y - e.y; var i = this.pointer; this.x = i.x, this.y = i.y, this.worldX = i.worldX, this.worldY = i.worldY, this.emit("pan", this, this.gameObject, this.lastPointer) } } }, { key: "isPanned", get: function () { return this.state === Rd } }, { key: "setDragThreshold", value: function (t) { return this.dragThreshold = t, this } }]), o }(), Bd = "IDLE", Id = "BEGIN", Rd = "RECOGNIZED", Ad = Phaser.Math.Distance.Between, Dd = Phaser.Math.Angle.Between, Ld = { getDt: function () { return this.scene.sys.game.loop.delta }, getVelocity: function () { var t = this.pointer.position, e = this.pointer.prevPosition; return Ad(e.x, e.y, t.x, t.y) / (.001 * this.getDt()) }, getVelocityX: function () { var t = this.pointer.position, e = this.pointer.prevPosition; return Math.abs(t.x - e.x) / (.001 * this.getDt()) }, getVelocityY: function () { var t = this.pointer.position, e = this.pointer.prevPosition; return Math.abs(t.y - e.y) / (.001 * this.getDt()) }, getVelocityAngle: function () { var t = this.pointer.position, e = this.pointer.prevPosition; return Dd(e.x, e.y, t.x, t.y) } }, zd = { "up&down": 0, "left&right": 1, "4dir": 2, "8dir": 3 }, jd = {}, Fd = Phaser.Utils.Objects.GetValue, Yd = Phaser.Math.RadToDeg, Wd = function () { w(o, pd); var r = T(o); function o(t, e) { var i; z(this, o); var n = j(i = r.call(this, t, e)), s = { states: { IDLE: { enter: function () { n.x = 0, n.y = 0, n.worldX = 0, n.worldY = 0 }, exit: function () { var t = n.lastPointer; n.x = t.x, n.y = t.y, n.worldX = t.worldX, n.worldY = t.worldY } }, BEGIN: { enter: function () { n.validDrag = !1 } }, RECOGNIZED: { enter: function () { n.start(), n.updateDirectionStates(), n.emit("swipe", n, n.gameObject, n.lastPointer) }, exit: function () { n.stop(), n.clearDirectionStates() } } }, init: function () { this.state = Vd }, eventEmitter: !1 }; return i.setRecongizedStateObject(new Zc(s)), i.clearDirectionStates(), i } return k(o, [{ key: "resetFromJSON", value: function (t) { return O(C(o.prototype), "resetFromJSON", this).call(this, t), this.setDragThreshold(Fd(t, "threshold", 10)), this.setVelocityThreshold(Fd(t, "velocityThreshold", 1e3)), this.setDirectionMode(Fd(t, "dir", "8dir")), this } }, { key: "onDragStart", value: function () { this.state = Xd } }, { key: "onDragEnd", value: function () { this.state = Vd } }, { key: "onDrag", value: function () { this.state === Xd && (this.validDrag || (this.validDrag = 0 === this.dragThreshold || this.pointer.getDistance() >= this.dragThreshold), this.validDrag && this.dragVelocity > this.velocityThreshold && (this.state = Gd)) } }, { key: "postUpdate", value: function () { this.isRunning && this.enable && this.state === Gd && (this.state = Vd) } }, { key: "isSwiped", get: function () { return this.state === Gd } }, { key: "dragVelocity", get: function () { var t; switch (this.dirMode) { case 0: t = this.getVelocityY(); break; case 1: t = this.getVelocityX(); break; default: t = this.getVelocity() }return t } }, { key: "setDragThreshold", value: function (t) { return this.dragThreshold = t, this } }, { key: "setVelocityThreshold", value: function (t) { return this.velocityThreshold = t, this } }, { key: "setDirectionMode", value: function (t) { return "string" == typeof t && (t = zd[t]), this.dirMode = t, this } }, { key: "updateDirectionStates", value: function () { return function (t, e, i) { switch (void 0 === i ? i = {} : !0 === i && (i = jd), i.left = !1, i.right = !1, i.up = !1, i.down = !1, t = (t + 360) % 360, e) { case 0: t < 180 ? i.down = !0 : i.up = !0; break; case 1: 90 < t && t <= 270 ? i.left = !0 : i.right = !0; break; case 2: 45 < t && t <= 135 ? i.down = !0 : 135 < t && t <= 225 ? i.left = !0 : 225 < t && t <= 315 ? i.up = !0 : i.right = !0; break; case 3: 22.5 < t && t <= 67.5 ? (i.down = !0, i.right = !0) : 67.5 < t && t <= 112.5 ? i.down = !0 : 112.5 < t && t <= 157.5 ? (i.down = !0, i.left = !0) : 157.5 < t && t <= 202.5 ? i.left = !0 : 202.5 < t && t <= 247.5 ? (i.left = !0, i.up = !0) : 247.5 < t && t <= 292.5 ? i.up = !0 : (292.5 < t && t <= 337.5 && (i.up = !0), i.right = !0) } }(Yd(this.getVelocityAngle()), this.dirMode, this), this } }, { key: "clearDirectionStates", value: function () { return this.left = !1, this.right = !1, this.up = !1, this.down = !1, this } }]), o }(); Object.assign(Wd.prototype, Ld); var Vd = "IDLE", Xd = "BEGIN", Gd = "RECOGNIZED", Ud = Phaser.Utils.Objects.GetValue, Hd = Phaser.Utils.Array.SpliceOne, Nd = Phaser.Math.Distance.Between, Jd = Phaser.Math.Angle.Between, Kd = function () { function n(t, e) { z(this, n); var i = t.input.manager.pointersTotal - 1; i < 2 && t.input.addPointer(2 - i), this.scene = t, this.setEventEmitter(Ud(e, "eventEmitter", void 0)), this._enable = void 0, this.pointers = [], this.movedState = {}, this.resetFromJSON(e), this.boot() } return k(n, [{ key: "resetFromJSON", value: function (t) { return this.setEnable(Ud(t, "enable", !0)), this.bounds = Ud(t, "bounds", void 0), this.tracerState = Zd, this.pointers.length = 0, st(this.movedState), this } }, { key: "boot", value: function () { this.scene.input.on("pointerdown", this.onPointerDown, this), this.scene.input.on("pointerup", this.onPointerUp, this), this.scene.input.on("gameout", this.dragCancel, this), this.scene.input.on("pointermove", this.onPointerMove, this), this.scene.sys.events.once("shutdown", this.destroy, this) } }, { key: "shutdown", value: function () { this.scene && (this.destroyEventEmitter(), this.pointers.length = 0, st(this.movedState), this.scene.input.off("pointerdown", this.onPointerDown, this), this.scene.input.off("pointerup", this.onPointerUp, this), this.scene.input.off("gameout", this.dragCancel, this), this.scene.input.off("pointermove", this.onPointerMove, this), this.scene.sys.events.off("shutdown", this.destroy, this), this.scene = void 0) } }, { key: "destroy", value: function () { this.shutdown() } }, { key: "enable", get: function () { return this._enable }, set: function (t) { if (this._enable !== t) return t || this.dragCancel(), this._enable = t, this } }, { key: "setEnable", value: function (t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "toggleEnable", value: function () { return this.setEnable(!this.enable), this } }, { key: "onPointerDown", value: function (t) { if (this.enable && (2 !== this.pointers.length && (!this.bounds || this.bounds.contains(t.x, t.y)) && -1 === this.pointers.indexOf(t))) switch (this.movedState[t.id] = !1, this.pointers.push(t), this.tracerState) { case Zd: this.tracerState = Qd, this.onDrag1Start(); break; case Qd: this.tracerState = tf, this.onDrag2Start() } } }, { key: "onPointerUp", value: function (t) { if (this.enable && (!this.bounds || this.bounds.contains(t.x, t.y))) { var e = this.pointers.indexOf(t); if (-1 !== e) switch (delete this.movedState[t.id], Hd(this.pointers, e), this.tracerState) { case Qd: this.tracerState = Zd, this.onDrag1End(); break; case tf: this.tracerState = Qd, this.onDrag2End(), this.onDrag1Start() } } } }, { key: "onPointerMove", value: function (t) { if (this.enable && t.isDown) { var e = !this.bounds || this.bounds.contains(t.x, t.y), i = -1 !== this.pointers.indexOf(t); if (i || !e) if (i && !e) this.onPointerUp(t); else if (this.movedState[t.id] || (this.movedState[t.id] = t.x !== t.downX || t.y !== t.downY), this.movedState[t.id]) switch (this.tracerState) { case Qd: this.onDrag1(); break; case tf: this.onDrag2() } } } }, { key: "dragCancel", value: function () { return this.tracerState === tf && this.onDrag2End(), this.pointers.length = 0, st(this.movedState), this.tracerState = Zd, this } }, { key: "onDrag1Start", value: function () { this.emit("drag1start", this) } }, { key: "onDrag1End", value: function () { this.emit("drag1end", this) } }, { key: "onDrag1", value: function () { this.emit("drag1", this) } }, { key: "onDrag2Start", value: function () { this.emit("drag2start", this) } }, { key: "onDrag2End", value: function () { this.emit("drag2end", this) } }, { key: "onDrag2", value: function () { this.emit("drag2", this) } }, { key: "distanceBetween", get: function () { if (this.tracerState !== tf) return 0; var t = this.pointers[0], e = this.pointers[1]; return Nd(t.x, t.y, e.x, e.y) } }, { key: "angleBetween", get: function () { if (this.tracerState !== tf) return 0; var t = this.pointers[0], e = this.pointers[1]; return Jd(t.x, t.y, e.x, e.y) } }, { key: "drag1Vector", get: function () { var t = this.pointers[0]; if (t && this.movedState[t.id]) { var e = t.position, i = t.prevPosition; $d.x = e.x - i.x, $d.y = e.y - i.y } else $d.x = 0, $d.y = 0; return $d } }, { key: "centerX", get: function () { if (this.tracerState !== tf) return 0; var t = this.pointers[0].position, e = this.pointers[1].position; return (t.x + e.x) / 2 } }, { key: "centerY", get: function () { if (this.tracerState !== tf) return 0; var t = this.pointers[0].position, e = this.pointers[1].position; return (t.y + e.y) / 2 } }, { key: "prevCenterX", get: function () { if (this.tracerState !== tf) return 0; var t = this.movedState[this.pointers[0].id] ? this.pointers[0].prevPosition : this.pointers[0].position, e = this.movedState[this.pointers[1].id] ? this.pointers[1].prevPosition : this.pointers[1].position; return (t.x + e.x) / 2 } }, { key: "prevCenterY", get: function () { if (this.tracerState !== tf) return 0; var t = this.movedState[this.pointers[0].id] ? this.pointers[0].prevPosition : this.pointers[0].position, e = this.movedState[this.pointers[1].id] ? this.pointers[1].prevPosition : this.pointers[1].position; return (t.y + e.y) / 2 } }, { key: "movementCenterX", get: function () { return this.centerX - this.prevCenterX } }, { key: "movementCenterY", get: function () { return this.centerY - this.prevCenterY } }, { key: "setRecongizedStateObject", value: function (t) { return this.recongizedState = t, this } }, { key: "state", get: function () { return this.recongizedState.state }, set: function (t) { this.recongizedState.state = t } }, { key: "cancel", value: function () { return this.state = ef, this } }]), n }(); Object.assign(Kd.prototype, ho); function qd(t, e, i, n) { return hf(t, e, i, n), t.rotation += n, t } var $d = {}, Zd = 0, Qd = 1, tf = 2, ef = "IDLE", nf = Phaser.Utils.Objects.GetValue, sf = function () { w(o, Kd); var r = T(o); function o(t, e) { var i; z(this, o); var n = j(i = r.call(this, t, e)), s = { states: { IDLE: { enter: function () { n.prevDistance = void 0, n.scaleFactor = 1 } }, BEGIN: {}, RECOGNIZED: { enter: function () { n.emit("pinchstart", n) }, exit: function () { n.emit("pinchend", n) } } }, init: function () { this.state = rf }, eventEmitter: !1 }; return i.setRecongizedStateObject(new Zc(s)), i } return k(o, [{ key: "resetFromJSON", value: function (t) { return O(C(o.prototype), "resetFromJSON", this).call(this, t), this.setDragThreshold(nf(t, "threshold", 0)), this } }, { key: "onDrag2Start", value: function () { this.scaleFactor = 1, this.prevDistance = this.distanceBetween, this.state = of, 0 === this.dragThreshold && (this.state = af) } }, { key: "onDrag2End", value: function () { this.state = rf } }, { key: "onDrag2", value: function () { switch (this.state) { case of: if (this.pointers[0].getDistance() >= this.dragThreshold && this.pointers[1].getDistance() >= this.dragThreshold) { var t = this.distanceBetween; this.scaleFactor = t / this.prevDistance, this.prevDistance = t, this.state = af } break; case af: t = this.distanceBetween; this.scaleFactor = t / this.prevDistance, this.emit("pinch", this), this.prevDistance = t } } }, { key: "isPinched", get: function () { return this.state === af } }, { key: "setDragThreshold", value: function (t) { return this.dragThreshold = t, this } }]), o }(), rf = "IDLE", of = "BEGIN", af = "RECOGNIZED", hf = Phaser.Math.RotateAround, lf = {}, uf = Phaser.Utils.Objects.GetValue, cf = Phaser.Math.Angle.WrapDegrees, df = Phaser.Math.Angle.ShortestBetween, ff = Phaser.Math.RadToDeg, pf = Phaser.Math.DegToRad, vf = function () { w(o, Kd); var r = T(o); function o(t, e) { var i; z(this, o); var n = j(i = r.call(this, t, e)), s = { states: { IDLE: { enter: function () { n.prevAngle = void 0, n.angle = 0 } }, BEGIN: {}, RECOGNIZED: { enter: function () { n.emit("rotatestart", n) }, exit: function () { n.emit("rotateend", n) } } }, init: function () { this.state = mf }, eventEmitter: !1 }; return i.setRecongizedStateObject(new Zc(s)), i } return k(o, [{ key: "resetFromJSON", value: function (t) { return O(C(o.prototype), "resetFromJSON", this).call(this, t), this.setDragThreshold(uf(t, "threshold", 0)), this } }, { key: "onDrag2Start", value: function () { this.prevAngle = cf(ff(this.angleBetween)), this.state = kf, 0 === this.dragThreshold && (this.state = bf) } }, { key: "onDrag2End", value: function () { this.state = mf } }, { key: "onDrag2", value: function () { switch (this.state) { case kf: if (this.pointers[0].getDistance() >= this.dragThreshold && this.pointers[1].getDistance() >= this.dragThreshold) { var t = cf(ff(this.angleBetween)); this.angle = df(this.prevAngle, t), this.prevAngle = t, this.state = bf } break; case bf: t = cf(ff(this.angleBetween)); this.angle = df(this.prevAngle, t), this.prevAngle = t, this.emit("rotate", this) } } }, { key: "isRotated", get: function () { return this.state === bf } }, { key: "rotation", get: function () { return pf(this.angle) } }, { key: "setDragThreshold", value: function (t) { return this.dragThreshold = t, this } }]), o }(), gf = { spinObject: function (t, e) { if (!this.isRotation) return this; void 0 === e && (e = this.pointers[0].camera); var i, n, s, r = this.movementCenterX, o = this.movementCenterY, a = (i = this.centerX, n = this.centerY, void 0 === (s = !0) ? s = {} : !0 === s && (s = lf), e.getWorldPoint(i, n, s), s), h = a.x, l = a.y, u = this.rotation; if (Array.isArray(t)) for (var c = t, d = 0, f = c.length; d < f; d++)(t = c[d]).x += r, t.y += o, qd(t, h, l, u); else t.x += r, t.y += o, qd(t, h, l, u); return this } }; Object.assign(vf.prototype, gf); function yf(t, e) { return t.setInteractive(), t._childrenInteractive = { targetSizers: Sf(e, "targets", [t]), eventEmitter: Sf(e, "eventEmitter", t), eventNamePrefix: Sf(e, "inputEventPrefix", "child.") }, function (t) { !1 !== rd(t, "down", void 0) && this.on("pointerdown", od, this) }.call(t, e), function (t) { !1 !== ad(t, "up", void 0) && this.on("pointerup", hd, this) }.call(t, e), function (t) { !1 !== ld(t, "over", void 0) && this.on("pointermove", ud, this).on("pointerover", ud, this).on("pointerout", cd, this) }.call(t, e), function (t) { var e = dd(t, "click", void 0); if (!1 !== e) { void 0 === e && (e = {}), e.hasOwnProperty("threshold") || (e.threshold = 10); var s = this._childrenInteractive; this._click = new Uc(this, e), this._click.on("click", function (t, e, i, n) { td(s.eventEmitter, "".concat(s.eventNamePrefix, "click"), s.targetSizers, i.worldX, i.worldY, i, n) }, this) } }.call(t, e), function (t) { var e = xf(t, "tap", void 0); if (!1 !== e) { var n = this._childrenInteractive; this._tap = new bd(this, e), this._tap.on("tap", function (t, e, i) { td(n.eventEmitter, "".concat(n.eventNamePrefix).concat(t.tapsCount, "tap"), n.targetSizers, t.worldX, t.worldY, i) }, this) } }.call(t, e), function (t) { var e = Cf(t, "press", void 0); if (!1 !== e) { var n = this._childrenInteractive; this._press = new Pd(this, e), this._press.on("pressstart", function (t, e, i) { td(n.eventEmitter, "".concat(n.eventNamePrefix, "pressstart"), n.targetSizers, t.worldX, t.worldY, i) }, this).on("pressend", function (t, e, i) { td(n.eventEmitter, "".concat(n.eventNamePrefix, "pressend"), n.targetSizers, t.worldX, t.worldY, i) }, this) } }.call(t, e), function (t) { var e = wf(t, "swipe", void 0); if (!1 !== e) { void 0 === e && (e = {}), e.hasOwnProperty("dir") || (e.dir = "4dir"); var s = this._childrenInteractive; this._swipe = new Wd(this, e), this._swipe.on("swipe", function (t, e, i) { var n = t.left ? "left" : t.right ? "right" : t.up ? "up" : "down"; td(s.eventEmitter, "".concat(s.eventNamePrefix, "swipe").concat(n), s.targetSizers, t.worldX, t.worldY, i) }, this) } }.call(t, e), t } var mf = "IDLE", kf = "BEGIN", bf = "RECOGNIZED", xf = Phaser.Utils.Objects.GetValue, Cf = Phaser.Utils.Objects.GetValue, wf = Phaser.Utils.Objects.GetValue, Sf = Phaser.Utils.Objects.GetValue, Pf = { getSizerConfig: _l, getChildPrevState: function (t) { var e = _l(t); return e.hasOwnProperty("prevState") || (e.prevState = {}), e.prevState }, pushIntoBounds: function (t) { return void 0 === t && (t = Bl(this.scene)), this.left = Math.max(this.left, t.left), this.right = Math.min(this.right, t.right), this.top = Math.max(this.top, t.top), this.bottom = Math.min(this.bottom, t.bottom), this }, drawBounds: function (t, e) { var i, n, s, r, o = t.scene; if ("number" == typeof e) i = e; else { i = Ku(e, "color", 16777215); var a = Ku(e, "name", !1); a && (n = Ku(a, "createTextCallback", $u), s = Ku(a, "createTextCallbackScope", void 0), "string" == typeof (r = Ku(a, "align", "left-top")) && (r = Ll[r])) } if (n && !t.children) { t.children = new qu(o), t.once("destroy", function (t, e) { t.children.destroy(!e), t.children = void 0 }); var h = t.clear.bind(t); t.clear = function () { h(), t.children.clear(!1, !0) } } for (var l, u, c = this.getAllShownChildren([this]), d = 0, f = c.length; d < f; d++)((l = c[d]).getBounds || void 0 !== l.width && void 0 !== l.height) && (Zu = lu(l, Zu), null != i && t.lineStyle(1, i).strokeRectShape(Zu), l.name && n && (u = s ? n.call(s, o) : n(o)) && (u.setText(l.name), t.children.add(u), hu(u, Zu.x, Zu.y, Zu.width, Zu.height, r))); return this }, resolveWidth: fu, resolveChildrenWidth: function (t) { var e, i; for (var n in this.sizerChildren) (e = this.sizerChildren[n]) && e.isRexSizer && !e.ignoreLayout && (i = this.getExpandedChildWidth(e, t), i = e.resolveWidth(i), e.resolveChildrenWidth(i)) }, resolveHeight: pu, getChildWidth: function (t) { return t.isRexSizer ? Math.max(t.minWidth, t.childrenWidth) : void 0 !== t.minWidth ? t.minWidth : jl(t) }, getChildHeight: function (t) { return t.isRexSizer ? Math.max(t.minHeight, t.childrenHeight) : void 0 !== t.minHeight ? t.minHeight : Fl(t) }, getExpandedChildWidth: function (t, e) { return e }, getExpandedChildHeight: function (t, e) { return e }, getChildrenWidth: function () { return 0 }, getChildrenHeight: function () { return 0 }, addChildrenMap: du, addElement: du, removeChildrenMap: function (t) { if ("object" === P(t)) { var e = t; for (var t in this.childrenMap) if (this.childrenMap[t] === e) return delete this.childrenMap[t], this } return delete this.childrenMap[t], this }, getElement: function (t, e) { if ("string" == typeof t && (t = t.split(".")), 0 !== t.length) { var i = t.shift(), n = null; if ("#" === i.charAt(0)) i = i.substring(1), n = this.getByName(i, e); else if (-1 === i.indexOf("[")) this.childrenMap && (n = this.childrenMap[i]); else { var s = i.match(ic); if (null != s && this.childrenMap) { var r = this.childrenMap[s[1]]; r && (n = r[s[2]]) } } return 0 === t.length ? n : n && n.childrenMap ? n.getElement(t) : null } }, getAllChildrenSizers: function (t) { void 0 === t && (t = []); for (var e = t.length, i = this.getChildrenSizers(t), n = t.length, s = e; s < n; s++)i[s].getAllChildrenSizers(t); return t }, getChildrenSizers: function (t) { return void 0 === t && (t = []), t }, preLayout: vu, layout: function () { return this.runLayout(), this }, runLayout: function (t, e, i) { if (this.ignoreLayout) return this; var n = !t; return n && this.preLayout(), e = this.resolveWidth(e), n && (this.resolveChildrenWidth(e), this.runWidthWrap(e)), i = this.resolveHeight(i), this.resize(e, i), this.sizerEventsEnable && void 0 === this.layoutedChildren && (this.layoutedChildren = []), this.layoutChildren(), this.layoutBackgrounds(), this.sizerEventsEnable && (this.emit("postlayout", this.layoutedChildren, this), this.layoutedChildren.length = 0), this.postLayout() }, layoutChildren: function () { }, runWidthWrap: gu, layoutBackgrounds: function () { if (void 0 !== this.backgroundChildren) for (var t, e, i, n, s, r, o, a = this.backgroundChildren, h = this.left, l = this.top, u = this.width, c = this.height, d = 0, f = a.length; d < f; d++)(e = (t = a[d]).rexSizer).hidden || (i = e.padding, zu.call(this, t), n = h + i.left, s = l + i.top, r = u - i.left - i.right, o = c - i.top - i.bottom, Lu(t, r, o), ju.call(this, t, n, s, r, o, Xc)) }, postLayout: function () { return this._anchor && this._anchor.updatePosition(), this }, setAnchor: function (t) { void 0 === t && (t = {}); var n = t.hasOwnProperty("width"), s = t.hasOwnProperty("height"), e = t.hasOwnProperty("onResizeCallback"); return !n && !s || e || (t.onResizeCallback = function (t, e, i) { n && i.setMinWidth(t), s && i.setMinHeight(e), i.layout() }), void 0 === this._anchor ? this._anchor = new rc(this, t) : this._anchor.resetFromJSON(t), this }, isInTouching: function (t, e) { return void 0 === e && (e = this), Bu(e, t) }, pointToChild: function (t, e, i, n, s) { if (Iu(i) || (s = i, n = i = void 0), void 0 === s && (s = this.sizerChildren ? this.sizerChildren : this.children), Ru(s)) { for (var r, o = 0, a = s.length; o < a; o++)if (r = s[o], Au(r, t, e, i, n)) return r } else for (var h in s) if (r = s[h], Au(r, t, e, i, n)) return r; return null }, setDraggable: function (s, t) { var e = P(s); return "string" === e ? s = this.getElement(s) : void 0 !== s && "object" == e || (t = s, s = this), void 0 === t && (t = !0), s.input && s.input.hasOwnProperty("draggable") ? s.input.draggable = t : t && (s.setInteractive(), s.scene.input.setDraggable(s), s.on("drag", function (t, e, i) { var n = this.getTopmostSizer(); n.x += e - s.x, n.y += i - s.y, n.emit("sizer.drag", t, e, i) }, this).on("dragstart", function (t, e, i) { this.getTopmostSizer().emit("sizer.dragstart", t, e, i) }, this).on("dragend", function (t, e, i, n) { this.getTopmostSizer().emit("sizer.dragend", t, e, i, n) }, this)), this }, setChildrenInteractive: function (t) { return yf(this, t), this }, broadcastEvent: function () { for (var t = this.getAllChildren([this]), e = 0, i = t.length; e < i; e++) { var n = t[e]; n.emit.apply(n, arguments) } return this } }; Object.assign(Pf, nc, ec, { removeFromParentSizer: function () { var t = this.getParentSizer(); return t && t.remove(this), this } }, { getParentSizer: function (t, e) { return this.getParent(t, e) }, getTopmostSizer: function (t) { return this.getTopmostParent(t) } }, dc, bc, Mc, Ac, zc, Nc, $c, sd, Fc, sc); var Tf = Phaser.Utils.Objects.GetValue, Of = function () { w(l, dr); var h = T(l); function l(t, e, i, n, s, r) { var o; z(this, l), (o = h.call(this, t, e, i, 2, 2)).isRexSizer = !0, o.setMinSize(n, s), o.setName(Tf(r, "name", "")), o.rexSizer = {}, o.space = {}, o.backgroundChildren = void 0, o.sizerChildren = void 0, o.layoutedChildren = void 0; var a = Tf(r, "anchor", void 0); return a && o.setAnchor(a), o.setInnerPadding(Tf(r, "space", 0)), o.setDraggable(Tf(r, "draggable", !1)), o.setSizerEventsEnable(Tf(r, "sizerEvents", !1)), o.setDirty(!0), o } return k(l, [{ key: "destroy", value: function (t) { if (this.scene) { if (t) for (var e = this.getAllChildrenSizers([this]), i = 0, n = e.length; i < n; i++)e[i].sizerEventsEnable = !1; O(C(l.prototype), "destroy", this).call(this, t), st(this.backgroundChildren), st(this.sizerChildren), this.childrenMap = void 0, this.space = void 0, this.rexSizer = void 0, this.layoutedChildren = void 0 } } }, { key: "setMinSize", value: function (t, e) { return this.setMinWidth(t).setMinHeight(e), this } }, { key: "setMinWidth", value: function (t) { return null == t && (t = 0), this.minWidth = t, this } }, { key: "setMinHeight", value: function (t) { return null == t && (t = 0), this.minHeight = t, this } }, { key: "setDirty", value: function (t) { return void 0 === t && (t = !0), this.dirty = t, this } }, { key: "setSizerEventsEnable", value: function (t) { return void 0 === t && (t = !0), this.sizerEventsEnable = t, this } }, { key: "ignoreLayout", get: function () { return this.rexSizer.hidden || !this.dirty } }, { key: "childrenWidth", get: function () { return void 0 === this._childrenWidth && (this._childrenWidth = this.getChildrenWidth()), this._childrenWidth } }, { key: "childrenHeight", get: function () { return void 0 === this._childrenHeight && (this._childrenHeight = this.getChildrenHeight()), this._childrenHeight } }, { key: "left", get: function () { return this.x - jl(this) * this.originX }, set: function (t) { this.x += t - this.left } }, { key: "alignLeft", value: function (t) { return this.left = t, this } }, { key: "right", get: function () { return this.left + jl(this) }, set: function (t) { this.x += t - this.right } }, { key: "alignRight", value: function (t) { return this.right = t, this } }, { key: "centerX", get: function () { return this.left + jl(this) / 2 }, set: function (t) { this.x += t - this.centerX } }, { key: "alignCenterX", value: function (t) { return this.centerX = t, this } }, { key: "top", get: function () { return this.y - Fl(this) * this.originY }, set: function (t) { this.y += t - this.top } }, { key: "alignTop", value: function (t) { return this.top = t, this } }, { key: "bottom", get: function () { return this.top + Fl(this) }, set: function (t) { this.y += t - this.bottom } }, { key: "alignBottom", value: function (t) { return this.bottom = t, this } }, { key: "centerY", get: function () { return this.top + Fl(this) / 2 }, set: function (t) { this.y += t - this.centerY } }, { key: "alignCenterY", value: function (t) { return this.centerY = t, this } }, { key: "innerLeft", get: function () { return this.left + this.space.left } }, { key: "innerRight", get: function () { return this.right - this.space.right } }, { key: "innerTop", get: function () { return this.top + this.space.top } }, { key: "innerBottom", get: function () { return this.bottom - this.space.bottom } }, { key: "innerWidth", get: function () { return this.width - this.space.left - this.space.right } }, { key: "innerHeight", get: function () { return this.height - this.space.top - this.space.bottom } }, { key: "minInnerWidth", get: function () { var t = this.minWidth - this.space.left - this.space.right; return Math.max(t, 0) } }, { key: "minInnerHeight", get: function () { var t = this.minHeight - this.space.top - this.space.bottom; return Math.max(t, 0) } }]), l }(); Object.assign(Of.prototype, Pf); function Mf(t, e) { t.width < t.childrenWidth && console.warn("Layout width error: Parent=".concat(e.constructor.name, ", Child=").concat(t.constructor.name)), t.height < t.childrenHeight && console.warn("Layout height error: Parent=".concat(e.constructor.name, ", Child=").concat(t.constructor.name)) } function Ef(t, e) { return this.isBackground(t) && Lf(this.backgroundChildren, t), zf.call(this, t, e), !e && this.sizerEventsEnable && (t.emit("sizer.remove", t, this), this.emit("remove", t, this)), this } function _f(t) { this.backgroundChildren && (this.backgroundChildren.length = 0); var e, i = !t && this.sizerEventsEnable; if (i && (e = this.getChildren([])), jf.call(this, t), i) for (var n, s = 0, r = e.length; s < r; s++)(n = e[s]).emit("sizer.remove", n, this), this.emit("remove", n, this); return this } var Bf = Phaser.Utils.Objects.IsPlainObject, If = Phaser.Utils.Objects.GetValue, Rf = Phaser.Display.Align.CENTER, Af = Phaser.Utils.String.UUID, Df = { add: function (t, e, i, n, s, r, o, a, h) { cu.call(this, t), Bf(e) && (e = If(l = e, "key", void 0), i = If(l, "align", Rf), a = If(l, "offsetX", 0), h = If(l, "offsetY", 0), n = If(l, "padding", 0), s = If(l, "expand", !0), t.isRexSizer || (r = If(l, "minWidth", t._minWidth), o = If(l, "minHeight", t._minHeighted))); var l, u = void 0 !== e; return u || (e = Af()), "string" == typeof i && (i = Ll[i]), void 0 === i && (i = Rf), void 0 === a && (a = 0), void 0 === h && (h = 0), void 0 === n && (n = 0), void 0 === s && (s = !0), t.isRexSizer || (void 0 === r && (r = t._minWidth), void 0 === o && (o = t._minHeight)), (l = this.getSizerConfig(t)).align = i, l.alignOffsetX = a, l.alignOffsetY = h, l.padding = uu(n), Bf(s) ? (l.expandWidth = If(s, "width", !1), l.expandHeight = If(s, "height", !1)) : (l.expandWidth = s, l.expandHeight = s), t.isRexSizer || (l.expandWidth && (t.minWidth = void 0 === r ? jl(t) : r), l.expandHeight && (t.minHeight = void 0 === o ? Fl(t) : o)), this.sizerChildren.hasOwnProperty(e) && this.sizerChildren[e].destroy(), this.sizerChildren[e] = t, u && this.addChildrenMap(e, t), this } }, Lf = Phaser.Utils.Array.Remove, zf = dr.prototype.remove, jf = dr.prototype.clear, Ff = { remove: function (t, e) { var i; if ("string" == typeof t) { if (i = t, !(t = this.sizerChildren[i])) return this } else { if (this.getParentSizer(t) !== this) return this; i = this.childToKey(t) } return i && (delete this.sizerChildren[i], this.childrenMap.hasOwnProperty(i) && delete this.childrenMap[i]), Ef.call(this, t, e), this }, removeAll: function (t) { for (var e in this.sizerChildren) this.remove(e, t); return this }, clear: function (t) { for (var e in this.sizerChildren) delete this.sizerChildren[e], this.childrenMap.hasOwnProperty(e) && delete this.childrenMap[e]; return _f.call(this, t), this } }, Yf = { getChildrenWidth: function () { if (this.rexSizer.hidden) return 0; var t, e, i, n = 0, s = this.sizerChildren; for (var r in s) e = (t = s[r]).rexSizer.padding, i = this.getChildWidth(t) + e.left + e.right, n = Math.max(i, n); return n + this.space.left + this.space.right }, getChildrenHeight: function () { if (this.rexSizer.hidden) return 0; var t, e, i, n = 0, s = this.sizerChildren; for (var r in s) i = (t = s[r]).isRexSizer ? Math.max(t.minHeight, t.childrenHeight) : void 0 !== t.minHeight ? t.minHeight : Fl(t), i += (e = t.rexSizer.padding).top + e.bottom, n = Math.max(i, n); return n + this.space.top + this.space.bottom }, getExpandedChildWidth: function (t, e) { var i; void 0 === e && (e = this.width); var n = t.rexSizer; if (n.expandWidth) { var s = e - this.space.left - this.space.right, r = n.padding; i = s - r.left - r.right } return i }, getExpandedChildHeight: function (t, e) { var i; void 0 === e && (e = this.height); var n = t.rexSizer; if (n.expandHeight) { var s = e - this.space.top - this.space.bottom, r = n.padding; i = s - r.top - r.bottom } return i }, getChildrenSizers: function (t) { void 0 === t && (t = []); var e, i = this.sizerChildren; for (var n in i) (e = i[n]).isRexSizer && t.push(e); return t }, layoutChildren: function () { var t, e, i, n, s, r, o, a, h, l = this.innerLeft, u = this.innerTop, c = this.innerWidth, d = this.innerHeight, f = this.sizerChildren; for (var p in f) (t = f[p]).rexSizer.hidden || (i = (e = t.rexSizer).padding, zu.call(this, t), t.isRexSizer ? (t.runLayout(this, this.getExpandedChildWidth(t), this.getExpandedChildHeight(t)), Mf(t, this)) : (h = a = void 0, e.expandWidth && (a = c - i.left - i.right), e.expandHeight && (h = d - i.top - i.bottom), Lu(t, a, h)), n = l + i.left, r = c - i.left - i.right, s = u + i.top, o = d - i.top - i.bottom, ju.call(this, t, n, s, r, o, e.align, e.alignOffsetX, e.alignOffsetY)) } }; Object.assign(Yf, Df, Ff); function Wf(t, e) { if (Array.isArray(t)) return t.indexOf(e); for (var i in t) if (t[i] === e) return i; return null } var Vf = Phaser.Utils.Objects.IsPlainObject, Xf = Phaser.Utils.Objects.GetValue, Gf = function () { w(h, Of); var a = T(h); function h(t, e, i, n, s, r) { var o; return z(this, h), Vf(e) ? (e = Xf(r = e, "x", 0), i = Xf(r, "y", 0), n = Xf(r, "width", void 0), s = Xf(r, "height", void 0)) : Vf(n) && (n = Xf(r = n, "width", void 0), s = Xf(r, "height", void 0)), (o = a.call(this, t, e, i, n, s, r)).type = "rexOverlapSizer", o.sizerChildren = {}, o.addChildrenMap("items", o.sizerChildren), o } return k(h, [{ key: "childToKey", value: function (t) { if ("string" != typeof t) return Wf(this.sizerChildren, t); var e = t; return this.sizerChildren.hasOwnPropery(e) ? e : null } }]), h }(); Object.assign(Gf.prototype, Yf); function Uf(t, e, i) { var n = t.width / 2; return $f(n, n, e, i) <= n } function Hf(t, e, i) { if (this.enable && t.isDown) { var n = this.sizerChildren.knob; if (Uf(n, e, i)) { var s = n.width / 2, r = n.startAngle, o = Zf(s, s, e, i), a = n.anticlockwise ? r - o : o - r, h = Qf(a) / (2 * Math.PI); this.stopEaseValue(), 0 === this.easeValueDuration || Math.abs(this.value - h) < .1 ? this.value = h : this.easeValueTo(h) } } } function Nf(t, e, i) { if (this.enable && !this.panPointer) { var n = this.sizerChildren.knob; Uf(n, e, i) && ip.call(this, t) } } function Jf(t, e, i) { if (this.enable && t.isDown) { var n = this.sizerChildren.knob; switch (this.panState) { case rp: Uf(n, e, i) && ip.call(this, t); break; case op: Uf(n, e, i) ? sp.call(this) : np.call(this) } } } function Kf(t) { this.enable && this.panPointer === t && np.call(this) } function qf(t) { return void 0 === t && (t = this.value), this.textFormatCallbackScope ? this.textFormatCallback(t) : this.textFormatCallback.call(this.textFormatCallbackScope, t) } var $f = Phaser.Math.Distance.Between, Zf = Phaser.Math.Angle.Between, Qf = Phaser.Math.Angle.Normalize, tp = Phaser.Math.Angle.Between, ep = Phaser.Math.Angle.Wrap, ip = function (t) { this.panPointer = t, this.panState = op }, np = function () { this.panPointer = void 0, this.panState = rp }, sp = function () { var t = this.panPointer.prevPosition, e = this.panPointer.position, i = this.sizerChildren.knob, n = tp(i.x, i.y, t.x, t.y), s = tp(i.x, i.y, e.x, e.y), r = i.anticlockwise ? n - s : s - n, o = ep(r) / (2 * Math.PI); this.stopEaseValue(), this.value += o }, rp = 0, op = 1, ap = { setTextFormatCallback: function (t, e) { return this.textFormatCallback = t, this.textFormatCallbackScope = e, this }, getFormatText: qf, updateText: function () { var t = this.sizerChildren.text; return t && this.textFormatCallback && (t.setText(qf.call(this)), t.layout && t.layout()), this } }, hp = Phaser.Utils.Objects.GetValue, lp = Phaser.Math.Linear, up = Phaser.Math.Percent, cp = Phaser.Math.Snap.To, dp = function () { w(u, Gf); var l = T(u); function u(t, e) { var i; z(this, u), void 0 === e && (e = {}), (i = l.call(this, t, e)).type = "rexKnob", i.eventEmitter = hp(e, "eventEmitter", j(i)); var n = hp(e, "background", void 0), s = hp(e, "text", void 0); n && i.addBackground(n), s && (e.textColor = void 0, e.textStrokeColor = void 0, i.setTextFormatCallback(hp(e, "textFormatCallback", void 0), hp(e, "textFormatCallbackScope", void 0))); var r = new El(t, e); r.setDepth(hp(e, "knobDepth", 0)), r._value = -1, t.add.existing(r), i.add(r, "knob"), s && (i.add(s, "text", "center", 0, !1), t.children.moveBelow(r, s)), i.addChildrenMap("background", n), i.addChildrenMap("knob", r), i.addChildrenMap("text", s); var o = hp(e, "valuechangeCallback", null); if (null !== o) { var a = hp(e, "valuechangeCallbackScope", void 0); i.eventEmitter.on("valuechange", o, a) } i.setEnable(hp(e, "enable", void 0)), i.setEaseValuePropName("value").setEaseValueDuration(hp(e, "easeValue.duration", 0)).setEaseValueFunction(hp(e, "easeValue.ease", "Linear")), i.setGap(hp(e, "gap", void 0)), i.setValue(hp(e, "value", 0), hp(e, "min", void 0), hp(e, "max", void 0)); var h = hp(e, "input", 0); switch ("string" == typeof h && (h = fp[h]), h) { case 0: (function () { this.sizerChildren.knob.setInteractive().on("pointerdown", Nf, this).on("pointermove", Jf, this).on("pointerup", Kf, this), this.panPointer = void 0, this.panState = rp }).call(j(i)); break; case 1: (function () { this.sizerChildren.knob.setInteractive().on("pointerdown", Hf, this).on("pointermove", Hf, this) }).call(j(i)) }return i } return k(u, [{ key: "setEnable", value: function (t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "setGap", value: function (t) { return this.gap = t, this } }, { key: "value", get: function () { return this.sizerChildren.knob.value }, set: function (t) { void 0 !== this.gap && (t = cp(t, this.gap)); var e = this.value; this.sizerChildren.knob.value = t; var i = this.value; e !== i && (this.updateText(), this.eventEmitter.emit("valuechange", i, e, this.eventEmitter)) } }, { key: "setValue", value: function (t, e, i) { return null == t || (void 0 !== e && (t = up(t, e, i)), this.value = t), this } }, { key: "addValue", value: function (t, e, i) { return void 0 !== e && (t = up(t, e, i)), this.value += t, this } }, { key: "getValue", value: function (t, e) { var i = this.value; return void 0 !== t && (i = lp(t, e, i)), i } }]), u }(), fp = { pan: 0, drag: 0, click: 1, none: -1 }; Object.assign(dp.prototype, ap, Wh), c.register("knob", function (t) { var e = new dp(this.scene, t); return this.scene.add.existing(e), e }), R(window, "RexPlugins.UI.Knob", dp); function pp() { for (var t = this.getShapes(), e = 0, i = t.length; e < i; e++)t[e].lineStyle().fillStyle() } var vp = { arc: al, circle: hl, curve: ll, ellipse: ul, line: cl, lines: yl, rectangle: kl, triangle: xl }, gp = Phaser.Utils.Objects.GetValue, yp = Phaser.Utils.Objects.IsPlainObject, mp = { createShape: function (t, e) { var i = new vp[t]; return e && i.setName(e), i }, buildShapes: function (t) { var e = gp(t, "create", void 0); if (yp(e)) { var i = e; for (var n in i) { var s = i[n]; switch (P(s)) { case "number": for (var r = 0; r < s; r++)this.addShape(this.createShape(n)); break; case "string": this.addShape(this.createShape(n, s)); break; default: for (var o = s, a = (r = 0, o.length); r < a; r++)this.addShape(this.createShape(n, o[r])) } } } else if (Array.isArray(e)) for (r = 0, a = (i = e).length; r < a; r++) { var h = i[r]; this.addShape(this.createShape(h.type, h.name)) } else "function" == typeof e && e.call(this); this.setUpdateShapesCallback(gp(t, "update")) }, setUpdateShapesCallback: function (t) { return void 0 === t && (t = pp), this.dirty = this.dirty || this.updateCallback !== t, this.updateCallback = t, this }, updateShapes: function () { this.updateCallback.call(this) } }, kp = Phaser.Utils.Objects.GetValue, bp = Phaser.Utils.Objects.IsPlainObject, xp = function () { w(h, tl); var a = T(h); function h(t, e, i, n, s, r) { var o; return z(this, h), bp(e) && (e = kp(r = e, "x", 0), i = kp(r, "y", 0), n = kp(r, "width", 2), s = kp(r, "height", 2)), (o = a.call(this, t, e, i, n, s)).type = kp(r, "type", "rexCustomShapes"), o.buildShapes(r), o } return k(h) }(); Object.assign(xp.prototype, mp), c.register("customShapes", function (t, e, i, n, s) { var r = new xp(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r }), R(window, "RexPlugins.UI.CustomShapes", xp); var Cp = Phaser.Utils.Objects.GetValue, wp = Phaser.Utils.Objects.IsPlainObject, Sp = Phaser.Math.Clamp, Pp = Phaser.Math.Linear, Tp = Phaser.Math.Percent, Op = function () { w(u, xp); var l = T(u); function u(t, e, i, n, s, r) { var o; z(this, u), wp(e) && (e = Cp(r = e, "x", 0), i = Cp(r, "y", 0), n = Cp(r, "width", 2), s = Cp(r, "height", 2)), void 0 === r && (r = {}), r.type || (r.type = "rexCustomProgress"), (o = l.call(this, t, e, i, n, s, r)).eventEmitter = Cp(r, "eventEmitter", j(o)); var a = Cp(r, "valuechangeCallback", null); if (null !== a) { var h = Cp(r, "valuechangeCallbackScope", void 0); o.eventEmitter.on("valuechange", a, h) } return o.setEaseValuePropName("value").setEaseValueDuration(Cp(r, "easeValue.duration", 0)).setEaseValueFunction(Cp(r, "easeValue.ease", "Linear")), o.setValue(Cp(r, "value", 0)), o } return k(u, [{ key: "centerX", get: function () { return this.width / 2 } }, { key: "centerY", get: function () { return this.height / 2 } }, { key: "radius", get: function () { return Math.min(this.centerX, this.centerY) } }, { key: "value", get: function () { return this._value }, set: function (t) { t = Sp(t, 0, 1); var e = this._value, i = e != t; this.dirty = this.dirty || i, this._value = t, i && this.eventEmitter.emit("valuechange", this._value, e, this.eventEmitter) } }, { key: "setValue", value: function (t, e, i) { return null == t || (void 0 !== e && (t = Tp(t, e, i)), this.value = t), this } }, { key: "addValue", value: function (t, e, i) { return void 0 !== e && (t = Tp(t, e, i)), this.value += t, this } }, { key: "getValue", value: function (t, e) { var i = this.value; return void 0 !== t && (i = Pp(t, e, i)), i } }]), u }(); Object.assign(Op.prototype, Wh), c.register("customProgress", function (t, e, i, n, s) { var r = new Op(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r }), R(window, "RexPlugins.UI.CustomProgress", Op); function Mp(t, e, i, n, s) { switch (this.clear().fillStyle(16777215), this.shape) { case 1: var r = Math.min(t, e) / 2; this.fillCircle(-t * (n - .5), -e * (s - .5), r + i); break; default: this.fillRect(-t * n - i, -e * s - i, t + 2 * i, e + 2 * i) } } function Ep(t, e, i, n, s, r) { var o, a; null == i && (i = "__BASE"), Iu(r) || (void 0 === (a = r) && (a = ","), r = "__BASE" === (o = i) ? function (t, e) { return "".concat(t).concat(a).concat(e) } : function (t, e) { return "".concat(o, "_").concat(t).concat(a).concat(e) }); for (var h, l = t.sys.textures.get(e), u = l.frames[i], c = u.width / n, d = u.height / s, f = 0, p = 0, v = 0; v < s; v++) { for (var g = f = 0; g < n; g++)h = r(g, v), l.add(h, 0, f + u.cutX, p + u.cutY, c, d), f += c; p += d } return { getFrameNameCallback: r, cellWidth: c, cellHeight: d, columns: n, rows: s } } var _p = Phaser.Utils.Objects.IsPlainObject, Bp = Phaser.Utils.Objects.GetValue, Ip = { out: 0, in: 1 }, Rp = { setTransitionDirection: function (t) { return "string" == typeof t && (t = Ip[t]), this.dir = t, this }, setDuration: function (t) { return this.duration = t, this }, setEaseFunction: function (t) { return this.easeFunction = t, this }, setNextTexture: function (t, e) { return this.nextImage.setTexture(t, e), this }, transit: function (t, e) { if (this.isRunning && (this.ignoreCompleteEvent = !0, this.stop(), this.ignoreCompleteEvent = !1), _p(t)) { var i = t; t = Bp(i, "key", void 0), e = Bp(i, "frame", void 0), this.setDuration(Bp(i, "duration", this.duration)).setEaseFunction(Bp(i, "ease", this.easeFunction)).setTransitionDirection(Bp(i, "dir", this.dir)); var n = Bp(i, "mask", void 0); n && this.setMaskGameObject(n), this.setMaskEnable(!0 === n); var s = Bp(i, "onStart", void 0), r = Bp(i, "onProgress", void 0), o = Bp(i, "onComplete", void 0); void 0 === s && void 0 === r && void 0 === o || this.setTransitionStartCallback(s, Bp(i, "onStartScope", void 0)).setTransitionProgressCallback(r, Bp(i, "onProgressScope", void 0)).setTransitionCompleteCallback(o, Bp(i, "onCompleteScope", void 0)) } return this.setNextTexture(t, e), this.start(), this }, start: function () { return void 0 === this.easeValueTask && (this.easeValueTask = new Fh(this, { eventEmitter: null })), this.easeValueTask.restart({ key: "t", from: 0, to: 1, duration: this.duration, ease: this.easeFunction }), this }, pause: function () { return this.easeValueTask && this.easeValueTask.pause(), this }, resume: function () { return this.easeValueTask && this.easeValueTask.resume(), this }, stop: function () { return this.easeValueTask && this.easeValueTask.stop(), this.setT(1), this } }, Ap = Phaser.GameObjects.Graphics, Dp = function () { w(r, Ap); var s = T(r); function r(t, e, i) { var n; return z(this, r), void 0 === e && (e = 0), "string" == typeof e && (e = Lp[e]), void 0 === i && (i = 0), (n = s.call(this, t.scene)).parent = t, n.shape = e, n.padding = i, n.setPosition().resize().setVisible(!1), n } return k(r, [{ key: "destroy", value: function () { return this.parent = void 0, O(C(r.prototype), "destroy", this).call(this), this } }, { key: "setPosition", value: function (t, e) { var i = this.parent; return void 0 === t && (t = i.x), void 0 === e && (e = i.y), O(C(r.prototype), "setPosition", this).call(this, t, e), this } }, { key: "resize", value: function (t, e, i) { var n = this.parent; return void 0 === t && (t = n.width), void 0 === e && (e = n.height), void 0 === i && (i = this.padding), this.widthSave === t && this.heightSave === e && this.paddingSave === i || (this.widthSave = t, this.heightSave = e, this.paddingSave = i, this.originXSave = n.originX, this.originYSave = n.originY, Mp.call(this, t, e, i, n.originX, n.originY)), this } }, { key: "setOrigin", value: function (t, e) { void 0 === e && (e = t); var i = this.parent; return void 0 === t && (t = i.originX), void 0 === e && (e = i.originY), this.originXSave === t && this.originYSave === e || (this.originXSave = t, this.originYSave = e, Mp.call(this, this.widthSave, this.heightSave, this.paddingSave, t, e)), this } }]), r }(), Lp = { rectangle: 0, circle: 1 }, zp = { setMaskGameObject: function (t) { if (!t) return this.removeMaskGameObject(), this; if (this.maskGameObject) { if (!0 === t && this.maskGameObject instanceof Dp) return this; if (this.maskGameObject === t) return this; this.removeMaskGameObject() } return !0 === t && (t = new Dp(this)), this.maskGameObject = t, this.maskGameObject.resize(this.width, this.height).setOrigin(this.originX, this.originY).setPosition(0, 0).setScale(1).setVisible(!1), this.addLocal(this.maskGameObject), this.childrenMask = this.maskGameObject.createGeometryMask(), this }, removeMaskGameObject: function () { return this.backImage.clearMask(), this.frontImage.clearMask(), this.childrenMask = void 0, this.remove(this.maskGameObject, !0), this.maskGameObject = void 0, this }, setImageMaskEnable: function (t, e, i) { return void 0 === e && (e = !0), this.childrenMask || this.setMaskGameObject(!0), e ? (t.setMask(this.childrenMask), i && this.childrenMask.setInvertAlpha()) : t.clearMask(), this }, setCurrentImageMaskEnable: function (t, e) { return this.setImageMaskEnable(this.currentImage, t, e), this }, setNextImageMaskEnable: function (t, e) { return this.setImageMaskEnable(this.nextImage, t, e), this }, setCellImagesMaskEnable: function (t, e) { for (var i = this.getCellImages(), n = 0, s = i.length; n < s; n++)this.setImageMaskEnable(i[n], t, e); return this }, setMaskEnable: function (t, e) { return this.setImageMaskEnable(this.backImage, t, e), this.setImageMaskEnable(this.frontImage, t, e), this.setCellImagesMaskEnable(t, e), this } }, jp = Phaser.Utils.Objects.GetValue, Fp = Phaser.GameObjects.Image, Yp = Phaser.Utils.Objects.IsPlainObject, Wp = Phaser.Math.RotateAround, Vp = { gridCutImage: function (t, e, i, n) { void 0 === n && (n = {}), n.objectPool = this.imagesPool; for (var s, r = function (t, e, i, n) { Yp(e) && (e = jp(n = e, "columns", 1), i = jp(n, "rows", 1)); for (var s = jp(n, "ImageClass", Fp), r = jp(n, "originX", .5), o = jp(n, "originY", .5), a = jp(n, "add", !0), h = jp(n, "align", a), l = jp(n, "objectPool", void 0), u = t.scene, c = t.texture.key, d = t.frame.name, f = Ep(u, c, d, e, i), p = f.getFrameNameCallback, v = t.scaleX, g = t.scaleY, y = t.rotation, m = t.getTopLeft(), k = m.x, b = m.y, x = [], C = f.cellWidth * v, w = f.cellHeight * g, S = 0; S < i; S++)for (var P = 0; P < e; P++) { var T, O = p(P, S); T = l && 0 < l.length ? l.pop().setTexture(c, O) : new s(u, 0, 0, c, O), a && u.add.existing(T); var M = k + C * P + r * C, E = b + w * S + o * w; h && (T.setOrigin(r, o).setPosition(M, E).setScale(v, g).setRotation(y), Wp(T, k, b, y)), x.push(T) } return x }(t, e, i, n), o = 0, a = r.length; o < a; o++)(s = r[o]).setVisible(!0), this.add(s); return this.cellImages = r, this.setChildLocalVisible(t, !1), r }, gridCutCurrentImage: function (t, e, i) { return this.gridCutImage(this.currentImage, t, e, i) }, gridCutNextImage: function (t, e, i) { return this.gridCutImage(this.nextImage, t, e, i) }, getCellImages: function () { return this.cellImages }, freeCellImages: function () { var t; if (0 === this.cellImages.length) return this; for (var e, i, n = this.cellImages[0].texture, s = this.cellImages, r = 0, o = s.length; r < o; r++)e = s[r], this.setChildLocalAlpha(e, 1).setChildLocalScale(e, 1).setChildLocalVisible(e, !1), e.clearMask(), i = e.frame.name, e.setTexture(), n.remove(i); return (t = this.imagesPool).push.apply(t, M(s)), s.length = 0, this } }, Xp = {}; Object.assign(Xp, { setTransitionStartCallback: function (t, e) { return this.onStartCallback = t, this.onStartCallbackScope = e, this }, setTransitionProgressCallback: function (t, e) { return this.onProgressCallback = t, this.onProgressCallbackScope = e, this }, setTransitionCompleteCallback: function (t, e) { return this.onCompleteCallback = t, this.onCompleteCallbackScope = e, this } }, Rp, zp, Vp); function Gp() { } function Up(t, e, i, n) { t.setChildLocalAlpha(e, 1 - n).setChildLocalAlpha(i, n) } function Hp(t, e) { t.setChildLocalAlpha(e, 1) } var Np = Phaser.Utils.Objects.IsPlainObject, Jp = Phaser.Utils.Objects.GetValue, Kp = Phaser.Math.Clamp, qp = function () { w(y, dr); var g = T(y); function y(t, e, i, n, s, r) { var o; z(this, y), Np(e) ? (e = Jp(r = e, "x", 0), i = Jp(r, "y", 0), n = Jp(r, "key", void 0), s = Jp(r, "frame", void 0)) : Np(s) && (r = s, s = void 0); var a = Jp(r, "back", void 0), h = Jp(r, "front", void 0); a = a || t.add.image(e, i, n, s), h = h || t.add.image(e, i, n, s); var l = Jp(r, "width", h.width), u = Jp(r, "height", h.height); o = g.call(this, t, e, i, l, u), a.setVisible(!1), o.addMultiple([a, h]), o.type = "rexTransitionImage", o.backImage = a, o.frontImage = h, o.maskGameObject = void 0, o.cellImages = [], o.imagesPool = []; var c = Jp(r, "onStart", void 0), d = Jp(r, "onProgress", void 0), f = Jp(r, "onComplete", void 0), p = Jp(r, "dir", 0); void 0 === c && void 0 === d && void 0 === f && (c = Gp, d = Up, f = Hp, p = 0), o.setTransitionStartCallback(c, Jp(r, "onStartScope", void 0)).setTransitionProgressCallback(d, Jp(r, "onProgressScope", void 0)).setTransitionCompleteCallback(f, Jp(r, "onCompleteScope", void 0)).setTransitionDirection(p).setDuration(Jp(r, "duration", 1e3)).setEaseFunction(Jp(r, "ease", "Linear")); var v = Jp(r, "mask", void 0); return v && o.setMaskGameObject(v), o.setMaskEnable(!1), o.ignoreCompleteEvent = !1, o } return k(y, [{ key: "destroy", value: function (t) { this.scene && (this.childrenMask && (this.childrenMask.destroy(), this.childrenMask = void 0), this.backImage = void 0, this.frontImage = void 0, this.maskGameObject = void 0, this.cellImages.length = 0, this.imagesPool.length = 0, O(C(y.prototype), "destroy", this).call(this, t), this.onStartCallback = void 0, this.onStartCallbackScope = void 0, this.onProgressCallback = void 0, this.onProgressCallbackScope = void 0, this.onCompleteCallback = void 0, this.onCompleteCallbackScope = void 0, this.easeValueTask = void 0) } }, { key: "currentImage", get: function () { return 0 === this.dir ? this.frontImage : this.backImage } }, { key: "nextImage", get: function () { return 0 === this.dir ? this.backImage : this.frontImage } }, { key: "texture", get: function () { return this.nextImage.texture } }, { key: "frame", get: function () { return this.nextImage.frame } }, { key: "t", get: function () { return this._t }, set: function (t) { if (t = Kp(t, 0, 1), this._t !== t) { this._t = t; var e = this.currentImage, i = this.nextImage; if (0 === t && (this.setChildVisible(this.frontImage, !0).setChildVisible(this.backImage, !0), $p(this.onStartCallback, this.onStartCallbackScope, this, e, i, t)), $p(this.onProgressCallback, this.onProgressCallbackScope, this, e, i, t), 1 === t) { $p(this.onCompleteCallback, this.onCompleteCallbackScope, this, e, i, t); var n = i.texture.key, s = i.frame.name; this.frontImage.setTexture(n, s), this.backImage.setTexture(n, s), this.setChildVisible(this.frontImage, !0).setChildVisible(this.backImage, !1).setMaskEnable(!1).freeCellImages() } 1 !== t || this.ignoreCompleteEvent || this.emit("complete") } } }, { key: "setT", value: function (t) { return this.t = t, this } }, { key: "isRunning", get: function () { return !!this.easeValueTask && this.easeValueTask.isRunning } }, { key: "setOrigin", value: function (t, e) { return O(C(y.prototype), "setOrigin", this).call(this, t, e), this.backImage.setOrigin(t, e), this.frontImage.setOrigin(t, e), this.maskGameObject && this.maskGameObject.setOrigin(t, e), this } }, { key: "setTexture", value: function (t, e) { return this.frontImage.setTexture(t, e), this.backImage.setTexture(t, e).setVisible(!1), this } }]), y }(), $p = function (t, e, i, n, s, r) { t && (e ? t.call(e, i, n, s, r) : t(i, n, s, r)) }; Object.assign(qp.prototype, Xp), c.register("transitionImage", function (t, e, i, n, s) { var r = new qp(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r }), R(window, "RexPlugins.UI.TransitionImage", qp); var Zp = Phaser.GameObjects.Rectangle, Qp = function () { w(r, Zp); var s = T(r); function r(t, e, i) { var n; return z(this, r), (n = s.call(this, t, 0, 0, 2, 2, e, 1)).setAlpha(i), n.setScrollFactor(0), n.boot(), n } return k(r, [{ key: "boot", value: function () { this.scene.sys.events.on("prerender", this.resize, this) } }, { key: "destroy", value: function (t) { this.scene && (this.scene.sys.events.off("prerender", this.resize, this), O(C(r.prototype), "destroy", this).call(this, t)) } }, { key: "tint", get: function () { return this.fillColor }, set: function (t) { this.setFillStyle(t, this.fillAlpha) } }, { key: "resize", value: function () { var t = this.scene, e = t.sys.scale.gameSize, i = t.sys.cameras.main, n = e.width, s = e.height, r = 1 / i.zoom, o = n / 2, a = s / 2, h = n * r, l = s * r; this.x === o && this.y === a || this.setPosition(o, a), this.width === h && this.height === l || this.setSize(h, l).setOrigin(.5) } }]), r }(); c.register("fullWindowRectangle", function (t, e) { var i = new Qp(this.scene, t, e); return this.scene.add.existing(i), i }), R(window, "RexPlugins.UI.FullWindowRectangle", Qp); var tv = Phaser.Utils.Objects.GetValue, ev = function () { w(s, Ta); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, t, { eventEmitter: !1 })).resetFromJSON(e), i.boot(), i } return k(s, [{ key: "resetFromJSON", value: function (t) { return this.setHitAreaMode(tv(t, "hitAreaMode", 0)), this.setEnable(tv(t, "enable", !0)), this } }, { key: "boot", value: function () { this.parent.on("pointerdown", function (t, e, i, n) { n.stopPropagation() }).on("pointerup", function (t, e, i, n) { n.stopPropagation() }).on("pointermove", function (t, e, i, n) { n.stopPropagation() }).on("pointerover", function (t, e, i, n) { n.stopPropagation() }).on("pointerout", function (t, e) { e.stopPropagation() }) } }, { key: "setHitAreaMode", value: function (t) { "string" == typeof t && (t = iv[t]); var e = this.parent; return e.input && e.removeInteractive(), 0 === t ? e.setInteractive() : e.setInteractive({ hitArea: {}, hitAreaCallback: function () { return !0 } }), this } }, { key: "setEnable", value: function (t) { return void 0 === t && (t = !0), t ? this.parent.setInteractive() : this.parent.disableInteractive(), this.enable = t, this } }, { key: "toggleEnable", value: function () { return this.setEnable(!this.enable), this } }]), s }(), iv = { default: 0, fullWindow: 1 }, nv = Phaser.Utils.Objects.GetValue, sv = function () { w(o, Qp); var r = T(o); function o(t, e) { var i; z(this, o); var n = nv(e, "color", 0), s = nv(e, "alpha", .8); return (i = r.call(this, t, n, s)).touchEventStop = new ev(j(i), { hitAreaMode: 1 }), i } return k(o) }(); c.register("cover", function (t) { var e = new sv(this.scene, t); return this.scene.add.existing(e), e }), R(window, "RexPlugins.UI.Cover", sv); var rv = function (e, t) { void 0 === t && (t = {}), void 0 === t.options && (t.options = {}); var i = t.options; i.responsive = !1, i.maintainAspectRatio = !1, i.hasOwnProperty("devicePixelRatio") || (i.devicePixelRatio = 1); var n = !1; void 0 === i.animation ? i.animation = {} : !1 === i.animation && (n = !0, i.animation = {}); var s = i.animation; n && (s.duration = 0); var r = s.onProgress; s.onProgress = function (t) { r && r(t), e.needRedraw() }; var o = s.onComplete; return s.onComplete = function (t) { o && o(t), e.needRedraw() }, t }, ov = function () { w(h, $t); var a = T(h); function h(t, e, i, n, s, r) { var o; return z(this, h), (o = a.call(this, t, e, i, n, s)).type = "rexChart", (o.chart = void 0) !== r && o.setChart(r), o } return k(h, [{ key: "destroy", value: function (t) { this.scene && (this.chart && (this.chart.destroy(), this.chart = void 0), O(C(h.prototype), "destroy", this).call(this, t)) } }, { key: "resize", value: function (t, e) { if (t === this.width && e === this.height) return this; if (O(C(h.prototype), "resize", this).call(this, t, e), this.chart) { var i = this.chart; i.height = this.canvas.height, i.width = this.canvas.width, i.aspectRatio = i.height ? i.width / i.height : null, i.update() } return this } }]), h }(), av = { setChart: function (t) { if (window.Chart) return this.chart && this.chart.destroy(), this.chart = new Chart(this.context, rv(this, t)), this; return console.error("Can not find chartjs! Load chartjs in preload stage.\nscene.load.script('chartjs', 'https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.8.0/Chart.min.js');"), this }, getChartDataset: function (t) { if (void 0 !== this.chart) { if ("string" != typeof t) return this.chart.data.datasets[t]; for (var e, i = this.chart.data.datasets, n = 0, s = i.length; n < s; n++)if ((e = i[n]).label === t) return e } }, getChartData: function (t, e) { var i = this.getChartDataset(t); if (void 0 !== i) { if ("string" == typeof e) if (-1 === (e = this.chart.data.labels.indexOf(e))) return; return i.data[e] } }, setChartData: function (t, e, i) { if (void 0 === this.chart) return this; var n = this.getChartDataset(t); if ("string" == typeof e && -1 === (e = this.chart.data.labels.indexOf(e))) return this; return n.data[e] = i, this }, updateChart: function () { return void 0 === this.chart || this.chart.update(), this } }; Object.assign(ov.prototype, av), c.register("chart", function (t, e, i, n, s) { var r = new ov(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r }), R(window, "RexPlugins.UI.Chart", ov); function hv(t, e, i, n, s, r, o, a) { cu.call(this, t); var h = t.isRexSpace, l = P(e); if (null === e) return this; if ("number" !== l) if ("string" === l) e = pv[e]; else if (cv(e)) { var u; e = dv(u = e, "proportion", void 0), i = dv(u, "align", fv), n = dv(u, "padding", 0), s = dv(u, "expand", !1), r = dv(u, "key", void 0), o = dv(u, "index", void 0), t.isRexSizer || (a = 0 === this.orientation ? dv(u, "minWidth", void 0) : dv(u, "minHeight", void 0)) } return "string" == typeof i && (i = Ll[i]), void 0 === e && (e = h ? 1 : 0), void 0 === i && (i = fv), void 0 === n && (n = 0), void 0 === s && (s = !1), void 0 === a && (h ? a = 0 : t.isRexSizer || (a = 0 === this.orientation ? t._minWidth : t._minHeight)), (u = this.getSizerConfig(t)).proportion = e, u.align = i, u.padding = uu(n), u.expand = s, void 0 === o || o >= this.sizerChildren.length ? this.sizerChildren.push(t) : this.sizerChildren.splice(o, 0, t), !t.isRexSizer && 0 < e && (0 === this.orientation ? t.minWidth = void 0 === a ? jl(t) : a : t.minHeight = void 0 === a ? Fl(t) : a), void 0 !== r && this.addChildrenMap(r, t), this } var lv = Phaser.GameObjects.Zone, uv = function () { w(n, lv); var i = T(n); function n(t) { var e; return z(this, n), (e = i.call(this, t, 0, 0, 1, 1)).isRexSpace = !0, e } return k(n) }(), cv = Phaser.Utils.Objects.IsPlainObject, dv = Phaser.Utils.Objects.GetValue, fv = Phaser.Display.Align.CENTER, pv = { min: 0, full: -1 }, vv = { add: hv, addSpace: function (t) { return this.insertSpace(void 0, t), this }, insertSpace: function (t, e) { return void 0 === e && (e = 1), hv.call(this, new uv(this.scene), { proportion: e, minWidth: 0, minHeight: 0, index: t }), this }, insert: function (t, e, i, n, s, r, o, a) { return cv(i) && (i.index = t), hv.call(this, e, i, n, s, r, o, t, a), this }, insertAtPosition: function (t, e, i, n, s, r, o, a, h) { var l = function (t, e) { var i = this.sizerChildren; if (0 === i.length) return -1; for (var n = -1, s = 1 / 0, r = 0, o = i.length; r < o; r++) { var a = i[r]; (h = 0 === this.orientation ? Math.abs(a.left - t) : Math.abs(a.top - e)) < s && (s = h, n = r) } var h; a = i[i.length - 1]; return (h = 0 === this.orientation ? Math.abs(a.right - t) : Math.abs(a.bottom - e)) < s && (s = h, n = r + 1), n }.call(this, t, e); return -1 === l && (l = void 0), this.insert(l, i, n, s, r, o, a, h), this } }, gv = Phaser.Utils.Array.Remove, yv = { remove: function (t, e) { return this.getParentSizer(t) !== this || (gv(this.sizerChildren, t), Ef.call(this, t, e)), this }, removeAll: function (t) { for (var e = this.sizerChildren.length - 1; 0 <= e; e--)this.remove(this.sizerChildren[e], t); return this }, clear: function (t) { return this.sizerChildren.length = 0, _f.call(this, t), this } }, mv = { getChildrenWidth: function (t) { if (this.rexSizer.hidden) return 0; void 0 === t && (t = !0); var e, i, n, s = 0, r = this.sizerChildren; if (0 === this.orientation) for (var o = 0, a = r.length; o < a; o++)(e = r[o]).rexSizer.hidden || (n = 0 === e.rexSizer.proportion || t && 0 < e.rexSizer.proportion ? this.getChildWidth(e) : 0, n += (i = e.rexSizer.padding).left + i.right, 0 < o && (n += this.space.item), s += n); else for (o = 0, a = r.length; o < a; o++)(e = r[o]).hasOwnProperty("rexSizer") && (e.rexSizer.hidden || (i = e.rexSizer.padding, n = this.getChildWidth(e) + i.left + i.right, s = Math.max(n, s))); return s + this.space.left + this.space.right }, getChildrenHeight: function (t) { if (this.rexSizer.hidden) return 0; void 0 === t && (t = !0); var e, i, n, s = 0, r = this.sizerChildren; if (0 === this.orientation) for (var o = 0, a = r.length; o < a; o++)(e = r[o]).rexSizer.hidden || (i = e.rexSizer.padding, n = this.getChildHeight(e) + i.top + i.bottom, s = Math.max(n, s)); else for (o = 0, a = r.length; o < a; o++)(e = r[o]).hasOwnProperty("rexSizer") && (e.rexSizer.hidden || (i = e.rexSizer.padding, n = 0 === e.rexSizer.proportion || t && 0 < e.rexSizer.proportion ? this.getChildHeight(e) : 0, n += i.top + i.bottom, 0 < o && (n += this.space.item), s += n)); return s + this.space.top + this.space.bottom }, getExpandedChildWidth: function (t, e) { var i; void 0 === e && (e = this.width); var n = t.rexSizer, s = n.padding; 0 === this.orientation ? 0 < n.proportion && 0 < this.proportionLength && (i = n.proportion * this.proportionLength) : n.expand && (i = e - this.space.left - this.space.right - s.left - s.right); return i }, getExpandedChildHeight: function (t, e) { var i; void 0 === e && (e = this.height); var n = t.rexSizer, s = n.padding; 0 === this.orientation ? n.expand && (i = e - this.space.top - this.space.bottom - s.top - s.bottom) : 0 < n.proportion && 0 < this.proportionLength && (i = n.proportion * this.proportionLength); return i }, getChildrenSizers: function (t) { void 0 === t && (t = []); for (var e, i = this.sizerChildren, n = 0, s = i.length; n < s; n++)(e = i[n]).isRexSizer && t.push(e); return t }, preLayout: function () { return this._childrenProportion = void 0, this.proportionLength = void 0, vu.call(this), this }, layoutChildren: function () { for (var t, e, i, n, s, r, o, a, h, l = this.sizerChildren, u = this.innerLeft, c = this.innerTop, d = this.innerWidth, f = this.innerHeight, p = u, v = c, g = 0, y = l.length; g < y; g++)(t = this.rtl ? l[y - g - 1] : l[g]).rexSizer.hidden || (i = (e = t.rexSizer).padding, zu.call(this, t), h = t.isRexSpace ? a = 0 : (a = this.getExpandedChildWidth(t), this.getExpandedChildHeight(t)), t.isRexSizer ? (t.runLayout(this, a, h), Mf(t, this)) : Lu(t, a, h), void 0 === a && (a = jl(t)), void 0 === h && (h = Fl(t)), o = 0 === this.orientation ? (n = p + i.left, r = 0 === e.proportion || 0 === this.proportionLength ? a : e.proportion * this.proportionLength, s = v + i.top, f - i.top - i.bottom) : (n = p + i.left, r = d - i.left - i.right, s = v + i.top, 0 === e.proportion || 0 === this.proportionLength ? h : e.proportion * this.proportionLength), ju.call(this, t, n, s, r, o, e.align), 0 === this.orientation ? p += r + i.left + i.right + this.space.item : v += o + i.top + i.bottom + this.space.item) }, resolveWidth: function (t) { t = fu.call(this, t); if (void 0 === this.proportionLength && 0 === this.orientation) { var e = t - this.childrenWidth; 0 < e ? (e = t - this.getChildrenWidth(!1), this.proportionLength = e / this.childrenProportion) : this.proportionLength = 0 } return t }, resolveHeight: function (t, e) { e = pu.call(this, t, e); if (void 0 === this.proportionLength && 1 === this.orientation) { var i = e - this.childrenHeight; 0 < i ? (i = e - this.getChildrenHeight(!1), this.proportionLength = i / this.childrenProportion) : this.proportionLength = 0 } return e } }; Object.assign(mv, vv, yv); function kv(t) { return "string" == typeof t && (t = bv[t]), t } var bv = { x: 0, h: 0, horizontal: 0, "left-to-right": 0, y: 1, v: 1, vertical: 1, "top-to-bottom": 1 }, xv = Phaser.Utils.Objects.IsPlainObject, Cv = Phaser.Utils.Objects.GetValue, wv = function () { w(l, Of); var h = T(l); function l(t, e, i, n, s, r, o) { var a; return z(this, l), xv(e) ? (e = Cv(o = e, "x", 0), i = Cv(o, "y", 0), n = Cv(o, "width", void 0), s = Cv(o, "height", void 0), r = Cv(o, "orientation", 0)) : xv(n) ? (n = Cv(o = n, "width", void 0), s = Cv(o, "height", void 0), r = Cv(o, "orientation", 0)) : xv(r) && (r = Cv(o = r, "orientation", 0)), void 0 === r && (r = 0), (a = h.call(this, t, e, i, n, s, o)).type = "rexSizer", a.sizerChildren = [], a.setOrientation(r), a.setItemSpacing(Cv(o, "space.item", 0)), a.setRTL(Cv(o, "rtl", !1)), a.addChildrenMap("items", a.sizerChildren), a } return k(l, [{ key: "setOrientation", value: function (t) { return this.orientation = kv(t), this } }, { key: "setItemSpacing", value: function (t) { return this.space.item = t, this } }, { key: "setRTL", value: function (t) { return void 0 === t && (t = !0), this.rtl = t, this } }, { key: "childrenProportion", get: function () { return void 0 === this._childrenProportion && (this._childrenProportion = function () { for (var t, e, i = 0, n = this.sizerChildren, s = 0, r = n.length; s < r; s++)(t = n[s]).rexSizer.hidden || 0 < (e = t.rexSizer.proportion) && (i += e); return i }.call(this)), this._childrenProportion } }]), l }(); Object.assign(wv.prototype, mv), c.register("sizer", function (t, e, i, n, s, r) { var o = new wv(this.scene, t, e, i, n, s, r); return this.scene.add.existing(o), o }), R(window, "RexPlugins.UI.Sizer", wv); function Sv() { return Array.prototype.reduce.call(arguments, Ev, 0) } function Pv(t, e, i, n, s) { if ("number" == typeof t || "number" == typeof e) if (void 0 === t) { for (var r = 0; r < n; r++)if (!i[o = e * n + r]) return o } else if (void 0 === e) { for (r = 0; r < s; r++)if (!i[o = r * n + t]) return o } else { if (!i[o = e * n + t]) return o } else if (!0 === e) { var o; for (r = 0; r < n; r++)for (var a = 0; a < s; a++)if (!i[o = a * n + r]) return o } else { r = 0; for (var h = i.length; r < h; r++)if (!i[r]) return r } return null } function Tv(t, e, i, n) { void 0 === i && (i = 0), void 0 === n && (n = t.length - 1); for (var s = i; s <= n; s++)t[s] = e; return t } function Ov(t, e, i) { void 0 === e && (e = this.rowProportions[0] || 0), void 0 === i && (i = this.space.row[0] || 0), this.rowCount += 1, this.gridCount += this.columnCount; for (var n = [t * this.columnCount, 0], s = 0; s < this.columnCount; s++)n.push(null); return this.sizerChildren.splice.apply(this.sizerChildren, n), this.rowProportions.push(e), this.rowHeight.length += 1, this.space.row.splice(t, 0, i), this } function Mv(t, e, i) { void 0 === e && (e = this.columnProportions[0] || 0), void 0 === i && (i = this.space.column[0] || 0), this.columnCount += 1, this.gridCount += this.rowCount; for (var n = this.rowCount - 1; 0 <= n; n--) { var s = n * this.columnCount + t; this.sizerChildren.splice(s, 0, null) } return this.columnProportions.push(e), this.columnWidth.length += 1, this.space.column.splice(t, 0, i), this } var Ev = function (t, e) { return t + e }, _v = Phaser.Utils.Objects.IsPlainObject, Bv = Phaser.Utils.Objects.GetValue, Iv = Phaser.Display.Align.CENTER, Rv = { add: function (t, e, i, n, s, r, o) { cu.call(this, t), _v(e) && (e = Bv(a = e, "column", void 0), i = Bv(a, "row", void 0), n = Bv(a, "align", Iv), s = Bv(a, "padding", 0), r = Bv(a, "expand", !1), o = Bv(a, "key", void 0)); var a, h = Pv(e, i, this.sizerChildren, this.columnCount, this.rowCount); if (null === h) { if ("number" == typeof e && "number" == typeof i) return this; !0 === i || "number" == typeof i ? this.addEmptyColumn() : this.addEmptyRow(), h = Pv(e, i, this.sizerChildren, this.columnCount, this.rowCount) } return "string" == typeof n && (n = Ll[n]), void 0 === n && (n = Iv), void 0 === s && (s = 0), void 0 === r && (r = !0), (a = this.getSizerConfig(t)).align = n, a.padding = uu(s), a.expand = r, this.sizerChildren[h] = t, void 0 !== o && this.addChildrenMap(o, t), this } }, Av = { remove: function (t, e) { if (this.getParentSizer(t) !== this) return this; var i = this.sizerChildren.indexOf(t); return -1 !== i && (this.sizerChildren[i] = null), Ef.call(this, t, e), this }, removeAt: function (t, e, i) { var n = this.getChildAt(t, e); return n && this.remove(n, i), this }, removeAll: function (t) { for (var e = this.sizerChildren.length - 1; 0 <= e; e--) { var i = this.sizerChildren[e]; i && this.remove(i, t) } return this }, clear: function (t) { return Tv(this.sizerChildren, null), _f.call(this, t), this } }, Dv = Phaser.Utils.Objects.GetValue, Lv = { getChildrenWidth: function () { if (this.rexSizer.hidden) return 0; for (var t, e, i, n, s = 0, r = this.sizerChildren, o = 0; o < this.columnCount; o++) { if ((t = 0) === this.columnProportions[o]) { for (var a = 0; a < this.rowCount; a++)(e = r[a * this.columnCount + o]) && (e.rexSizer.hidden || (i = e.rexSizer.padding, n = this.getChildWidth(e) + i.left + i.right, t = Math.max(t, n))); s += t } this.columnWidth[o] = t } var h = this.space, l = Math.max(h.indentLeftOdd, h.indentLeftEven); return s + Sv.apply(void 0, [h.left, l].concat(M(h.column), [h.right])) }, getChildrenHeight: function () { if (this.rexSizer.hidden) return 0; for (var t, e, i, n, s = 0, r = this.sizerChildren, o = 0; o < this.rowCount; o++) { if ((t = 0) === this.rowProportions[o]) { for (var a = 0; a < this.columnCount; a++)(e = r[o * this.columnCount + a]) && (e.rexSizer.hidden || (n = e.isRexSizer ? Math.max(e.minHeight, e.childrenHeight) : e.hasOwnProperty("minHeight") ? e.minHeight : Fl(e), n += (i = e.rexSizer.padding).top + i.bottom, t = Math.max(t, n))); s += t } this.rowHeight[o] = t } var h = this.space, l = Math.max(h.indentTopOdd, h.indentTopEven); return s + Sv.apply(void 0, [h.top, l].concat(M(h.row), [h.bottom])) }, getExpandedChildWidth: function (t, e) { var i, n = t.rexSizer; if (n.expand) { var s = n.padding; i = e - s.left - s.right } return i }, getExpandedChildHeight: function (t, e) { var i, n = t.rexSizer; if (n.expand) { var s = n.padding; i = e - s.top - s.bottom } return i }, getChildrenSizers: function (t) { void 0 === t && (t = []); for (var e, i = this.sizerChildren, n = 0, s = i.length; n < s; n++)(e = i[n]) && e.isRexSizer && t.push(e); return t }, preLayout: function () { return this._totalColumnProportions = void 0, this._totalRowProportions = void 0, this.proportionWidthLength = void 0, this.proportionHeightLength = void 0, vu.call(this), this }, layoutChildren: function () { for (var t, e, i, n, s, r, o, a, h, l, u, c, d = this.innerLeft, f = this.innerTop, p = this.space.column, v = this.space.row, g = this.space.indentLeftOdd, y = this.space.indentLeftEven, m = this.space.indentTopOdd, k = this.space.indentTopEven, b = 0; b < this.rowCount; b++) { c = this.getRowHeight(b), n = d + (b % 2 ? y : g); for (var x = 0; x < this.columnCount; x++)u = this.getColumnWidth(x), (t = this.getChildAt(x, b)) && !t.rexSizer.hidden && (zu.call(this, t), h = this.getExpandedChildWidth(t, u), l = this.getExpandedChildHeight(t, c), t.isRexSizer ? (t.runLayout(this, h, l), Mf(t, this)) : Lu(t, h, l), s = n + (i = (e = t.rexSizer).padding).left, o = u - i.left - i.right, r = f + (x % 2 ? k : m) + i.top, a = c - i.top - i.bottom, ju.call(this, t, s, r, o, a, e.align)), n += u + p[x]; f += c + v[b] } }, resolveWidth: function (t) { t = fu.call(this, t); if (void 0 === this.proportionWidthLength) { var e = this.totalColumnProportions; if (0 < e) { var i = t - this.childrenWidth; 0 <= i && (this.proportionWidthLength = i / e) } else this.proportionWidthLength = 0 } return t }, resolveHeight: function (t, e) { e = pu.call(this, t, e); if (void 0 === this.proportionHeightLength) { var i = this.totalRowProportions; if (0 < i) { var n = e - this.childrenHeight; 0 <= n && (this.proportionHeightLength = n / i) } else this.proportionHeightLength = 0 } return e }, resolveChildrenWidth: function () { var t, e, i; for (var n in this.sizerChildren) (t = this.sizerChildren[n]) && t.isRexSizer && !t.ignoreLayout && (i = this.getColumnWidth(parseInt(n) % this.columnCount), e = this.getExpandedChildWidth(t, i), e = t.resolveWidth(e), t.resolveChildrenWidth(e)) }, runWidthWrap: function () { var t, e, i; for (var n in this.sizerChildren) !(t = this.sizerChildren[n]) || t.isRexSizer && t.ignoreLayout || !t.runWidthWrap || (i = this.getColumnWidth(parseInt(n) % this.columnCount), e = this.getExpandedChildWidth(t, i), t.isRexSizer && (e = t.resolveWidth(e)), t.runWidthWrap(e)); return this }, resetGrid: function (t, e, i, n, s) { if (void 0 === i && (i = 0), void 0 === n && (n = 0), this.columnCount = t, this.rowCount = e, this.gridCount = t * e, void 0 === this.sizerChildren ? this.sizerChildren = [] : this.removeAll(), this.sizerChildren.length = t * e, Tv(this.sizerChildren, null), this.columnProportions = [], this.columnProportions.length = t, "number" == typeof i) Tv(this.columnProportions, i); else for (var r = 0; r < t; r++)this.columnProportions[r] = i[r] || 0; if (this.rowProportions = [], this.rowProportions.length = e, "number" == typeof n) Tv(this.rowProportions, n); else for (r = 0; r < e; r++)this.rowProportions[r] = n[r] || 0; this.columnWidth = [], this.columnWidth.length = t, this.rowHeight = [], this.rowHeight.length = e, this.space.column = [], this.space.column.length = t - 1; var o = Dv(s, "column", 0); if ("number" == typeof o) Tv(this.space.column, o); else { r = 0; for (var a = this.space.column.length; r < a; r++)this.space.column[r] = o[r] || 0 } this.space.row = [], this.space.row.length = e - 1; var h = Dv(s, "row", 0); if ("number" == typeof h) Tv(this.space.row, h); else for (r = 0, a = this.space.row.length; r < a; r++)this.space.row[r] = h[r] || 0; return this }, inseryEmptyRow: Ov, addEmptyRow: function (t, e) { return Ov.call(this, this.rowCount, t, e), this }, insertEmptyColumn: Mv, addEmptyColumn: function (t, e) { return Mv.call(this, this.columnCount, t, e), this } }; Object.assign(Lv, Rv, Av); var zv = Phaser.Utils.Objects.IsPlainObject, jv = Phaser.Utils.Objects.GetValue, Fv = function () { w(y, Of); var g = T(y); function y(t, e, i, n, s, r, o, a, h, l) { var u; z(this, y), zv(e) ? (e = jv(l = e, "x", 0), i = jv(l, "y", 0), n = jv(l, "width", void 0), s = jv(l, "height", void 0), r = jv(l, "column", l.col || 0), o = jv(l, "row", 0), a = jv(l, "columnProportions", 0), h = jv(l, "rowProportions", 0)) : zv(n) ? (n = jv(l = n, "width", void 0), s = jv(l, "height", void 0), r = jv(l, "column", l.col || 0), o = jv(l, "row", 0), a = jv(l, "columnProportions", 0), h = jv(l, "rowProportions", 0)) : zv(r) ? (r = jv(l = r, "column", l.col || 0), o = jv(l, "row", 0), a = jv(l, "columnProportions", 0), h = jv(l, "rowProportions", 0)) : zv(a) && (a = jv(l = a, "columnProportions", 0), h = jv(l, "rowProportions", 0)), (u = g.call(this, t, e, i, n, s, l)).type = "rexGridSizer", u.resetGrid(r, o, a, h, jv(l, "space", void 0)), u.setIndentLeft(jv(l, "space.indentLeftOdd", 0), jv(l, "space.indentLeftEven", 0)), u.setIndentTop(jv(l, "space.indentTopOdd", 0), jv(l, "space.indentTopEven", 0)), u.addChildrenMap("items", u.sizerChildren); var c = jv(l, "createCellContainerCallback"); if (c) { i = 0; for (var d = u.rowCount; i < d; i++) { e = 0; for (var f = u.columnCount; e < f; e++) { var p = { column: e, row: i }, v = c(t, e, i, p); v && u.add(v, p) } } } return u } return k(y, [{ key: "destroy", value: function (t) { this.scene && (O(C(y.prototype), "destroy", this).call(this, t), this.columnProportions = void 0, this.rowProportions = void 0, this.columnWidth = void 0, this.rowHeight = void 0) } }, { key: "setIndentLeft", value: function (t, e) { return this.space.indentLeftOdd = t, this.space.indentLeftEven = e, this } }, { key: "setIndentTop", value: function (t, e) { return this.space.indentTopOdd = t, this.space.indentTopEven = e, this } }, { key: "setColumnProportion", value: function (t, e) { return t >= this.columnProportions.length || (this.columnProportions[t] = e), this } }, { key: "setRowProportion", value: function (t, e) { return t >= this.rowProportions.length || (this.rowProportions[t] = e), this } }, { key: "totalColumnProportions", get: function () { return void 0 === this._totalColumnProportions && (this._totalColumnProportions = function () { for (var t, e = 0, i = 0; i < this.columnCount; i++)0 < (t = this.columnProportions[i]) && (e += t); return e }.call(this)), this._totalColumnProportions } }, { key: "totalRowProportions", get: function () { return void 0 === this._totalRowProportions && (this._totalRowProportions = function () { for (var t, e = 0, i = 0; i < this.rowCount; i++)0 < (t = this.rowProportions[i]) && (e += t); return e }.call(this)), this._totalRowProportions } }, { key: "getChildAt", value: function (t, e) { return this.sizerChildren[e * this.columnCount + t] } }, { key: "childToGridIndex", value: function (t, e) { if (!t) return null; var i = this.sizerChildren.indexOf(t); return -1 === i ? null : (void 0 === e && (e = {}), e.x = i % this.columnCount, e.y = Math.floor(i / this.columnCount), e) } }, { key: "getColumnWidth", value: function (t) { var e = this.columnProportions[t]; return 0 === e ? this.columnWidth[t] : e * this.proportionWidthLength } }, { key: "getRowHeight", value: function (t) { var e = this.rowProportions[t]; return 0 === e ? this.rowHeight[t] : e * this.proportionHeightLength } }]), y }(); Object.assign(Fv.prototype, Lv), c.register("gridSizer", function (t, e, i, n, s, r, o, a, h) { var l = new Fv(this.scene, t, e, i, n, s, r, o, a, h); return this.scene.add.existing(l), l }), R(window, "RexPlugins.UI.GridSizer", Fv); function Yv(t, e, i, n) { return "\n" === t ? this.addNewLine() : (cu.call(this, t), Uv(e) && (e = Hv(s = e, "padding", 0), i = Hv(s, "key", void 0), n = Hv(s, "index", void 0)), void 0 === e && (e = 0), (s = this.getSizerConfig(t)).align = Nv, s.padding = uu(e), void 0 === n || n >= this.sizerChildren.length ? this.sizerChildren.push(t) : this.sizerChildren.splice(n, 0, t), void 0 !== i && this.addChildrenMap(i, t)), this; var s } var Wv = function (t, e, i, n) { return e / t <= i ? e / (n - 1) : 0 }, Vv = function (t) { var e = t.rexSizer.padding; return jl(t) + e.left + e.right }, Xv = function (t) { var e = t.rexSizer.padding; return Fl(t) + e.top + e.bottom }, Gv = Phaser.Math.Distance.Between, Uv = Phaser.Utils.Objects.IsPlainObject, Hv = Phaser.Utils.Objects.GetValue, Nv = Phaser.Display.Align.CENTER, Jv = { add: function (t, e, i) { if (Ru(t)) for (var n = t, s = 0, r = n.length; s < r; s++)Yv.call(this, n[s], e); else Yv.call(this, t, e, i); return this }, addNewLine: function () { return this.sizerChildren.push("\n"), this }, insert: function (t, e, i, n) { return Yv.call(this, e, i, n, t), this }, insertAtPosition: function (t, e, i, n, s) { var r = function (t, e) { var i = this.sizerChildren; if (0 === i.length) return -1; for (var n = -1, s = 1 / 0, r = 0, o = i.length; r < o; r++) { var a = i[r]; if (!(Math.abs(a.centerY - e) > a.height / 2)) { (h = Gv(a.left, a.centerY, t, e)) < s && (s = h, n = r); var h, l = i[r + 1]; if (!l || l.y !== a.y) (h = Gv(a.right, a.centerY, t, e)) < s && (s = h, n = r + 1) } } return n }.call(this, t, e); return -1 === r && (r = void 0), this.insert(r, i, n, s), this } }, Kv = Phaser.Utils.Array.Remove, qv = { remove: function (t, e) { return this.getParentSizer(t) !== this || (Kv(this.sizerChildren, t), Ef.call(this, t, e)), this }, removeAll: function (t) { for (var e = this.sizerChildren.length - 1; 0 <= e; e--)this.remove(this.sizerChildren[e], t); return this }, clear: function (t) { return this.sizerChildren.length = 0, _f.call(this, t), this } }, $v = { getChildrenWidth: function () { return this.rexSizer.hidden ? 0 : this.maxChildWidth + this.space.left + this.space.right }, getChildrenHeight: function () { return this.rexSizer.hidden ? 0 : this.widthWrapResult.height + this.space.top + this.space.bottom }, getChildrenSizers: function (t) { void 0 === t && (t = []); for (var e, i = this.sizerChildren, n = 0, s = i.length; n < s; n++)"\n" !== (e = i[n]) && e.isRexSizer && t.push(e); return t }, preLayout: function () { return this._maxChildWidth = void 0, this._maxChildHeight = void 0, vu.call(this), this }, layoutChildren: function () { for (var t, e, i, n, s, r, o, a, h, l, u, c = this.innerWidth, d = this.justifyPercentage, f = this.space.item, p = this.space.line, v = this.space.indentLeftOdd, g = this.space.indentLeftEven, y = this.space.indentTopOdd, m = this.space.indentTopEven, k = 0, b = this.innerLeft, x = this.innerTop, C = this.widthWrapResult.lines, w = x, S = 0, P = C.length; S < P; S++) { switch (h = (a = C[S]).children, this.rtl && h.reverse(), u = b + (S % 2 ? g : v), l = c - a.width, this.align) { case 0: break; case 1: u += l; break; case 2: u += l / 2; break; case 3: k = Wv(c, l, d, h.length); break; case 4: 0 === (k = Wv(c, l, d, h.length)) && (u += l); break; case 5: 0 === (k = Wv(c, l, d, h.length)) && (u += l / 2) }for (var T = 0, O = h.length; T < O; T++)(t = h[T]).rexSizer.hidden || (i = (e = t.rexSizer).padding, zu.call(this, t), n = u + i.left, 0 < T && (n += f), s = w + (T % 2 ? m : y) + i.top, r = jl(t), o = Fl(t), u = n + r + i.right + k, ju.call(this, t, n, s, r, o, e.align)); w += a.height + p } }, runWidthWrap: function (t) { var e = t - this.space.left - this.space.right; this.widthWrapResult = function (t, e) { void 0 === e ? e = { lines: [], width: 0, height: 0 } : (e.lines.length = 0, e.width = 0, e.height = 0); for (var i, n, s, r, o = this.sizerChildren, a = this.space.item, h = this.space.line, l = this.space.indentLeftOdd, u = this.space.indentLeftEven, c = this.space.indentTopOdd, d = this.space.indentTopEven, f = 0, p = e.lines, v = void 0, g = 0, y = o.length; g < y; g++) { if ("\n" === (i = o[g])) i = void 0, r = !(n = 0); else { if (i.rexSizer.hidden) continue; i.isRexSizer && i.layout(), r = f < (n = Vv(i)) || void 0 === v } if (r) v && (v.width = t - (f + a), e.width = Math.max(e.width, v.width), e.height += v.height + h), v = { children: [], height: 0 }, p.push(v), f = t - (p.length % 2 ? l : u); f -= n + a, i && (v.children.push(i), s = Xv(i), v.height = Math.max(v.height, s)) } return v && (v.width = t - (f + a), e.width = Math.max(e.width, v.width), e.height += v.height), e.height += Math.max(c, d), e }.call(this, e, this.widthWrapResult), gu.call(this, t) } }; Object.assign($v, Jv, qv); var Zv = Phaser.Utils.Objects.IsPlainObject, Qv = Phaser.Utils.Objects.GetValue, tg = function () { w(h, Of); var a = T(h); function h(t, e, i, n, s, r) { var o; return z(this, h), Zv(e) ? (e = Qv(r = e, "x", 0), i = Qv(r, "y", 0), n = Qv(r, "width", void 0), s = Qv(r, "height", void 0)) : Zv(n) && (n = Qv(r = n, "width", void 0), s = Qv(r, "height", void 0)), (o = a.call(this, t, e, i, n, s, r)).type = "rexFixWidthSizer", o.sizerChildren = [], o.setOrientation(Qv(r, "orientation", 0)), o.setItemSpacing(Qv(r, "space.item", 0)), o.setLineSpacing(Qv(r, "space.line", 0)), o.setIntentLeft(Qv(r, "space.indentLeftOdd", 0), Qv(r, "space.indentLeftEven", 0)), o.setIntentTop(Qv(r, "space.indentTopOdd", 0), Qv(r, "space.indentTopEven", 0)), o.setAlign(Qv(r, "align", 0)), o.setJustifyPercentage(Qv(r, "justifyPercentage", .25)), o.setRTL(Qv(r, "rtl", !1)), o.addChildrenMap("items", o.sizerChildren), o } return k(h, [{ key: "setOrientation", value: function (t) { return this.orientation = kv(t), this } }, { key: "setItemSpacing", value: function (t) { return this.space.item = t, this } }, { key: "setLineSpacing", value: function (t) { return this.space.line = t, this } }, { key: "setIntentLeft", value: function (t, e) { return this.space.indentLeftOdd = t, this.space.indentLeftEven = e, this } }, { key: "setIntentTop", value: function (t, e) { return this.space.indentTopOdd = t, this.space.indentTopEven = e, this } }, { key: "setAlign", value: function (t) { return "string" == typeof t && (t = eg[t]), this.align = t, this } }, { key: "setJustifyPercentage", value: function (t) { return this.justifyPercentage = t, this } }, { key: "setRTL", value: function (t) { return void 0 === t && (t = !0), this.rtl = t, this } }, { key: "maxChildWidth", get: function () { return void 0 === this._maxChildWidth && (this._maxChildWidth = function (t) { void 0 === t && (t = this.sizerChildren); for (var e, i, n = 0, s = 0, r = t.length; s < r; s++)"\n" !== (e = t[s]) && (i = this.getChildWidth(e), n = Math.max(i, n)); return n }.call(this)), this._maxChildWidth } }, { key: "maxChildHeight", get: function () { return void 0 === this._maxChildHeight && (this._maxChildHeight = function (t) { void 0 === t && (t = this.sizerChildren); for (var e, i, n = 0, s = 0, r = t.length; s < r; s++)"\n" !== (e = t[s]) && (i = e.isRexSizer ? Math.max(e.minHeight, e.childrenHeight) : e.hasOwnProperty("minHeight") ? e.minHeight : Fl(e), n = Math.max(i, n)); return n }.call(this)), this._maxChildHeight } }]), h }(), eg = { left: 0, top: 0, right: 1, bottom: 1, center: 2, justify: 3, "justify-left": 3, "justify-top": 3, "justify-right": 4, "justify-bottom": 4, "justify-center": 5 }; Object.assign(tg.prototype, $v), c.register("fixWidthSizer", function (t, e, i, n, s) { var r = new tg(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r }), R(window, "RexPlugins.UI.FixWidthSizer", tg), c.register("overlapSizer", function (t, e, i, n, s) { var r = new Gf(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r }), R(window, "RexPlugins.UI.OverlapSizer", Gf), c.register("space", function () { return new uv(this.scene) }), R(window, "RexPlugins.UI.Space", uv); function ig(t, e, i, n) { var s = new Dp(e, i, n); if (t && !t.isRexSizer) { var r = s.createGeometryMask(); t.setMask(r), this.once("destroy", function () { t.setMask(), r.destroy() }) } return this.pin(s), s } var ng = Phaser.Utils.Objects.GetValue, sg = function () { w(m, wv); var y = T(m); function m(t, e) { var i; z(this, m), (i = y.call(this, t, e)).type = "rexLabel"; var n = ng(e, "background", void 0), s = ng(e, "icon", void 0), r = ng(e, "iconMask", void 0), o = ng(e, "text", void 0), a = ng(e, "action", void 0), h = ng(e, "actionMask", void 0), l = ng(e, "align", void 0), u = ng(e, "space.icon", 0), c = ng(e, "space.text", 0); n && i.addBackground(n), "right" !== l && "bottom" !== l && "center" !== l || i.addSpace(), s && (0 === i.orientation ? (o || a) && (f = { right: u }) : (o || a) && (f = { bottom: u }), i.add(s, 0, "center", f), r = r && ig.call(j(i), s, s, 1)); if (o) { var d, f, p, v = ng(e, "expandTextWidth", !1), g = ng(e, "expandTextHeight", !1); p = 0 === i.orientation ? (d = v ? 1 : 0, a && (f = { right: c }), g) : (d = g ? 1 : 0, a && (f = { bottom: c }), v), i.add(o, d, "center", f, p) } return a && (i.add(a), h = h && ig.call(j(i), a, a, 1)), "center" === l && i.addSpace(), i.addChildrenMap("background", n), i.addChildrenMap("icon", s), i.addChildrenMap("iconMask", r), i.addChildrenMap("text", o), i.addChildrenMap("action", a), i.addChildrenMap("actionMask", h), i } return k(m, [{ key: "text", get: function () { var t = this.childrenMap.text; return void 0 === t ? "" : t.text }, set: function (t) { var e = this.childrenMap.text; void 0 !== e && e.setText(t) } }, { key: "setText", value: function (t) { return this.text = t, this } }, { key: "appendText", value: function (t) { return this.text += t, this } }, { key: "setTexture", value: function (t, e) { var i = this.childrenMap.icon; if (void 0 !== i) return i.setTexture(t, e), this } }, { key: "texture", get: function () { var t = this.childrenMap.icon; if (void 0 !== t) return t.texture } }, { key: "frame", get: function () { var t = this.childrenMap.icon; if (void 0 !== t) return t.frame } }, { key: "runLayout", value: function (t, e, i) { if (this.ignoreLayout) return this; O(C(m.prototype), "runLayout", this).call(this, t, e, i); var n = this.childrenMap.iconMask; n && (n.setPosition(), this.resetChildPositionState(n)); var s = this.childrenMap.actionMask; return s && (s.setPosition(), this.resetChildPositionState(s)), this } }, { key: "resize", value: function (t, e) { O(C(m.prototype), "resize", this).call(this, t, e); var i = this.childrenMap.iconMask; i && i.resize(); var n = this.childrenMap.actionMask; return n && n.resize(), this } }]), m }(); c.register("label", function (t) { var e = new sg(this.scene, t); return this.scene.add.existing(e), e }), R(window, "RexPlugins.UI.Label", sg); function rg(t) { var e = !t.isRexSpace, i = !e || this.buttonsExpand ? 1 : 0; if (0 === this.sizerChildren.length) if (e) { !this.buttonsExpand && ("right" === this.buttonsAlign || "center" === this.buttonsAlign || "bottom" === this.buttonsAlign) && lg.call(this), hg.call(this, t, { proportion: i, expand: !0 }); var n = !this.buttonsExpand && "center" === this.buttonsAlign; n && lg.call(this), this.hasTailSpace = n } else hg.call(this, t, { proportion: i, expand: !0 }), this.hasTailSpace = !1; else if (this.hasTailSpace) { var s = this.sizerChildren.length - 1; hg.call(this, t, { index: s, proportion: i, expand: !0 }) } else hg.call(this, t, { proportion: i, expand: !0 }); return e && this.buttonGroup.add(t), this } function og(t, e) { return this.getParentSizer(t) !== this || (this.buttonGroup.remove(t), cg.call(this, t, e)), this } function ag(t) { var e, i, n = yg(t, "dataManager", void 0); if (void 0 === n) { var s = this.parent; s.setDataEnabled(), n = s.data } this.dataManager = n, e = yg(t, "setValueCallback", void 0), i = yg(t, "setValueCallbackScope", void 0), void 0 === e && (e = yg(t, "setButtonStateCallback", void 0), i = yg(t, "setButtonStateCallbackScope", void 0)), this.setValueCallback = e, this.setValueCallbackScope = i, n.events.on("changedata", function (t, e, i, n) { var s = this.buttonMap[e]; if (s) { var r = this.setValueCallback, o = this.setValueCallbackScope; r && (o ? r.call(o, s, i, n) : r(s, i, n)), this.fireEvent("button.statechange", s, i, n) } }, this) } var hg = wv.prototype.add, lg = wv.prototype.addSpace, ug = { addButton: function (t) { if (Ru(t)) for (var e = t, i = 0, n = e.length; i < n; i++)rg.call(this, e[i]); else rg.call(this, t); return this }, addButtons: function (t) { for (var e = 0, i = t.length; e < i; e++)rg.call(this, t[e]); return this } }, cg = wv.prototype.remove, dg = wv.prototype.clear, fg = { remove: function (t, e) { if (Ru(t)) for (var i = t, n = 0, s = i.length; n < s; n++)og.call(this, i[n], e); else og.call(this, t, e); return this }, clear: function (t) { return this.buttonGroup.buttons.length = 0, dg.call(this, t), this }, removeButton: function (t, e) { return (t = this.getButton(t)) && this.remove(t, e), this }, clearButtons: function (t) { for (var e = this.buttonGroup.buttons, i = e.length - 1; 0 <= i; i--)og.call(this, e[i], t); return this } }, pg = { add: function (s) { if (this.buttons.push(s), this.buttonsType) { var t = s.name; "" === t ? console.error("".concat(this.parent.constructor.name, ": Button key is an empty string")) : this.buttonMap.hasOwnProperty(t) && console.error("".concat(this.parent.constructor.name, ": Duplicate button key '").concat(t, "'")), this.buttonMap[t] = s, this.dataManager.set(t, void 0).set(t, !1) } return s._buttonBehavior = new Uc(s, this.clickConfig), s._buttonBehavior.on("click", function (t, e, i, n) { this.fireEvent("button.click", e, i, n) }, this).on("enable", function (t, e) { this.fireEvent("button.enable", e) }, this).on("disable", function (t, e) { this.fireEvent("button.disable", e) }, this), s.on("pointerover", function (t, e, i, n) { this.fireEvent("button.over", s, t, n) }, this).on("pointerout", function (t, e) { this.fireEvent("button.out", s, t, e) }, this), this }, addMultiple: function (t) { for (var e = 0, i = t.length; e < i; e++)this.add(gameObject[e]); return this } }, vg = Phaser.Utils.Array.Remove, gg = { remove: function (t) { if (vg(this.buttons, t), this.buttonsType) { var e = t.name; delete this.buttonMap[e], this.dataManager.remove(e) } return this }, clear: function () { if (this.buttons.length = 0, this.buttonsType) for (var t in this.buttonMap) delete this.buttonMap[t], this.dataManager.remove(t); return this } }, yg = Phaser.Utils.Objects.GetValue, mg = { setButtonsType: function (t) { void 0 === t && (t = {}); var e = yg(t, "buttonsType", t.type); switch (this.buttonsType = e) { case "radio": this.setRadioType(t); break; case "checkboxes": this.setCheckboxesType(t) }return this }, setRadioType: function (t) { ag.call(this, t); var e = void 0, i = this.parent, s = this.buttons, r = this.dataManager; return Object.defineProperty(i, "value", { get: function () { return e }, set: function (n) { n !== e && (e = n, s.forEach(function (t) { var e = t.name, i = r.get(e); e === n ? i || r.set(e, !0) : i && r.set(e, !1) })) }, enumerable: !0, configurable: !0 }), i.on("button.click", function (t) { i.value = t.name }), this }, setCheckboxesType: function (t) { ag.call(this, t); var e = this.parent, i = this.dataManager; return e.on("button.click", function (t) { i.toggle(t.name) }), this }, clearAllButtonsState: function () { for (var t in this.buttonMap) this.dataManager.set(t, !1); return this }, getAllButtonsState: function () { var t = {}; for (var e in this.buttonMap) t[e] = this.dataManager.get(e); return t }, setSelectedButtonName: function (t) { return this.parent.value = t, this }, getSelectedButtonName: function () { return this.parent.value }, setButtonState: function (t, e) { return void 0 === e && (e = !0), this.dataManager.set(t, e), this }, getButtonState: function (t) { return this.dataManager.get(t) } }, kg = function (t, e) { return t ? t.hasOwnProperty("name") ? t.name === e ? t : null : GetElementByName(t, e) : null }, bg = { getButton: function (t) { var e, i = this.buttons; switch (P(t)) { case "number": e = i[t]; break; case "string": e = function (t, e) { if (!t) return null; if (Ru(t)) { for (var i, n = 0, s = t.length; n < s; n++)if (i = kg(t[n], e)) return i } else for (var r in t) if (i = kg(t[r], e)) return i }(i, t); break; default: e = t, -1 === i.indexOf(e) && (e = void 0) }return e }, setButtonEnable: function (t, e) { var i = this.buttons; if (void 0 === t || "boolean" == typeof t) { e = t; for (var n = 0, s = i.length; n < s; n++)i[n]._buttonBehavior.setEnable(e) } else this.getButton(t)._buttonBehavior.setEnable(e); return this }, toggleButtonEnable: function (t) { var e = this.buttons; if (void 0 === t || "boolean" == typeof t) for (var i = 0, n = e.length; i < n; i++)e[i]._buttonBehavior.toggleEnable(); else this.getButton(t)._buttonBehavior.toggleEnable(); return this }, getButtonEnable: function (t) { return void 0 === t && (t = 0), this.getButton(t)._buttonBehavior.enable }, emitButtonClick: function (t) { return (this.buttonGroup ? this.buttonGroup : this).fireEvent("button.click", t), this }, showButton: function (t) { return Ou(this.getButton(t)), this }, hideButton: function (t) { return Mu(this.getButton(t)), this }, isButtonShown: function (t) { return Eu(this.getButton(t)), this }, forEachButtton: function (t, e) { for (var i = this.buttons, n = 0, s = i.length; n < s; n++)e ? t.call(e, i[n], n, i) : t(i[n], n, i); return this } }, xg = function () { function e(t) { z(this, e), this.parent = t.parent, this.eventEmitter = t.eventEmitter, this.groupName = t.groupName, this.clickConfig = t.clickConfig, this.buttonsType = void 0, this.buttons = [], this.buttonMap = {} } return k(e, [{ key: "destroy", value: function () { this.parent = void 0, this.eventEmitter = void 0, this.clickConfig = void 0, this.buttons = void 0 } }]), e }(), Cg = { fireEvent: function (t, e) { var i, n, s, r; if ("number" == typeof e) { if (i = e, !(e = this.buttons[i])) return } else if (-1 === (i = this.buttons.indexOf(e))) return; for (var o = arguments.length, a = new Array(2 < o ? o - 2 : 0), h = 2; h < o; h++)a[h - 2] = arguments[h]; this.eventEmitter !== this.parent && (n = this.parent).emit.apply(n, [t, e, i].concat(a)); void 0 !== this.groupName ? (s = this.eventEmitter).emit.apply(s, [t, e, this.groupName, i].concat(a)) : (r = this.eventEmitter).emit.apply(r, [t, e, i].concat(a)) } }; Object.assign(xg.prototype, pg, gg, mg, bg, Cg); var wg = { clearAllButtonsState: function () { return this.buttonGroup.clearAllButtonsState(), this }, getAllButtonsState: function () { return this.buttonGroup.getAllButtonsState() }, setSelectedButtonName: function (t) { return this.buttonGroup.setSelectedButtonName(t), this }, getSelectedButtonName: function () { return this.buttonGroup.getSelectedButtonName() }, setButtonState: function (t, e) { return this.buttonGroup.setButtonState(t, e), this }, getButtonState: function (t) { return this.buttonGroup.getButtonState(t) } }, Sg = Phaser.Utils.Objects.GetValue, Pg = function () { w(a, wv); var o = T(a); function a(t, e) { var i; z(this, a), void 0 === e && (e = {}); var n = e.space; "number" == typeof n && (e.space = { item: n }), (i = o.call(this, t, e)).type = "rexButtons", i.buttonGroup = new xg({ parent: j(i), eventEmitter: Sg(e, "eventEmitter", j(i)), groupName: Sg(e, "groupName", void 0), clickConfig: Sg(e, "click", void 0) }).setButtonsType(e); var s = Sg(e, "background", void 0), r = Sg(e, "buttons", void 0); return i.buttonsExpand = Sg(e, "expand", !1), i.buttonsAlign = Sg(e, "align", void 0), s && i.addBackground(s), r && i.addButtons(r), i.addChildrenMap("background", s), i.addChildrenMap("buttons", i.buttonGroup.buttons), i } return k(a, [{ key: "destroy", value: function (t) { this.scene && (O(C(a.prototype), "destroy", this).call(this, t), this.buttonGroup.destroy(), this.buttonGroup = void 0) } }, { key: "buttons", get: function () { return this.buttonGroup.buttons } }, { key: "groupName", get: function () { return this.buttonGroup.groupName }, set: function (t) { this.buttonGroup.groupName = t } }, { key: "eventEmitter", get: function () { return this.buttonGroup.eventEmitter } }]), a }(); Object.assign(Pg.prototype, ug, fg, bg, wg), c.register("buttons", function (t) { var e = new Pg(this.scene, t); return this.scene.add.existing(e), e }), R(window, "RexPlugins.UI.Buttons", Pg); function Tg(t, e) { return (t = this.getButton(t)) && (this.buttonGroup.remove(t), Eg.call(this, t, e)), this } var Og = Fv.prototype.add, Mg = { addButton: function (t, e, i) { return Og.call(this, t, e, i, void 0, 0, this.buttonsExpand), this.buttonGroup.add(t), this }, addButtons: function (t, e) { for (var i = 0, n = t; i < n; i++)this.addButton(t[i], void 0, e); return this } }, Eg = Fv.prototype.remove, _g = Fv.prototype.clear, Bg = { remove: function (t, e) { if (Ru(t)) for (var i = t, n = 0, s = i.length; n < s; n++)Tg.call(this, i[n], e); else Tg.call(this, t, e); return this }, clear: function (t) { return this.buttonGroup.buttons.length = 0, _g.call(this, t), this }, removeButton: function (t, e) { return this.remove(t, e), this }, clearButtons: function (t) { for (var e = this.buttonGroup.buttons, i = e.length - 1; 0 <= i; i--)Tg.call(this, e[i], t); return this } }, Ig = Phaser.Utils.Objects.GetValue, Rg = function () { w(x, Fv); var b = T(x); function x(t, e) { var i; z(this, x), void 0 === e && (e = {}); var n = Ig(e, "row", 0), s = Ig(e, "column", e.col || 0), r = Ig(e, "createCellContainerCallback"), o = Ig(e, "buttons", void 0), a = Ig(e, "expand", !0), h = a ? 1 : 0; if (r && (e.createCellContainerCallback = void 0), void 0 !== o) { n = Math.max(n, o.length); for (var l = 0, u = o.length; l < u; l++)s = Math.max(s, o[l].length) } e.row = n, e.column = s, e.columnProportions = h, e.rowProportions = h, (i = b.call(this, t, e)).type = "rexGridButtons", i.buttonGroup = new xg({ parent: j(i), eventEmitter: Ig(e, "eventEmitter", j(i)), groupName: Ig(e, "groupName", void 0), clickConfig: Ig(e, "click", void 0) }).setButtonsType(e); var c = Ig(e, "background", void 0); if (i.buttonsExpand = a, Ig(e, "space", void 0), c && i.addBackground(c), o) for (var d, f = 0, p = o.length; f < p; f++)for (var v = 0, g = (d = o[f]).length; v < g; v++)(k = d[v]) && i.addButton(k, v, f); else if (r) for (var y = 0; y < n; y++)for (var m = 0; m < s; m++) { var k; (k = r(t, m, y)) && i.addButton(k, m, y) } return i.addChildrenMap("background", c), i.addChildrenMap("buttons", i.buttonGroup.buttons), i } return k(x, [{ key: "destroy", value: function (t) { this.scene && (O(C(x.prototype), "destroy", this).call(this, t), this.buttonGroup.destroy(), this.buttonGroup = void 0) } }, { key: "buttons", get: function () { return this.buttonGroup.buttons } }, { key: "groupName", get: function () { return this.buttonGroup.groupName }, set: function (t) { this.buttonGroup.groupName = t } }, { key: "eventEmitter", get: function () { return this.buttonGroup.eventEmitter } }]), x }(); Object.assign(Rg.prototype, Mg, Bg, bg, wg), c.register("gridButtons", function (t) { var e = new Rg(this.scene, t); return this.scene.add.existing(e), e }), R(window, "RexPlugins.UI.GridButtons", Rg); function Ag(t) { return Lg.call(this, t), this.buttonGroup.add(t), this } function Dg(t, e) { return (t = this.getButton(t)) && (this.buttonGroup.remove(t), jg.call(this, t, e)), this } var Lg = tg.prototype.add, zg = { addButton: function (t) { if (Ru(t)) for (var e = t, i = 0, n = e.length; i < n; i++)Ag.call(this, e[i]); else Ag.call(this, t); return this }, addButtons: function (t) { if (Ru(t[0])) for (var e, i = t, n = 0, s = i.length - 1; n <= s; n++) { for (var r = 0, o = (e = i[n]).length; r < o; r++)Ag.call(this, e[r]); s < n && Lg.addNewLine(this) } else for (r = 0, o = t.length; r < o; r++)Ag.call(this, t[r]); return this } }, jg = tg.prototype.remove, Fg = tg.prototype.clear, Yg = { remove: function (t, e) { if (Ru(t)) for (var i = t, n = 0, s = i.length; n < s; n++)Dg.call(this, i[n], e); else Dg.call(this, t, e); return this }, clear: function (t) { return this.buttonGroup.buttons.length = 0, Fg.call(this, t), this }, removeButton: function (t, e) { return this.remove(t, e), this }, clearButtons: function (t) { for (var e = this.buttonGroup.buttons, i = e.length - 1; 0 <= i; i--)Dg.call(this, e[i], t); return this } }, Wg = Phaser.Utils.Objects.GetValue, Vg = function () { w(a, tg); var o = T(a); function a(t, e) { var i; z(this, a), void 0 === e && (e = {}); var n = e.space; "number" == typeof n && (e.space = { item: n, line: n }), (i = o.call(this, t, e)).type = "rexFixWidthButtons", i.buttonGroup = new xg({ parent: j(i), eventEmitter: Wg(e, "eventEmitter", j(i)), groupName: Wg(e, "groupName", void 0), clickConfig: Wg(e, "click", void 0) }).setButtonsType(e); var s = Wg(e, "background", void 0), r = Wg(e, "buttons", void 0); return i.buttonsAlign = Wg(e, "align", void 0), s && i.addBackground(s), r && i.addButtons(r), i.addChildrenMap("background", s), i.addChildrenMap("buttons", i.buttonGroup.buttons), i } return k(a, [{ key: "destroy", value: function (t) { this.scene && (O(C(a.prototype), "destroy", this).call(this, t), this.buttonGroup.destroy(), this.buttonGroup = void 0) } }, { key: "buttons", get: function () { return this.buttonGroup.buttons } }, { key: "groupName", get: function () { return this.buttonGroup.groupName }, set: function (t) { this.buttonGroup.groupName = t } }, { key: "eventEmitter", get: function () { return this.buttonGroup.eventEmitter } }]), a }(); Object.assign(Vg.prototype, zg, Yg, bg, wg), c.register("fixWidthButtons", function (t) { var e = new Vg(this.scene, t); return this.scene.add.existing(e), e }), R(window, "RexPlugins.UI.FixWidthButtons", Vg); var Xg = { getChoice: function (t) { var e = this.childrenMap.choicesSizer; return e ? e.getButton(t) : void 0 }, getAction: function (t) { return this.childrenMap.actionsSizer.getButton(t) }, getToolbar: function (t) { return this.childrenMap.toolbarSizer.getButton(t) }, getLeftToolbar: function (t) { return this.childrenMap.leftToolbarSizer.getButton(t) }, setChoiceEnable: function (t, e) { var i = this.childrenMap.choicesSizer; return i && i.setButtonEnable(t, e), this }, setActionEnable: function (t, e) { return this.childrenMap.actionsSizer.setButtonEnable(t, e), this }, setToolbarEnable: function (t, e) { return this.childrenMap.toolbarSizer.setButtonEnable(t, e), this }, setLeftToolbarEnable: function (t, e) { return this.childrenMap.leftToolbarSizer.setButtonEnable(t, e), this }, toggleChoiceEnable: function (t) { var e = this.childrenMap.choicesSizer; return e && e.toggleButtonEnable(t), this }, toggleActionEnable: function (t) { return this.childrenMap.actionsSizer.toggleButtonEnable(t), this }, toggleToolbarEnable: function (t) { return this.childrenMap.toolbarSizer.toggleButtonEnable(t), this }, toggleLeftToolbarEnable: function (t) { return this.childrenMap.leftToolbarSizer.toggleButtonEnable(t), this }, getChoiceEnable: function (t) { var e = this.childrenMap.choicesSizer; return !!e && e.getButtonEnable(t) }, getActionEnable: function (t) { return this.childrenMap.actionsSizer.getButtonEnable(t) }, getToolbarEnable: function (t) { return this.childrenMap.toolbarSizer.getButtonEnable(t) }, getLeftToolbarEnable: function (t) { return this.childrenMap.leftToolbarSizer.getButtonEnable(t) }, emitChoiceClick: function (t) { var e = this.childrenMap.choicesSizer; return e && e.emitButtonClick(t), this }, emitActionClick: function (t) { return this.childrenMap.actionsSizer.emitButtonClick(t), this }, emitToolbarClick: function (t) { return this.childrenMap.toolbarSizer.emitButtonClick(t), this }, emitLeftToolbarClick: function (t) { return this.childrenMap.leftToolbarSizer.emitButtonClick(t), this }, showChoice: function (t) { var e = this.childrenMap.choicesSizer; return e && e.showButton(t), this }, showAction: function (t) { return this.childrenMap.actionsSizer.showButton(t), this }, showToolbar: function (t) { return this.childrenMap.toolbarSizer.showButton(t), this }, showLeftToolbar: function (t) { return this.childrenMap.leftToolbarSizer.showButton(t), this }, hideChoice: function (t) { var e = this.childrenMap.choicesSizer; return e && e.hideButton(t), this }, hideAction: function (t) { return this.childrenMap.actionsSizer.hideButton(t), this }, hideToolbar: function (t) { return this.childrenMap.toolbarSizer.hideButton(t), this }, hideLeftToolbar: function (t) { return this.childrenMap.leftToolbarSizer.hideButton(t), this }, addChoice: function (t) { var e = this.childrenMap.choicesSizer; return e && e.addButton(t), this }, addAction: function (t) { return this.childrenMap.actionsSizer.addButton(t), this }, addToolbar: function (t) { return this.childrenMap.toolbarSizer.addButton(t), this }, addLeftToolbar: function (t) { return this.childrenMap.leftToolbarSizer.addButton(t), this }, removeChoice: function (t, e) { var i = this.childrenMap.choicesSizer; return i && i.removeButton(t, e), this }, removeAction: function (t, e) { return this.childrenMap.actionsSizer.removeButton(t, e), this }, removeToolbar: function (t, e) { return this.childrenMap.toolbarSizer.removeButton(t, e), this }, removeLeftToolbar: function (t, e) { return this.childrenMap.leftToolbarSizer.removeButton(t, e), this }, clearChoices: function (t) { var e = this.childrenMap.choicesSizer; return e && e.clearButtons(t), this }, clearActions: function (t) { return this.childrenMap.actionsSizer.clearButtons(t), this }, clearToolbar: function (t) { return this.childrenMap.toolbarSizer.clearButtons(t), this }, clearLeftToolbar: function (t) { return this.childrenMap.leftToolbarSizer.clearButtons(t), this }, forEachChoice: function (t, e) { var i = this.childrenMap.choicesSizer; return i && i.forEachButtton(t, e), this }, forEachAction: function (t, e) { return this.childrenMap.actionsSizer.forEachButtton(t, e), this }, forEachToolbar: function (t, e) { return this.childrenMap.toolbarSizer.forEachButtton(t, e), this }, forEachLeftToolbar: function (t, e) { return this.childrenMap.leftToolbarSizer.forEachButtton(t, e), this }, setAllButtonsEnable: function (t) { return void 0 === t && (t = !0), this.childrenMap.toolbarSizer && this.setToolbarEnable(t), this.childrenMap.leftToolbarSizer && this.setLeftToolbarEnable(t), this.childrenMap.actionsSizer && this.setActionEnable(t), this.childrenMap.choicesSizer && this.setChoiceEnable(t), this }, getChoicesButtonStates: function () { var t = this.childrenMap.choicesSizer; return t ? t.getAllButtonsState() : {} }, getChoicesButtonState: function (t) { var e = this.childrenMap.choicesSizer; return void 0 === t ? e ? e.getAllButtonsState() : {} : !!e && e.getButtonState(t) }, setChoicesButtonState: function (t, e) { var i = this.childrenMap.choicesSizer; return i && i.setButtonState(t, e), this }, clearChoicesButtonStates: function () { var t = this.childrenMap.choicesSizer; return t && t.clearAllButtonsState(), this }, getChoicesSelectedButtonName: function () { var t = this.childrenMap.choicesSizer; return t ? t.getSelectedButtonName() : "" }, setChoicesSelectedButtonName: function (t) { var e = this.childrenMap.choicesSizer; return e && e.setSelectedButtonName(t), this } }, Gg = Phaser.Utils.Objects.GetValue, Ug = function () { w(L, wv); var D = T(L); function L(t, e) { var i; z(this, L), void 0 === e && (e = {}), e.orientation = 1, (i = D.call(this, t, e)).type = "rexDialog", i.eventEmitter = Gg(e, "eventEmitter", j(i)); var n, s, r, o, a = Gg(e, "background", void 0), h = Gg(e, "title", void 0), l = Gg(e, "toolbar", void 0), u = Gg(e, "toolbarBackground", void 0), c = Gg(e, "leftToolbar", void 0), d = Gg(e, "leftToolbarBackground", void 0), f = Gg(e, "content", void 0), p = Gg(e, "description", void 0), v = Gg(e, "choices", void 0), g = Gg(e, "choicesBackground", void 0), y = Gg(e, "actions", void 0), m = Gg(e, "actionsBackground", void 0), k = Gg(e, "click", void 0); if (a && i.addBackground(a), l && (r = new Pg(t, { groupName: "toolbar", background: u, buttons: l, orientation: 0, space: { item: Gg(e, "space.toolbarItem", 0) }, click: k, eventEmitter: i.eventEmitter })), c && (o = new Pg(t, { groupName: "leftToolbar", background: d, buttons: c, orientation: 0, space: { item: Gg(e, "space.leftToolbarItem", 0) }, click: k, eventEmitter: i.eventEmitter })), h && !l && !c) { var b = Gg(e, "align.title", "center"), x = Gg(e, "space.title", 0); (f || p || v || y) && (S = { bottom: x }); var C = Gg(e, "expand.title", !0); i.add(h, { align: b, padding: S, expand: C }) } if (l && !h && !c) { x = Gg(e, "space.title", 0); (f || p || v || y) && (S = { bottom: x }); C = Gg(e, "expand.toolbar", !0); i.add(r, { align: "right", padding: S, expand: C }) } if (c && !h && !l) { x = Gg(e, "space.title", 0); (f || p || v || y) && (S = { bottom: x }); C = Gg(e, "expand.leftToolbar", !0); i.add(o, { align: "left", padding: S, expand: C }) } if (h && (l || c)) { var w = new wv(t, { orientation: 0 }); o && w.add(o, { align: "right", expand: !1 }); b = Gg(e, "align.title", "left"); (C = Gg(e, "expand.title", !0)) || "right" !== b && "center" !== b || w.addSpace(); var S = { left: Gg(e, "space.titleLeft", 0), right: Gg(e, "space.titleRight", 0) }, P = C ? 1 : 0; w.add(h, { proportion: P, align: "center", padding: S, expand: C }), C || "left" !== b && "center" !== b || w.addSpace(), r && w.add(r, { align: "right", expand: !1 }); x = Gg(e, "space.title", 0); (f || p || v || y) && (S = { bottom: x }), i.add(w, { align: "center", padding: S, expand: !0 }) } if (f) { b = Gg(e, "align.content", "center"); var T = Gg(e, "space.content", 0); S = { left: Gg(e, "space.contentLeft", 0), right: Gg(e, "space.contentRight", 0), bottom: p || v || y ? T : 0 }, C = Gg(e, "expand.content", !0); i.add(f, { align: b, padding: S, expand: C }) } if (p) { b = Gg(e, "align.description", "center"); var O = Gg(e, "space.description", 0); S = { left: Gg(e, "space.descriptionLeft", 0), right: Gg(e, "space.descriptionRight", 0), bottom: v || y ? O : 0 }, C = Gg(e, "expand.description", !0); i.add(p, { align: b, padding: S, expand: C }) } if (v) { var M = Gg(e, "choicesType", "").split("-"), E = Hg(M, "wrap") ? Vg : Hg(M, "grid") ? Rg : Pg, _ = Hg(M, "radio") ? "radio" : Hg(M, "checkboxes") ? "checkboxes" : void 0, B = { left: Gg(e, "space.choicesBackgroundLeft", 0), right: Gg(e, "space.choicesBackgroundRight", 0), top: Gg(e, "space.choicesBackgroundTop", 0), bottom: Gg(e, "space.choicesBackgroundBottom", 0) }, I = Gg(e, "space.choice", 0); E === Pg ? B.item = I : E === Vg ? (B.item = I, B.line = Gg(e, "space.choiceLine", I)) : (B.column = Gg(e, "space.choiceColumn", I), B.row = Gg(e, "space.choiceRow", I)); var R = { width: Gg(e, "choicesWidth", void 0), height: Gg(e, "choicesHeight", void 0), groupName: "choices", buttonsType: _, background: g, buttons: v, space: B, click: k, eventEmitter: i.eventEmitter, setValueCallback: Gg(e, "choicesSetValueCallback", void 0), setValueCallbackScope: Gg(e, "choicesSetValueCallbackScope", void 0) }; E === Pg && (R.orientation = Hg(M, "x") ? 0 : 1), n = new E(t, R); var A = Gg(e, "space.choices", 0); S = { left: Gg(e, "space.choicesLeft", 0), right: Gg(e, "space.choicesRight", 0), bottom: y ? A : 0 }, b = Gg(e, "align.choices", "center"), C = Gg(e, "expand.choices", !0); i.add(n, { align: b, padding: S, expand: C }) } if (y) { s = new Pg(t, { groupName: "actions", background: m, buttons: y, orientation: 0, space: { item: Gg(e, "space.action", 0) }, expand: Gg(e, "expand.actions", !1), align: Gg(e, "align.actions", "center"), click: k, eventEmitter: i.eventEmitter }); S = { left: Gg(e, "space.actionsLeft", 0), right: Gg(e, "space.actionsRight", 0) }; i.add(s, { align: "center", padding: S, expand: !0 }) } return i.addChildrenMap("background", a), i.addChildrenMap("title", h), i.addChildrenMap("toolbar", l), i.addChildrenMap("leftToolbar", c), i.addChildrenMap("content", f), i.addChildrenMap("description", p), i.addChildrenMap("choices", v), i.addChildrenMap("actions", y), i.addChildrenMap("choicesSizer", n), i.addChildrenMap("actionsSizer", s), i.addChildrenMap("toolbarSizer", r), i.addChildrenMap("leftToolbarSizer", o), i } return k(L) }(), Hg = function (t, e) { return -1 !== t.indexOf(e) }; Object.assign(Ug.prototype, Xg), c.register("dialog", function (t) { var e = new Ug(this.scene, t); return this.scene.add.existing(e), e }), R(window, "RexPlugins.UI.Dialog", Ug); var Ng = Phaser.Utils.Objects.GetValue, Jg = function () { w(v, wv); var p = T(v); function v(t, e) { var i; z(this, v), void 0 === e && (e = {}), e.orientation = 1, (i = p.call(this, t, e)).type = "rexHolyGrail"; var n = Ng(e, "background", void 0); n && i.addBackground(n); var s = Ng(e, "header", void 0); if (s) { var r = Ng(e, "proportion.header", 0), o = Ng(e, "align.header", "center"); "number" == typeof (c = Ng(e, "space.header", void 0)) && (c = { bottom: c }); var a = Ng(e, "expand.header", !0); i.add(s, { proportion: r, align: o, padding: c, expand: a }) } var h = new wv(t, { orientation: 0 }); i.add(h, { proportion: 1, align: "center", padding: 0, expand: !0 }); var l = Ng(e, "leftSide", void 0); if (l) { r = Ng(e, "proportion.leftSide", 0), o = Ng(e, "align.leftSide", "center"); "number" == typeof (c = Ng(e, "space.leftSide", void 0)) && (c = { right: c }); a = Ng(e, "expand.leftSide", !0); h.add(l, { proportion: r, align: o, padding: c, expand: a }) } var u = Ng(e, "content", void 0); if (u) { r = Ng(e, "proportion.content", 1), o = Ng(e, "align.content", "center"); var c = Ng(e, "space.content", void 0); a = Ng(e, "expand.content", !0); h.add(u, { proportion: r, align: o, padding: c, expand: a }) } var d = Ng(e, "rightSide", void 0); if (d) { r = Ng(e, "proportion.rightSide", 0), o = Ng(e, "align.rightSide", "center"); "number" == typeof (c = Ng(e, "space.rightSide", void 0)) && (c = { left: c }); a = Ng(e, "expand.rightSide", !0); h.add(d, { proportion: r, align: o, padding: c, expand: a }) } var f = Ng(e, "footer", void 0); if (f) { r = Ng(e, "proportion.footer", 0), o = Ng(e, "align.footer", "center"); "number" == typeof (c = Ng(e, "space.footer", void 0)) && (c = { top: c }); a = Ng(e, "expand.footer", !0); i.add(f, { proportion: r, align: o, padding: c, expand: a }) } return i.addChildrenMap("background", n), i.addChildrenMap("header", s), i.addChildrenMap("leftSide", l), i.addChildrenMap("content", u), i.addChildrenMap("rightSide", d), i.addChildrenMap("footer", f), i } return k(v) }(); c.register("holyGrail", function (t) { var e = new Jg(this.scene, t); return this.scene.add.existing(e), e }), R(window, "RexPlugins.UI.HolyGrail", Jg); var Kg = { getButtonsSizer: function (t) { return this.childrenMap["".concat(t, "ButtonsSizer")] }, getButton: function (t, e) { var i = this.getButtonsSizer(t); return i ? i.getButton(e) : void 0 }, setButtonEnable: function (t, e, i) { return this.getButtonsSizer(t).setButtonEnable(e, i), this }, setLeftButtonEnable: function (t, e) { return this.childrenMap.leftButtonsSizer.setButtonEnable(t, e), this }, setRightButtonEnable: function (t, e) { return this.childrenMap.rightButtonsSizer.setButtonEnable(t, e), this }, setTopButtonEnable: function (t, e) { return this.childrenMap.topButtonsSizer.setButtonEnable(t, e), this }, setBottomButtonEnable: function (t, e) { return this.childrenMap.bottomButtonsSizer.setButtonEnable(t, e), this }, toggleButtonEnable: function (t, e) { return this.getButtonsSizer(t).toggleButtonEnable(e), this }, toggleLeftButtonEnable: function (t) { return this.childrenMap.leftButtonsSizer.toggleButtonEnable(t), this }, toggleRightButtonEnable: function (t) { return this.childrenMap.rightButtonsSizer.toggleButtonEnable(t), this }, toggleTopButtonEnable: function (t) { return this.childrenMap.topButtonsSizer.toggleButtonEnable(t), this }, toggleBottomButtonEnable: function (t) { return this.childrenMap.bottomButtonsSizer.toggleButtonEnable(t), this }, getButtonEnable: function (t, e) { return this.getButtonsSizer(t).getButtonEnable(e) }, getLeftButtonEnable: function (t) { return this.childrenMap.leftButtonsSizer.getButtonEnable(t) }, getRightButtonEnable: function (t) { return this.childrenMap.rightButtonsSizer.getButtonEnable(t) }, getTopButtonEnable: function (t) { return this.childrenMap.topButtonsSizer.getButtonEnable(t) }, getBottomButtonEnable: function (t) { return this.childrenMap.bottomButtonsSizer.getButtonEnable(t) }, emitButtonClick: function (t, e) { var i = this.getButtonsSizer(t); return i && i.emitButtonClick(e), this }, emitLeftButtonClick: function (t) { return this.childrenMap.leftButtonsSizer.emitButtonClick(t), this }, emitRightButtonClick: function (t) { return this.childrenMap.rightButtonsSizer.emitButtonClick(t), this }, emitTopButtonClick: function (t) { return this.childrenMap.topButtonsSizer.emitButtonClick(t), this }, emitBottomButtonClick: function (t) { return this.childrenMap.bottomButtonsSizer.emitButtonClick(t), this }, getLeftButton: function (t) { return this.childrenMap.leftButtonsSizer.getButton(t) }, getRightButton: function (t) { return this.childrenMap.rightButtonsSizer.getButton(t) }, getTopButton: function (t) { return this.childrenMap.topButtonsSizer.getButton(t) }, getBottomButton: function (t) { return this.childrenMap.bottomButtonsSizer.getButton(t) }, showButton: function (t, e) { return Ou(this.getButton(t, e)), this }, showLeftButton: function (t) { return Ou(this.getLeftButton(t)), this }, showRightButton: function (t) { return Ou(this.getRightButton(t)), this }, showTopButton: function (t) { return Ou(this.getTopButton(t)), this }, showBottomButton: function (t) { return Ou(this.getBottomButton(t)), this }, hideButton: function (t, e) { return Mu(this.getButton(t, e)), this }, hideLeftButton: function (t) { return Mu(this.getLeftButton(t)), this }, hideRightButton: function (t) { return Mu(this.getRightButton(t)), this }, hideTopButton: function (t) { return Mu(this.getTopButton(t)), this }, hideBottomButton: function (t) { return Mu(this.getBottomButton(t)), this }, addButton: function (t, e) { return this.getButtonsSizer(t).addButton(e), this }, addLeftButton: function (t) { return this.addButton("left", t), this }, addRightButton: function (t) { return this.addButton("right", t), this }, addTopButton: function (t) { return this.addButton("top", t), this }, removeButton: function (t, e, i) { return this.getButtonsSizer(t).removeButton(e, i), this }, removeLeftButton: function (t, e) { return this.removeButton("left", t, e), this }, removeRightButton: function (t, e) { return this.removeButton("right", t, e), this }, removeTopButton: function (t, e) { return this.removeButton("top", t, e), this }, removeBottomButton: function (t, e) { return this.removeButton("bottom", t, e), this }, clearButtons: function (t, e) { return this.getButtonsSizer(t).clearButtons(e), this }, clearLeftButtons: function (t) { return this.clearButtons("left", t), this }, clearRightButtons: function (t) { return this.clearButtons("right", t), this }, clearTopButtons: function (t) { return this.clearButtons("top", t), this }, clearBottomButtonss: function (t) { return this.clearButtons("bottom", t), this }, forEachButton: function (t, e, i) { return this.getButtonsSizer(t).forEachButtton(e, i), this }, forEachLeftButton: function (t, e) { return this.childrenMap.leftButtonsSizer.forEachButtton(t, e), this }, forEachRightButton: function (t, e) { return this.childrenMap.rightButtonsSizer.forEachButtton(t, e), this }, forEachTopButton: function (t, e) { return this.childrenMap.topButtonsSizer.forEachButtton(t, e), this }, forEachBottomButton: function (t, e) { return this.childrenMap.bottomButtonsSizer.forEachButtton(t, e), this } }, qg = Phaser.Utils.Objects.GetValue, $g = function () { w(M, Fv); var O = T(M); function M(t, e) { var i; z(this, M), void 0 === e && (e = {}), e.column = 3, e.row = 3, (i = O.call(this, t, e)).type = "rexTabs", i.eventEmitter = qg(e, "eventEmitter", j(i)); var n, s, r, o, a = qg(e, "background", void 0), h = qg(e, "panel", void 0), l = qg(e, "leftButtons", void 0), u = qg(e, "leftButtonsBackground", void 0), c = qg(e, "rightButtons", void 0), d = qg(e, "rightButtonsBackground", void 0), f = qg(e, "topButtons", void 0), p = qg(e, "topButtonsBackground", void 0), v = qg(e, "bottomButtons", void 0), g = qg(e, "bottomButtonsBackground", void 0), y = qg(e, "click", void 0); if (a && i.addBackground(a), h && i.add(h, 1, 1, "center", 0, !0), l) { var m = qg(e, "space.leftButtonsOffset", 0), k = qg(e, "space.leftButton", 0); n = new Pg(t, { groupName: "left", background: u, buttons: l, orientation: 1, space: { item: k }, align: qg(e, "align.leftButtons", void 0), click: y, eventEmitter: i.eventEmitter }); var b = { top: m }; i.add(n, 0, 1, "top", b, !1) } if (c) { var x = qg(e, "space.rightButtonsOffset", 0), C = qg(e, "space.rightButton", 0); s = new Pg(t, { groupName: "right", background: d, buttons: c, orientation: 1, space: { item: C }, align: qg(e, "align.rightButtons", void 0), click: y, eventEmitter: i.eventEmitter }); b = { top: x }; i.add(s, 2, 1, "top", b, !1) } if (f) { var w = qg(e, "space.topButtonsOffset", 0), S = qg(e, "space.topButton", 0); r = new Pg(t, { groupName: "top", background: p, buttons: f, orientation: 0, space: { item: S }, align: qg(e, "align.topButtons", void 0), click: y, eventEmitter: i.eventEmitter }); b = { left: w }; i.add(r, 1, 0, "left", b, !1) } if (v) { var P = qg(e, "space.bottomButtonsOffset", 0), T = qg(e, "space.bottomButton", 0); o = new Pg(t, { groupName: "bottom", background: g, buttons: v, orientation: 0, space: { item: T }, align: qg(e, "align.bottomButtons", void 0), click: y, eventEmitter: i.eventEmitter }); b = { left: P }; i.add(o, 1, 2, "left", b, !1) } return i.addChildrenMap("background", a), i.addChildrenMap("panel", h), i.addChildrenMap("leftButtons", l), i.addChildrenMap("rightButtons", c), i.addChildrenMap("topButtons", f), i.addChildrenMap("bottomButtons", v), i.addChildrenMap("leftButtonsSizer", n), i.addChildrenMap("rightButtonsSizer", s), i.addChildrenMap("topButtonsSizer", r), i.addChildrenMap("bottomButtonsSizer", o), i } return k(M) }(); Object.assign($g.prototype, Kg), c.register("tabs", function (t) { var e = new $g(this.scene, t); return this.scene.add.existing(e), e }), R(window, "RexPlugins.UI.Tabs", $g); function Zg(t, e, i) { var n, s, r; return t.y === e.y ? (n = Math.min(t.x, e.x), s = Math.max(t.x, e.x), r = iy(i.x, n, s)) : t.x === e.x && (n = Math.min(t.y, e.y), s = Math.max(t.y, e.y), r = iy(i.y, n, s)), r } function Qg(t, e, i) { this.enable && (ny.x = e, ny.y = i, this.value = Zg(this.getStartPoint(), this.getEndPoint(), ny)) } function ty(t) { if (this.enable && t.isDown) { sy.x = t.worldX, sy.y = t.worldY; var e = Zg(this.getStartPoint(), this.getEndPoint(), sy); this.stopEaseValue(), 0 === this.easeValueDuration || Math.abs(this.value - e) < .1 ? this.value = e : this.easeValueTo(e) } } function ey(t, e) { void 0 === e && (e = ry); var i = this.childrenMap.thumb, n = i.x, s = i.y; return hu(i, this.innerLeft, this.innerTop, this.innerWidth, this.innerHeight, t), e.x = i.x, e.y = i.y, i.x = n, i.y = s, e } var iy = Phaser.Math.Percent, ny = {}, sy = {}, ry = {}, oy = Phaser.Display.Align.LEFT_CENTER, ay = Phaser.Display.Align.TOP_CENTER, hy = {}, ly = Phaser.Display.Align.RIGHT_CENTER, uy = Phaser.Display.Align.BOTTOM_CENTER, cy = {}, dy = Phaser.Math.Linear, fy = {}, py = Phaser.Display.Align.LEFT_CENTER, vy = Phaser.Display.Align.TOP_CENTER, gy = Phaser.Utils.Objects.GetValue, yy = Phaser.Math.Clamp, my = Phaser.Math.Linear, ky = Phaser.Math.Percent, by = Phaser.Math.Snap.To, xy = function () { w(c, wv); var u = T(c); function c(t, e) { var i; z(this, c), (i = u.call(this, t, e)).type = "rexSlider", i.eventEmitter = gy(e, "eventEmitter", j(i)); var n = gy(e, "background", void 0), s = gy(e, "track", void 0), r = gy(e, "indicator", void 0), o = gy(e, "thumb", void 0); n && i.addBackground(n), s && i.add(s, { proportion: 1, expand: !0, minWidth: 0, minHeight: 0 }), r && i.pin(r), o && i.pin(o); var a = gy(e, "input", 0); switch ("string" == typeof a && (a = Cy[a]), a) { case 0: o && (o.setInteractive(), i.scene.input.setDraggable(o), o.on("drag", Qg, j(i)).on("dragstart", function (t) { this.eventEmitter.emit("inputstart", t) }, j(i)).on("dragend", function (t) { this.eventEmitter.emit("inputend", t) }, j(i))); break; case 1: i.setInteractive().on("pointerdown", ty, j(i)).on("pointermove", ty, j(i)).on("pointerdown", function (t) { this.eventEmitter.emit("inputstart", t) }, j(i)).on("pointerup", function (t) { this.eventEmitter.emit("inputend", t) }, j(i)).on("pointerover", function (t) { t.isDown && this.eventEmitter.emit("inputstart", t) }, j(i)).on("pointerout", function (t) { t.isDown && this.eventEmitter.emit("inputend", t) }, j(i)) }i.addChildrenMap("background", n), i.addChildrenMap("track", s), i.addChildrenMap("indicator", r), i.addChildrenMap("thumb", o); var h = gy(e, "valuechangeCallback", null); if (null !== h) { var l = gy(e, "valuechangeCallbackScope", void 0); i.eventEmitter.on("valuechange", h, l) } return i.setEnable(gy(e, "enable", void 0)), i.setGap(gy(e, "gap", void 0)), i.setValue(gy(e, "value", 0), gy(e, "min", void 0), gy(e, "max", void 0)), i.setEaseValuePropName("value").setEaseValueDuration(gy(e, "easeValue.duration", 0)).setEaseValueFunction(gy(e, "easeValue.ease", "Linear")), i } return k(c, [{ key: "setEnable", value: function (t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "setGap", value: function (t) { return this.gap = t, this } }, { key: "value", get: function () { return this._value }, set: function (t) { void 0 !== this.gap && (t = by(t, this.gap)); var e = this._value; this._value = yy(t, 0, 1), e !== this._value && (this.updateThumb(this._value), this.updateIndicator(this._value), this.eventEmitter.emit("valuechange", this._value, e, this.eventEmitter)) } }, { key: "setValue", value: function (t, e, i) { return null == t || (void 0 !== e && (t = ky(t, e, i)), this.value = t), this } }, { key: "addValue", value: function (t, e, i) { return void 0 !== e && (t = ky(t, e, i)), this.value += t, this } }, { key: "getValue", value: function (t, e) { var i = this.value; return void 0 !== t && (i = my(t, e, i)), i } }, { key: "runLayout", value: function (t, e, i) { return this.ignoreLayout || (O(C(c.prototype), "runLayout", this).call(this, t, e, i), this.updateThumb(), this.updateIndicator()), this } }]), c }(), Cy = { pan: 0, drag: 0, click: 1, none: -1 }, wy = { getStartPoint: function (t) { if (void 0 === t && (t = hy), this.childrenMap.thumb) { var e = 0 === this.orientation ? oy : ay; ey.call(this, e, t) } else 0 === this.orientation ? (t.x = this.innerLeft + 1, t.y = this.centerY) : (t.x = this.centerX, t.y = this.innerTop + 1); return t }, getEndPoint: function (t) { if (void 0 === t && (t = cy), this.childrenMap.thumb) { var e = 0 === this.orientation ? ly : uy; ey.call(this, e, t) } else 0 === this.orientation ? (t.x = this.innerRight - 1, t.y = this.centerY) : (t.x = this.centerX, t.y = this.innerBottom - 1); return t }, updateThumb: function (t) { var e, i, n, s, r = this.childrenMap.thumb; return void 0 === r || (void 0 === t && (t = this.value), e = t, i = this.getStartPoint(), n = this.getEndPoint(), void 0 === (s = r) && (s = fy), s.x = dy(i.x, n.x, e), s.y = dy(i.y, n.y, e), this.resetChildPositionState(r)), this }, updateIndicator: function (t) { var e, i, n = this.childrenMap.indicator; if (void 0 === n) return this; void 0 === t && (t = this.value); var s = this.childrenMap.thumb; if (s) if (0 === this.orientation) { var r = jl(s); e = s.x - r * s.originX + r - this.left } else { var o = Fl(s); i = s.y - o * s.originY + o - this.top } else 0 === this.orientation ? e = this.width * t : i = this.height * t; Lu(n, e, i); var a = 0 === this.orientation ? py : vy; au(n, this, a), this.resetChildPositionState(n) } }; Object.assign(xy.prototype, wy, Wh), c.register("slider", function (t) { var e = new xy(this.scene, t); return this.scene.add.existing(e), e }), R(window, "RexPlugins.UI.Slider", xy); function Sy(t) { var e = Ty(t, "scrollMode", 0); return "string" == typeof e && (e = Py[e]), e } var Py = { v: 0, vertical: 0, h: 1, horizontal: 1 }, Ty = Phaser.Utils.Objects.GetValue, Oy = Phaser.Utils.Objects.GetValue, My = function () { w(p, wv); var f = T(p); function p(t, e) { var i; z(this, p), (i = f.call(this, t, e)).type = "rexScrollBar"; var n, s = Oy(e, "background", void 0), r = Oy(e, "buttons", void 0), o = Oy(r, "top", Oy(r, "left", void 0)), a = Oy(r, "bottom", Oy(r, "right", void 0)), h = Oy(e, "slider", void 0); s && i.addBackground(s), o && (i.add(o), new nd(o).on("intouch", function () { this.enable && (this.value -= this.scrollStep) }, j(i))); if (h) { var l; if (h.orientation = i.orientation, h.eventEmitter = j(i), h.value = null, 0 === i.orientation) l = void 0 === Oy(h, "width", void 0) ? 1 : 0; else l = void 0 === Oy(h, "height", void 0) ? 1 : 0; n = new xy(t, h), t.add.existing(n), i.add(n, { proportion: l }) } a && (i.add(a), new nd(a).on("intouch", function () { this.enable && (this.value += this.scrollStep) }, j(i))); var u = [o, a]; i.addChildrenMap("background", s), i.addChildrenMap("slider", n), i.addChildrenMap("buttons", u); var c = Oy(e, "valuechangeCallback", null); if (null !== c) { var d = Oy(e, "valuechangeCallbackScope", void 0); i.on("valuechange", c, d) } return i.setEnable(Oy(e, "enable", void 0)), i.setValue(Oy(e, "value", 0)), i.setScrollStep(Oy(r, "step", .01)), i } return k(p, [{ key: "setScrollStep", value: function (t) { return this.scrollStep = t, this } }, { key: "enable", get: function () { return !!this.childrenMap.slider && this.childrenMap.slider.enable }, set: function (t) { this.childrenMap.slider && this.childrenMap.slider.setEnable(t) } }, { key: "setEnable", value: function (t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "value", get: function () { return this.childrenMap.slider ? this.childrenMap.slider.value : 0 }, set: function (t) { this.childrenMap.slider && (this.childrenMap.slider.value = t) } }, { key: "setValue", value: function (t, e, i) { return this.childrenMap.slider && this.childrenMap.slider.setValue(t, e, i), this } }, { key: "addValue", value: function (t, e, i) { return this.childrenMap.slider && this.childrenMap.slider.addValue(t, e, i), this } }, { key: "getValue", value: function (t, e) { return this.childrenMap.slider ? this.childrenMap.slider.getValue(t, e) : 0 } }, { key: "easeValueTo", value: function (t, e, i) { return this.childrenMap.slider && this.childrenMap.slider.easeValueTo(t, e, i), this } }, { key: "stopEaseValue", value: function () { return this.childrenMap.slider && this.childrenMap.slider.stopEaseValue(), this } }, { key: "setEaseValueDuration", value: function (t) { return this.childrenMap.slider && this.childrenMap.slider.setEaseValueDuration(t), this } }, { key: "setEaseValueFunction", value: function (t) { return this.childrenMap.slider && this.childrenMap.slider.setEaseValueFunction(t), this } }]), p }(), Ey = function () { w(o, My); var r = T(o); function o(t, e) { var i; z(this, o), void 0 === e && (e = {}); var n = rt(e); (e = { slider: n }).orientation = n.orientation, delete n.orientation, e.background = n.background, delete n.background, e.buttons = n.buttons, delete n.buttons; var s = (i = r.call(this, t, e)).childrenMap.slider; return i.addChildrenMap("track", s.childrenMap.track), i.addChildrenMap("indicator", s.childrenMap.indicator), i.addChildrenMap("thumb", s.childrenMap.thumb), i } return k(o) }(), _y = function () { w(s, Zc); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, e)).parent = t, i.init(), i } return k(s, [{ key: "init", value: function () { this.start("IDLE") } }, { key: "next_IDLE", value: function () { var t, e = this.parent; return e.dragState.isDown && (t = 0 === e.dragThreshold ? "DRAG" : "DRAGBEGIN"), t } }, { key: "update_IDLE", value: function () { this.next() } }, { key: "next_DRAGBEGIN", value: function () { var t = this.parent, e = t.dragState; return e.isDown ? e.pointer.getDistance() >= t.dragThreshold ? "DRAG" : "DRAGBEGIN" : "IDLE" } }, { key: "update_DRAGBEGIN", value: function () { this.next() } }, { key: "next_DRAG", value: function () { var t, e = this.parent; return e.dragState.isUp && (t = e.outOfBounds ? "BACK" : e.slidingEnable ? "SLIDE" : "IDLE"), t } }, { key: "update_DRAG", value: function () { var t = this.parent; t.dragState.justMoved && t.dragging(), this.next() } }, { key: "enter_DRAG", value: function () { this.parent.onDragStart() } }, { key: "exit_DRAG", value: function () { this.parent.onDragEnd() } }, { key: "next_SLIDE", value: function () { var t, e = this.parent; return e.dragState.isDown ? t = "DRAG" : e.isSliding || (t = "IDLE"), t } }, { key: "enter_SLIDE", value: function () { this.parent.onSliding() } }, { key: "exit_SLIDE", value: function () { this.parent.stop() } }, { key: "update_SLIDE", value: function (t, e) { this.parent.sliding(t, e), this.next() } }, { key: "next_BACK", value: function () { var t, e = this.parent; return e.dragState.isDown ? t = "DRAG" : e.isPullBack || (t = "IDLE"), t } }, { key: "enter_BACK", value: function () { this.parent.onPullBack() } }, { key: "exit_BACK", value: function () { this.parent.stop() } }, { key: "update_BACK", value: function (t, e) { this.parent.pullBack(t, e), this.next() } }]), s }(), By = Phaser.Utils.Objects.GetValue, Iy = Phaser.Math.Distance.Between, Ry = function () { w(s, Ta); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, t, e))._enable = void 0, t.setInteractive(By(e, "inputConfig", void 0)), i.resetFromJSON(e), i.boot(), i } return k(s, [{ key: "resetFromJSON", value: function (t) { return this.pointer = void 0, this.isInTouched = !1, this.holdStartTime = void 0, this.x = void 0, this.y = void 0, this.preX = void 0, this.preY = void 0, this.localX = void 0, this.localY = void 0, this.justMoved = !1, this.setEnable(By(t, "enable", !0)), this.holdThreshold = By(t, "holdThreshold", 50), this.pointerOutReleaseEnable = By(t, "pointerOutRelease", !0), this } }, { key: "boot", value: function () { this.parent.on("pointerdown", this.onPointIn, this), this.parent.on("pointerup", this.onPointOut, this), this.pointerOutReleaseEnable && this.parent.on("pointerout", this.onPointOut, this), this.parent.on("pointermove", this.onPointerMove, this), this.scene.sys.events.on("preupdate", this.preupdate, this) } }, { key: "shutdown", value: function (t) { this.isShutdown || (this.scene.sys.events.off("preupdate", this.preupdate, this), this.pointer = void 0, O(C(s.prototype), "shutdown", this).call(this, t)) } }, { key: "enable", get: function () { return this._enable }, set: function (t) { this._enable !== t && (t || (this.isInTouched = !1, this.pointer = void 0), this._enable = t) } }, { key: "setEnable", value: function (t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "toggleEnable", value: function () { return this.setEnable(!this.enable), this } }, { key: "setPointerOutReleaseEnable", value: function (t) { return void 0 === t && (t = !0), this.pointerOutReleaseEnable = t, this } }, { key: "isDown", get: function () { return this.pointer && this.pointer.isDown } }, { key: "isUp", get: function () { return !this.isDown } }, { key: "dx", get: function () { return this.x - this.preX } }, { key: "dy", get: function () { return this.y - this.preY } }, { key: "dt", get: function () { return this.scene.sys.game.loop.delta } }, { key: "speed", get: function () { return this.x === this.preX && this.y === this.preY ? 0 : Iy(this.preX, this.preY, this.x, this.y) / (.001 * this.dt) } }, { key: "speedX", get: function () { return this.dx / (.001 * this.dt) } }, { key: "speedY", get: function () { return this.dy / (.001 * this.dt) } }, { key: "onPointIn", value: function (t, e, i) { this.enable && t.isDown && void 0 === this.pointer && (this.pointer = t, this.localX = e, this.localY = i) } }, { key: "onPointOut", value: function (t) { this.enable && this.pointer === t && (this.pointer = void 0) } }, { key: "onPointerMove", value: function (t, e, i) { this.enable && t.isDown && this.pointer === t && (this.localX = e, this.localY = i) } }, { key: "preupdate", value: function (t) { if (this.enable) { var e = this.pointer; this.justMoved = !1, e && !this.isInTouched ? (this.x = e.worldX, this.y = e.worldY, this.preX = e.worldX, this.preY = e.worldY, this.isInTouched = !0, this.holdStartTime = void 0, this.emit("touchstart", e, this.localX, this.localY)) : e && this.isInTouched ? this.x === e.x && this.y === e.y ? void 0 === this.holdStartTime ? this.holdStartTime = t : t - this.holdStartTime > this.holdThreshold && (this.preX = this.x, this.preY = this.y) : (this.preX = this.x, this.preY = this.y, this.x = e.worldX, this.y = e.worldY, this.holdStartTime = void 0, this.justMoved = !0, this.emit("touchmove", e, this.localX, this.localY)) : !e && this.isInTouched && (this.isInTouched = !1, this.holdStartTime = void 0, this.emit("touchend", e)) } } }]), s }(), Ay = Phaser.Utils.Objects.GetValue, Dy = function () { function e(t) { z(this, e), this.resetFromJSON(t) } return k(e, [{ key: "resetFromJSON", value: function (t) { return this.setValue(Ay(t, "value", 0)), this.setSpeed(Ay(t, "speed", 0)), this.setAcceleration(Ay(t, "acceleration", 0)), this } }, { key: "reset", value: function () { this.setValue(0), this.setSpeed(0), this.setAcceleration(0) } }, { key: "setValue", value: function (t) { return this.value = t, this } }, { key: "setSpeed", value: function (t) { return this.speed = t, this } }, { key: "setAcceleration", value: function (t) { return this.acceleration = t, this } }, { key: "updateSpeed", value: function (t) { return 0 !== this.acceleration && (this.speed += this.acceleration * t, this.speed < 0 && (this.speed = 0)), this } }, { key: "getDeltaValue", value: function (t) { return this.updateSpeed(t), this.speed <= 0 ? 0 : this.speed * t } }, { key: "update", value: function (t) { return this.updateSpeed(t), 0 < this.speed && (this.value += this.getDeltaValue(t)), this } }, { key: "isMoving", get: function () { return 0 < this.speed } }]), e }(), Ly = function () { function t() { z(this, t), this.value, this.dir, this.movement = new Dy } return k(t, [{ key: "init", value: function (t, e, i, n, s) { return this.value = t, this.end = s, this.dir = void 0 !== s ? t < s : e, this.movement.setSpeed(i).setAcceleration(-n), this } }, { key: "stop", value: function () { this.movement.reset() } }, { key: "update", value: function (t) { var e = this.movement.getDeltaValue(t); return this.dir || (e = -e), void 0 === this.end ? this.value += e : 0 === e ? this.value = this.end : (this.value += e, this.dir ? this.value > this.end && (this.value = this.end) : this.value < this.end && (this.value = this.end)), this } }, { key: "isMoving", get: function () { return this.movement.isMoving } }]), t }(), zy = Phaser.Utils.Objects.GetValue, jy = Phaser.Math.Clamp, Fy = function () { w(h, Ta); var a = T(h); function h(t, e) { var i; z(this, h), i = a.call(this, t, e); var n = zy(e, "enable", !0); i._state = new _y(j(i), { enable: n, eventEmitter: !1 }); var s = { inputConfig: zy(e, "inputConfig", void 0), enable: n, pointerOutRelease: zy(e, "pointerOutRelease", !0), eventEmitter: !1 }; i.dragState = new Ry(t, s), i._enable = void 0, i._value = void 0, i._slowDown = new Ly; var r = zy(e, "valuechangeCallback", null); if (null !== r) { var o = zy(e, "valuechangeCallbackScope", void 0); i.on("valuechange", r, o) } if (null !== (r = zy(e, "overmaxCallback", null))) { o = zy(e, "overmaxCallbackScope", void 0); i.on("overmax", r, o) } if (null !== (r = zy(e, "overminCallback", null))) { o = zy(e, "overminCallbackScope", void 0); i.on("overmin", r, o) } return i.resetFromJSON(e), i.boot(), i } return k(h, [{ key: "resetFromJSON", value: function (t) { this.setOrientationMode(zy(t, "orientation", 0)), this.setDragThreshold(zy(t, "threshold", 10)), this.setSlidingDeceleration(zy(t, "slidingDeceleration", 5e3)), this.setBackDeceleration(zy(t, "backDeceleration", 2e3)); var e = zy(t, "bounds", void 0); return e ? this.setBounds(e) : this.setBounds(zy(t, "max", 0), zy(t, "min", 0)), this.setValue(zy(t, "value", this.maxValue || 0)), this.setEnable(zy(t, "enable", !0)), this } }, { key: "boot", value: function () { this.scene.sys.events.on("preupdate", this._state.update, this._state) } }, { key: "shutdown", value: function (t) { this.isShutdown || (this.scene.sys.events.off("preupdate", this._state.update, this._state), this._state.destroy(t), this.dragState.destroy(t), this._state = void 0, this.dragState = void 0, O(C(h.prototype), "shutdown", this).call(this, t)) } }, { key: "enable", get: function () { return this._enable }, set: function (t) { if (this._enable !== t) return this._enable = t, this._state.setEnable(t), this.dragState.setEnable(t), this } }, { key: "setEnable", value: function (t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "toggleEnable", value: function () { return this.setEnable(!this.enable), this } }, { key: "setOrientationMode", value: function (t) { return "string" == typeof t && (t = Yy[t]), this.orientationMode = t, this } }, { key: "setDragThreshold", value: function (t) { return this.dragThreshold = t, this } }, { key: "setSlidingDeceleration", value: function (t) { return this.slidingDeceleration = t, this } }, { key: "setBackDeceleration", value: function (t) { return this.backDeceleration = t, this } }, { key: "setBounds", value: function (t, e) { if (Array.isArray(t)) { var i = t; t = i[0], e = i[1] } return t < e ? (this.minValue = t, this.maxValue = e) : (this.minValue = e, this.maxValue = t), this } }, { key: "value", get: function () { return this._value }, set: function (t) { if (t !== this._value) { var e = this._value, i = this.overMax(t), n = this.overMin(t); i && this.emit("overmax", t, e), n && this.emit("overmin", t, e), this.backEnable || (i && (t = this.maxValue), n && (t = this.minValue)), this._value = t, this.emit("valuechange", t, e) } } }, { key: "setValue", value: function (t, e) { return void 0 === e && (e = !1), e && (t = jy(t, this.minValue, this.maxValue)), this.value = t, this } }, { key: "addValue", value: function (t, e) { return this.setValue(this.value + t, e), this } }, { key: "state", get: function () { return this._state.state } }, { key: "isDragging", get: function () { return this.dragState.isInTouched } }, { key: "outOfMaxBound", get: function () { return this.overMax(this.value) } }, { key: "outOfMinBound", get: function () { return this.overMin(this.value) } }, { key: "outOfBounds", get: function () { return this.outOfMinBound || this.outOfMaxBound } }, { key: "overMax", value: function (t) { return null != this.maxValue && t > this.maxValue } }, { key: "overMin", value: function (t) { return null != this.minValue && t < this.minValue } }, { key: "backEnable", get: function () { return "number" == typeof this.backDeceleration } }, { key: "isPullBack", get: function () { return this._slowDown.isMoving } }, { key: "slidingEnable", get: function () { return "number" == typeof this.slidingDeceleration } }, { key: "isSliding", get: function () { return this._slowDown.isMoving } }, { key: "dragDelta", get: function () { return 0 === this.orientationMode ? this.dragState.dy : 1 === this.orientationMode ? this.dragState.dx : 0 } }, { key: "dragSpeed", get: function () { return 0 === this.orientationMode ? this.dragState.speedY : 1 === this.orientationMode ? this.dragState.speedX : 0 } }, { key: "onDragStart", value: function () { this.emit("dragstart") } }, { key: "onDragEnd", value: function () { this.emit("dragend") } }, { key: "dragging", value: function () { this.value += this.dragDelta } }, { key: "onSliding", value: function () { var t = this.value, e = this.dragSpeed; if (0 === e) return this._slowDown.stop(), void this._state.next(); var i = this.slidingDeceleration; this._slowDown.init(t, 0 < e, Math.abs(e), i) } }, { key: "sliding", value: function (t, e) { e *= .001; var i = this._slowDown.update(e).value; this.overMax(i) ? (this.value = this.maxValue, this._slowDown.stop()) : this.overMin(i) ? (this.value = this.minValue, this._slowDown.stop()) : this.value = i } }, { key: "onPullBack", value: function () { var t = this.value, e = this.outOfMinBound ? this.minValue : this.maxValue, i = Math.abs(e - t), n = this.backDeceleration, s = Math.sqrt(2 * n * i); this._slowDown.init(t, void 0, s, n, e) } }, { key: "pullBack", value: function (t, e) { e *= .001, this.value = this._slowDown.update(e).value, this._slowDown.isMoving || this._state.next() } }, { key: "stop", value: function () { this._slowDown.stop() } }]), h }(), Yy = { y: 0, v: 0, vertical: 0, x: 1, h: 1, horizontal: 1 }, Wy = Phaser.Utils.Objects.GetValue, Vy = function () { w(s, Ta); var n = T(s); function s(t, e) { var i; (z(this, s), (i = n.call(this, t, e)).parent !== i.scene ? i.focusMode = Wy(e, "focus", !1) : i.focusMode = !1, i.setSpeed(Wy(e, "speed", .1)), i.setEnable(Wy(e, "enable", !0)), i.focusMode) ? (t = i.parent).setInteractive(Wy(e, "inputConfig", void 0)).on("wheel", function (t, e, i, n, s) { this.enable && this.scroll(i) }, j(i)) : i.scene.input.on("wheel", i.onSceneScroll, j(i)); return i } return k(s, [{ key: "destroy", value: function () { this.focusMode || this.scene.input.off("wheel", this.onSceneScroll, this) } }, { key: "onSceneScroll", value: function (t, e, i, n) { this.enable && this.scroll(n) } }, { key: "setEnable", value: function (t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "setSpeed", value: function (t) { return this.speed = t, this } }, { key: "scroll", value: function (t) { t *= this.speed, this.emit("scroll", t, this.parent, this) } }]), s }(), Xy = Phaser.Utils.Objects.GetValue, Gy = { right: 0, left: 1, bottom: 0, top: 1 }; wv.prototype.runLayout; var Uy = function () { var t = Math.min(this.childVisibleHeight / this.childHeight, 1), e = this.childrenMap.slider, i = e.childrenMap.track, n = e.childrenMap.thumb, s = this.minThumbSize; if (0 === this.scrollMode) { var r = i.displayHeight * t; void 0 !== s && r < s && (r = s), Lu(n, void 0, r) } else { var o = i.displayWidth * t; void 0 !== s && o < s && (o = s), Lu(n, o, void 0) } Hy.call(this) }, Hy = function () { var t = this.childrenMap.slider, e = t.minWidth, i = t.minHeight; t.minWidth = t.width, t.minHeight = t.height, t.layout(), t.minWidth = e, t.minHeight = i }, Ny = Phaser.Utils.Objects.GetValue, Jy = Phaser.Math.Clamp, Ky = function () { w(p, wv); var f = T(p); function p(t, e) { var i; z(this, p), void 0 === e && (e = {}); var n = Sy(e); e.orientation = 0 === n ? 1 : 0, (i = f.call(this, t, e)).type = Ny(e, "type", "rexScrollable"); var s = Ny(e, "background", void 0), r = function (e, t) { var i, n = e.scene, s = Sy(t), r = new wv(n, { orientation: s }), o = Xy(t, "child.gameObject", void 0), a = 0, h = Xy(t, "slider", void 0), l = 0, u = Xy(h, "position", 0); "string" == typeof u && (u = Gy[u]); var c, d, f = 0 === u, p = Xy(t, "scroller", !0), v = Xy(t, "mouseWheelScroller", !1); if (o) { var g = Xy(t, "space.child", 0); if (e.childMargin = {}, "number" != typeof g) { var y = g; 0 === s ? (a = { left: Xy(y, "left", 0), right: Xy(y, "right", 0) }, e.childMargin.top = Xy(y, "top", 0), e.childMargin.bottom = Xy(y, "bottom", 0)) : (a = { top: Xy(y, "top", 0), bottom: Xy(y, "bottom", 0) }, e.childMargin.top = Xy(y, "left", 0), e.childMargin.bottom = Xy(y, "right", 0)) } else h && (a = 0 === s ? f ? { right: g } : { left: g } : f ? { bottom: g } : { top: g }), e.childMargin.top = 0, e.childMargin.bottom = 0; h ? (!0 === h && (h = {}), h.orientation = 0 === r.orientation ? 1 : 0, i = new Ey(n, h), l = Xy(t, "space.slider", 0), e.adaptThumbSizeMode = Xy(h, "adaptThumbSize", !1), e.minThumbSize = Xy(h, "minThumbSize", void 0)) : (e.adaptThumbSizeMode = !1, e.minThumbSize = void 0), p && (!0 === p && (p = {}), p.orientation = s, c = new Fy(o, p)), v && (d = new Vy(o, v)), i && !f && r.add(i, { proportion: 0, align: "center", padding: l, expand: !0 }); var m = Xy(t, "child.proportion", 1), k = Xy(t, "child.expand", !0); r.add(o, { proportion: m, align: "center", padding: a, expand: k }), i && f && r.add(i, { proportion: 0, align: "center", padding: l, expand: !0 }) } return i && i.on("valuechange", function (t) { e.t = t, e.emit("scroll", e) }), c && c.on("valuechange", function (t) { e.childOY = t, e.emit("scroll", e) }), d && d.on("scroll", function (t) { e.addChildOY(-t, !0) }), e.addChildrenMap("child", o), e.addChildrenMap("slider", i), e.addChildrenMap("scroller", c), e.addChildrenMap("mouseWheelScroller", d), r }(j(i), e), o = Ny(e, "header", void 0), a = Ny(e, "footer", void 0); if (s && i.addBackground(s), o) { var h = Ny(e, "align.header", "center"), l = Ny(e, "space.header", 0); c = 0 === n ? { bottom: l } : { right: l }; var u = Ny(e, "expand.header", !0); i.add(o, { proportion: 0, align: h, padding: c, expand: u }) } if (r && i.add(r, { proportion: 1, align: "center", padding: 0, expand: !0 }), a) { h = Ny(e, "align.footer", "center"); var c, d = Ny(e, "space.footer", 0); c = 0 === n ? { top: d } : { left: d }; u = Ny(e, "expand.footer", !0); i.add(a, { proportion: 0, align: h, padding: c, expand: u }) } return i.addChildrenMap("background", s), i.addChildrenMap("header", o), i.addChildrenMap("footer", a), i.runLayoutFlag = !1, i } return k(p, [{ key: "runLayout", value: function (t, e, i) { return this.ignoreLayout || (O(C(p.prototype), "runLayout", this).call(this, t, e, i), this.resizeController(), this.runLayoutFlag || (this.runLayoutFlag = !0, this.setT(0))), this } }, { key: "t", get: function () { var t = this.childrenMap.child.t, e = this.childMargin; if (0 !== e.top || 0 !== e.bottom) { var i = this.childrenMap.child, n = i.topChildOY - i.bottomChildOY, s = n + e.top + e.bottom; t = (n * t + e.top) / s } return t }, set: function (t) { var e = this.childMargin; if (0 !== e.top || 0 !== e.bottom) { var i = this.childrenMap.child, n = i.topChildOY - i.bottomChildOY; t = ((n + e.top + e.bottom) * t - e.top) / n } this.childrenMap.child.t = t, this.updateController() } }, { key: "childOY", get: function () { return this.childrenMap.child.childOY }, set: function (t) { this.childrenMap.child.childOY = t, this.updateController() } }, { key: "topChildOY", get: function () { return this.childrenMap.child.topChildOY + this.childMargin.top } }, { key: "bottomChildOY", get: function () { return this.childrenMap.child.bottomChildOY - this.childMargin.bottom } }, { key: "childVisibleHeight", get: function () { return this.childrenMap.child.childVisibleHeight } }, { key: "childHeight", get: function () { return this.childrenMap.child.childHeight } }, { key: "isOverflow", get: function () { var t = this.childrenMap.child; return t.topChildOY !== t.bottomChildOY } }, { key: "scrollMode", get: function () { return 0 === this.orientation ? 1 : 0 } }, { key: "setChildOY", value: function (t, e) { return void 0 === e && (e = !1), e && (t = Jy(t, this.bottomChildOY, this.topChildOY)), this.childOY = t, this } }, { key: "addChildOY", value: function (t, e) { return this.setChildOY(this.childOY + t, e), this } }, { key: "setT", value: function (t, e) { return void 0 === e && (e = !1), e && (t = Jy(t, 0, 1)), this.t = t, this } }, { key: "addT", value: function (t, e) { return this.setT(this.t + t, e), this } }, { key: "scrollToTop", value: function () { return this.t = 0, this } }, { key: "scrollToBottom", value: function () { return this.t = 1, this } }, { key: "sliderEnable", get: function () { var t = this.childrenMap.slider; return !!t && t.enable }, set: function (t) { var e = this.childrenMap.slider; e && e.setEnable(t) } }, { key: "setSliderEnable", value: function (t) { return void 0 === t && (t = !0), this.sliderEnable = t, this } }, { key: "scrollerEnable", get: function () { var t = this.childrenMap.scroller; return !!t && t.enable }, set: function (t) { var e = this.childrenMap.scroller; e && e.setEnable(t) } }, { key: "setScrollerEnable", value: function (t) { return void 0 === t && (t = !0), this.scrollerEnable = t, this } }, { key: "mouseWheelScrollerEnable", get: function () { var t = this.childrenMap.mouseWheelScroller; return !!t && t.enable }, set: function (t) { var e = this.childrenMap.mouseWheelScrollerEnable; e && e.setEnable(t) } }, { key: "setMouseWheelScrollerEnable", value: function (t) { return void 0 === t && (t = !0), this.mouseWheelScrollerEnable = t, this } }, { key: "setDropZoneEnable", value: function (t) { void 0 === t && (t = !0); var e = this.childrenMap.child; return e.setInteractive(), e.input.dropZone = t, this } }]), p }(), qy = { resizeController: function () { var t = this.topChildOY, e = this.bottomChildOY, i = this.childrenMap.scroller, n = this.childrenMap.slider; return i && i.setBounds(e, t), n && n.setEnable(e !== t), this.updateController(), this.adaptThumbSizeMode && Uy.call(this), this }, updateController: function () { var t = this.childrenMap.scroller, e = this.childrenMap.slider; t && t.setValue(this.childOY), e && e.setValue(this.t) } }; Object.assign(Ky.prototype, qy); var $y = function () { function i(t, e) { z(this, i), this.container = null, this._deltaHeight = 0, this.setParent(t) } return k(i, [{ key: "setParent", value: function (t) { this.parent = t, this.parentContainer = t.getParentContainer() } }, { key: "destroy", value: function (t) { void 0 === t && (t = !1), t || this.destroyContainer(), this.deltaHeight = 0, this.data = void 0, this.container = null, this.parent = void 0, this.parentContainer = void 0 } }, { key: "table", get: function () { return this.parent } }, { key: "scrollMode", get: function () { return this.parentContainer.scrollMode } }, { key: "colIndx", get: function () { return this.parent.cellIndxeToColIndex(this.index) } }, { key: "rowIndx", get: function () { return this.parent.cellIndxeToRowIndex(this.index) } }, { key: "getContainer", value: function () { return this.container } }, { key: "setContainer", value: function (t) { return t ? (this.container && this.container.destroy(), this.container = t, this.parentContainer.add(t)) : this.destroyContainer(), this } }, { key: "destroyContainer", value: function () { return this.container && (this.container.destroy(), this.container = null), this } }, { key: "popContainer", value: function () { if (this.container) { var t = this.container; return this.container = null, this.parentContainer.remove(t), t } return null } }, { key: "setXY", value: function (t, e) { return this.container && this.parentContainer.setChildLocalPosition(this.container, t, e), this } }, { key: "deltaHeight", get: function () { return this._deltaHeight }, set: function (t) { null == t && (t = 0); var e = this.parent; 0 === this._deltaHeight && 0 !== t ? e.nonZeroDeltaHeightCount++ : 0 !== this._deltaHeight && 0 === t && e.nonZeroDeltaHeightCount--; var i = this._deltaHeight !== t; if (this._deltaHeight = t, i) { e.resetTotalRowsHeight(); var n = 0 === this.scrollMode ? "cellheightchange" : "cellwidthchange"; this.parentContainer.emit(n, this, this.container, this.parentContainer) } } }, { key: "deltaWidth", get: function () { return this.deltaHeight }, set: function (t) { this.deltaHeight = t } }, { key: "setDeltaHeight", value: function (t) { return this.deltaHeight = t, this } }, { key: "setDeltaWidth", value: function (t) { return this.deltaHeight = t, this } }, { key: "height", get: function () { return 0 === this.scrollMode ? this.deltaHeight + this.parent.defaultCellHeight : this.parent.defaultCellWidth }, set: function (t) { 1 !== this.scrollMode && this.setDeltaHeight(t - this.parent.defaultCellHeight) } }, { key: "setHeight", value: function (t) { return this.height = t, this } }, { key: "width", get: function () { return 0 === this.scrollMode ? this.parent.defaultCellWidth : this.deltaHeight + this.parent.defaultCellHeight }, set: function (t) { 0 !== this.scrollMode && this.setDeltaHeight(t - this.parent.defaultCellHeight) } }, { key: "setWidth", value: function (t) { return this.width = t, this } }, { key: "scene", get: function () { return this.parentContainer.scene } }]), i }(); Object.assign($y.prototype, ot); function Zy(t) { return t.hasOwnProperty("geometryMask") ? t.geometryMask : t.bitmapMask } function Qy(t) { if (this.emit("cellinvisible", t), this.cellContainersPool) { var e = t.popContainer(); e && this.cellContainersPool.killAndHide(e) } t.destroyContainer() } function tm() { var t = this.preVisibleCells, e = this.visibleCells; t.iterate(function (t) { e.contains(t) || Qy.call(this, t) }, this) } function em(t) { var e, i = null; (e = t.getContainer()) ? (i = e, t.popContainer()) : this.cellContainersPool && null !== (i = this.cellContainersPool.getFirstDead()) && i.setActive(!0).setVisible(!0), this.emit("cellvisible", t, i, this), this.cellContainersPool && ((e = t.getContainer()) ? null === i ? this.cellContainersPool.add(e) : i !== e && (this.cellContainersPool.add(e), this.cellContainersPool.killAndHide(i)) : null !== i && this.cellContainersPool.killAndHide(i)) } function im(t, e) { e -= this.y + this.topLeftY, t -= this.x + this.topLeftX; var i = this.tableOY - (0 === this.scrollMode ? e : t), n = this.tableOX - (0 === this.scrollMode ? t : e), s = this.table, r = s.heightToRowIndex(-i), o = s.widthToColIndex(-n), a = s.colRowToCellIndex(o, r); return null !== a && this.isCellVisible(a) ? a : null } var nm = Phaser.Utils.Objects.GetValue, sm = Phaser.Utils.Array.SpliceOne, rm = function () { function i(t, e) { z(this, i), this.parent = t, this.cells = [], this.cellPool = new G, this.resetFromJSON(e) } return k(i, [{ key: "resetFromJSON", value: function (t) { return this.colCount = void 0, this.nonZeroDeltaHeightCount = 0, this.resetTotalRowsHeight(), this.setDefaultCellHeight(nm(t, "cellHeight", 30)), this.setDefaultCellWidth(nm(t, "cellWidth", 30)), this.initCells(nm(t, "cellsCount", 0)), this.setColumnCount(nm(t, "columns", 1)), this } }, { key: "destroy", value: function () { this.cellPool.destroy(), this.cells = void 0, this.parent = void 0 } }, { key: "defaultCellHeightMode", get: function () { return 0 === this.nonZeroDeltaHeightCount } }, { key: "setDefaultCellHeight", value: function (t) { return this.defaultCellHeight = t, this } }, { key: "setDefaultCellWidth", value: function (t) { return this.defaultCellWidth = t, this } }, { key: "initCells", value: function (t) { var e = this.cells; e.length = t; for (var i = 0; i < t; i++)e[i] = null; return this } }, { key: "insertNewCells", value: function (t, e) { var i = this.cells; if (t === i.length) { var n = t + e; i.legth = n; for (var s = t; s < n; s++)i[s] = null } else { var r, o = []; o.length = e; for (s = 0; s < e; s++)o[s] = null; (r = this.cells).splice.apply(r, [t, 0].concat(o)) } return this.resetTotalRowsHeight(), this } }, { key: "removeCells", value: function (t, e) { for (var i = t + e, n = t; n < i; n++)this.freeCell(n); return i === this.cells.length ? this.cells.length = t : (1 === e ? sm(this.cells, t) : this.cells.splice(t, e), this.buildCellIndex(t)), this.resetTotalRowsHeight(), this } }, { key: "setColumnCount", value: function (t) { return this.colCount = t, this.resetTotalRowsHeight(), this } }, { key: "rowCount", get: function () { return Math.ceil(this.cells.length / this.colCount) } }, { key: "cellsCount", get: function () { return this.cells.length } }, { key: "isValidCellIdx", value: function (t) { return 0 <= t && t < this.cells.length } }, { key: "heightToRowIndex", value: function (t, e) { if (this.defaultCellHeightMode) { var i = t / this.defaultCellHeight; return i = e ? Math.ceil(i) : Math.floor(i) } var n, s = this.rowCount, r = t; for (i = 0; ;) { if (n = 0 <= i && i < s, !(0 < (r -= this.getRowHeight(i)) && n)) { if (0 === r) return i; if (e) { var o = i; (n = 0 <= (i += 1) && i < s) || (i = o) } return i } i += 1 } } }, { key: "widthToColIndex", value: function (t, e) { var i = t / this.defaultCellWidth; return i = e ? Math.ceil(i) : Math.floor(i) } }, { key: "colRowToCellIndex", value: function (t, e) { return t >= this.colCount ? null : e * this.colCount + t } }, { key: "rowIndexToHeight", value: function (t, e) { if (this.defaultCellHeightMode) return (e - t + 1) * this.defaultCellHeight; for (var i = 0, n = t; n <= e; n++)i += this.getRowHeight(n); return i } }, { key: "colIndexToWidth", value: function (t, e) { return (e - t + 1) * this.defaultCellWidth } }, { key: "getRowHeight", value: function (t) { var e = this.colCount; if (e <= 1) return this.getCellHeight(this.colRowToCellIndex(0, t)); for (var i, n = 0, s = 0; s < e; s++)n < (i = this.getCellHeight(this.colRowToCellIndex(s, t))) && (n = i); return n } }, { key: "getColWidth", value: function () { return this.defaultCellWidth } }, { key: "getCellHeight", value: function (t) { if (!this.isValidCellIdx(t)) return 0; var e; if (this.defaultCellHeightMode) e = this.defaultCellHeight; else { var i = this.getCell(t, !1), n = i ? i.deltaHeight : 0; e = this.defaultCellHeight + n } return e } }, { key: "resetTotalRowsHeight", value: function () { this._totalRowsHeight = null } }, { key: "totalRowsHeight", get: function () { return null === this._totalRowsHeight && (this._totalRowsHeight = this.rowIndexToHeight(0, this.rowCount - 1)), this._totalRowsHeight } }, { key: "totalColumnWidth", get: function () { return this.colCount * this.defaultCellWidth } }, { key: "cellIndxeToColIndex", value: function (t) { return t % this.colCount } }, { key: "cellIndxeToRowIndex", value: function (t) { return Math.floor(t / this.colCount) } }, { key: "getCell", value: function (t, e) { if (!this.isValidCellIdx(t)) return null; if (void 0 === e && (e = !0), null === this.cells[t] && e) { var i = this.newCell(t); this.cells[t] = i } return this.cells[t] } }, { key: "newCell", value: function (t) { var e = this.cellPool.pop(); return null === e ? e = new $y(this) : e.setParent(this), e.index = t, e } }, { key: "buildCellIndex", value: function (t) { void 0 === t && (t = 0); for (var e, i = this.cells, n = t, s = i.length; n < s; n++)(e = i[n]) && (e.index = n); return this } }, { key: "getParentContainer", value: function () { return this.parent } }, { key: "freeCell", value: function (t) { return "number" == typeof t && (t = this.cells[t]), t && (t.destroy(), this.cellPool.push(t)), this } }]), i }(), om = Phaser.Geom.Intersects.RectangleToRectangle, am = Phaser.Geom.Rectangle.Overlaps, hm = function (t) { for (; ;) { var e = t.rexContainer; if (e) { if (e.visible) { var i = e.parent; if (i) { t = i; continue } return !0 } return !1 } return t.visible } }, lm = function (t, e) { var i = 0, n = e.top, s = e.bottom, r = e.left, o = e.right; return i += t.contains(r, n) ? 1 : 0, i += t.contains(r, s) ? 1 : 0, i += t.contains(o, n) ? 1 : 0, i += t.contains(o, s) ? 1 : 0 }, um = function (t, e) { t.setChildMaskVisible(e, !0), e.clearMask && e.clearMask() }, cm = function (t, e, i) { t.setChildMaskVisible(e, !0), e.setMask && e.setMask(i) }, dm = function (t, e) { t.setChildMaskVisible(e, !1), e.clearMask && e.clearMask() }, fm = Phaser.Utils.Objects.GetValue, pm = { update: 0, everyTick: 1 }, vm = { setupChildrenMask: function (t) { return !1 === t || (this.setMaskUpdateMode(fm(t, "updateMode", 0)), this.enableChildrenMask(fm(t, "padding", 0)), this.setMaskLayer(fm(t, "layer", void 0)), this.startMaskUpdate()), this }, destroyChildrenMask: function () { return this.childrenMask && (this.stopMaskUpdate(), this.childrenMask.destroy(), this.childrenMask = void 0), this }, setMaskUpdateMode: function (t) { return "string" == typeof t && (t = pm[t]), this.maskUpdateMode = t, this }, startMaskUpdate: function () { this.scene.game.events.on("poststep", this.maskChildren, this) }, stopMaskUpdate: function () { this.scene.game.events.off("poststep", this.maskChildren, this) }, enableChildrenMask: function (t) { var e = ig.call(this, null, this, 0, t); return this.childrenMask = e.createGeometryMask(), this }, setMaskChildrenFlag: function (t) { return void 0 === t && (t = !0), this.maskChildrenFlag = t, this }, setMaskLayer: function (t) { return this.maskLayer = t, this }, maskChildren: function () { return this.childrenMask && this.maskChildrenFlag && 0 !== this.alpha && this.visible && (this.maskLayer ? (this.addToLayer(this.maskLayer), this.maskLayer.setMask(this.childrenMask)) : function (t, e, i) { if (e) { void 0 === i && (i = t.getAllChildren()); for (var n, s, r = t.getBounds(), o = Zy(e), a = 0, h = i.length; a < h; a++)if (!(n = i[a]).hasOwnProperty("isRexContainerLite") && n !== o && hm(n)) if (n.getBounds) switch (s = n.getBounds(s), lm(r, s)) { case 4: um(t, n); break; case 0: om(r, s) || am(r, s) ? cm(t, n, e) : dm(t, n); break; default: cm(t, n, e) } else cm(t, n, e) } }(this, this.childrenMask, this.getAllChildren(), this.maskLayer), 0 === this.maskUpdateMode && (this.maskChildrenFlag = !1)), this }, layoutChildrenMask: function () { if (!this.childrenMask) return this; var t = Zy(this.childrenMask); return t.setPosition().resize(), this.resetChildPositionState(t), this } }, gm = function (t) { var e = 0 === this.scrollMode ? this.topLeftX : this.topLeftY; return this.tableOX + this.table.colIndexToWidth(0, t - 1) + e }, ym = function (t) { var e = 0 === this.scrollMode ? this.topLeftY : this.topLeftX; return this.tableOY + this.table.rowIndexToHeight(0, t - 1) + e }, mm = function () { var t = this.preVisibleCells; this.preVisibleCells = this.visibleCells, this.visibleCells = t, this.visibleCells.clear() }, km = Phaser.Math.Clamp, bm = { setTableOY: function (t) { var e = this.table, i = this.topTableOY, n = this.bottomTableOY, s = t > this.topTableOY, r = t < this.bottomTableOY; this.clampTableOXY && (e.rowCount < e.heightToRowIndex(this.instHeight, !0) ? t = 0 : s ? t = i : r && (t = n)); return this._tableOY !== t && (this._tableOY = t), s && (this.execeedTopState || this.emit("execeedtop", this, t, i)), this.execeedTopState = s, r && (this.execeedBottomState || this.emit("execeedbottom", this, t, n)), this.execeedBottomState = r, this }, setTableOX: function (t) { var e = this.table, i = this.leftTableOX, n = this.rightTableOX, s = t > this.leftTableOX, r = t < this.rightTableOX; this.clampTableOXY && (e.colCount < e.widthToColIndex(this.instWidth, !0) ? t = 0 : s ? t = i : r && (t = n)); return this._tableOX !== t && (this._tableOX = t), s && (this.execeedLeftState || this.emit("execeedleft", this, t, i)), this.execeedLeftState = s, r && (this.execeedRightState || this.emit("execeedright", this, t, n)), this.execeedRightState = r, this }, updateTable: function (t) { return void 0 === t && (t = !1), t && (mm.call(this), tm.call(this)), mm.call(this), function () { if (0 !== this.cellsCount) { var t = this.table, e = t.heightToRowIndex(-this.tableOY); e <= 0 && (e = 0); var i = e, n = t.widthToColIndex(-this.tableOX); n <= 0 && (n = 0); for (var s = n, r = t.colRowToCellIndex(s, i), o = this.bottomBound, a = this.rightBound, h = t.cellsCount - 1, l = t.colCount - 1, u = gm.call(this, s), c = u, d = ym.call(this, i); d < o && r <= h;) { if (this.table.isValidCellIdx(r)) { var f = t.getCell(r, !0); this.visibleCells.set(f), this.preVisibleCells.contains(f) || em.call(this, f), 0 === this.scrollMode ? f.setXY(c, d) : f.setXY(d, c) } c < a && s < l ? (c += t.getColWidth(s), s += 1) : (c = u, d += t.getRowHeight(i), s = n, i += 1), r = t.colRowToCellIndex(s, i) } } }.call(this), tm.call(this), this.setMaskChildrenFlag(), this }, isCellVisible: function (t) { var e = this.table.getCell(t, !1); return e && this.visibleCells.contains(e) }, pointToCellIndex: im, pointToCellContainer: function (t, e) { var i = im.call(this, t, e); if (null !== i) return this.getCellContainer(i) }, eachVisibleCell: function (t, e) { return this.visibleCells.each(t, e), this }, iterateVisibleCell: function (t, e) { return this.visibleCells.iterate(t, e), this }, eachCell: function (t, e) { return this.table.cells.slice().forEach(t, e), this }, iterateCell: function (t, e) { return this.table.cells.forEach(t, e), this }, setCellsCount: function (t) { var e = this.cellsCount; return e === t || (t < e ? this.removeCells(t, e - t) : this.insertNewCells(e, t - e)), this }, insertNewCells: function (t, e) { return "object" === P(t) && (t = t.index), void 0 === e && (e = 1), e <= 0 || (t = km(t, 0, this.cellsCount), this.table.insertNewCells(t, e)), this }, removeCells: function (t, e) { if ("object" === P(t) && (t = t.index), void 0 === e && (e = 1), t < 0 && (e += t, t = 0), e <= 0) return this; if (t > this.cellsCount) return this; for (var i, n = t, s = t + e; n < s; n++)(i = this.getCell(n, !1)) && (this.visibleCells.contains(i) && (Qy.call(this, i), this.visibleCells.delete(i)), this.preVisibleCells.delete(i)); return this.table.removeCells(t, e), this }, setColumnCount: function (t) { return this.table.colCount === t || this.table.setColumnCount(t), this }, setGridSize: function (t, e) { return this.setCellsCount(t * e), this.table.setColumnCount(t), this }, updateVisibleCell: function (t) { var e = this.table.getCell(t, !1); return e && e.container && em.call(this, e), this } }; Object.assign(bm, vm); var xm = Phaser.GameObjects.Group, Cm = Phaser.Structs.Set, wm = Phaser.Utils.Objects.GetValue, Sm = function () { w(f, dr); var d = T(f); function f(t, e, i, n, s, r) { var o; z(this, f), void 0 === r && (r = {}), (o = d.call(this, t, e, i, n, s)).type = "rexGridTable", o._tableOX = 0, o._tableOY = 0, o.visibleCells = new Cm, o.preVisibleCells = new Cm, o.execeedTopState = !1, o.execeedBottomState = !1, o.execeedLeftState = !1, o.execeedRightState = !1, wm(r, "reuseCellContainer", !1) && (o.cellContainersPool = new xm(t)); var a = wm(r, "cellVisibleCallback", null); if (null !== a) { var h = wm(r, "cellVisibleCallbackScope", void 0); o.on("cellvisible", a, h) } if (null !== (a = wm(r, "cellInvisibleCallback", null))) { h = wm(r, "cellInvisibleCallbackScope", void 0); o.on("cellinvisible", a, h) } if (o.setupChildrenMask(wm(r, "mask", void 0)), o.setScrollMode(wm(r, "scrollMode", 0)), o.setClampMode(wm(r, "clamplTableOXY", !0)), 0 === o.scrollMode) { var l = wm(r, "cellWidth", void 0); if (o.expandCellSize = void 0 === l, void 0 === l) { var u = wm(r, "columns", 1); r.cellWidth = o.width / u } } else { l = wm(r, "cellHeight", void 0); var c = wm(r, "cellWidth", void 0); o.expandCellSize = void 0 === l, r.cellWidth = l, r.cellHeight = c } return o.table = new rm(j(o), r), o.updateTable(), o } return k(f, [{ key: "destroy", value: function (t) { this.scene && (this.destroyChildrenMask(), this.table.destroy(t), this.table = void 0, this.cellContainersPool && (this.cellContainersPool.destroy(!0), this.cellContainersPool = void 0), O(C(f.prototype), "destroy", this).call(this, t)) } }, { key: "setScrollMode", value: function (t) { return "string" == typeof t && (t = Om[t.toLowerCase()]), this.scrollMode = t, this } }, { key: "setClampMode", value: function (t) { return void 0 === t && (t = !0), this.clampTableOXY = t, this } }, { key: "tableOY", get: function () { return this._tableOY }, set: function (t) { this.setTableOY(t).updateTable() } }, { key: "tableOX", get: function () { return this._tableOX }, set: function (t) { this.setTableOX(t).updateTable() } }, { key: "setTableOXY", value: function (t, e) { return this.setTableOY(e).setTableOX(t), this } }, { key: "addTableOY", value: function (t) { return this.setTableOY(this.tableOY + t), this } }, { key: "addTableOX", value: function (t) { return this.setTableOX(this.tableOX + t), this } }, { key: "addTableOXY", value: function (t, e) { return this.addTableOY(e).addTableOX(t), this } }, { key: "setTableOYByPercentage", value: function (t) { return this.setTableOY(-this.tableVisibleHeight * t), this } }, { key: "getTableOYPercentage", value: function () { var t = this.tableVisibleHeight; return 0 === t ? 0 : this.tableOY / -t } }, { key: "t", get: function () { return this.getTableOYPercentage() }, set: function (t) { this.setTableOYByPercentage(t).updateTable() } }, { key: "getCell", value: function (t) { return this.table.getCell(t, !0) } }, { key: "getCellContainer", value: function (t) { var e, i = this.table.getCell(t, !1); return i && (e = i.getContainer()), e } }, { key: "cellsCount", get: function () { return this.table.cellsCount } }, { key: "columnCount", get: function () { return this.table.colCount } }, { key: "setCellHeight", value: function (t, e) { return ("number" == typeof t ? this.table.getCell(t, !0) : t).height = e, this } }, { key: "setCellWidth", value: function (t, e) { return ("number" == typeof t ? this.table.getCell(t, !0) : t).width = e, this } }, { key: "instHeight", get: function () { return 0 === this.scrollMode ? this.height : this.width } }, { key: "instWidth", get: function () { return 0 === this.scrollMode ? this.width : this.height } }, { key: "tableHeight", get: function () { return this.table.totalRowsHeight } }, { key: "tableWidth", get: function () { return this.table.totalColumnWidth } }, { key: "topTableOY", get: function () { return 0 } }, { key: "bottomTableOY", get: function () { return -this.tableVisibleHeight } }, { key: "leftTableOX", get: function () { return 0 } }, { key: "rightTableOX", get: function () { return -this.tableVisibleWidth } }, { key: "tableVisibleHeight", get: function () { var t = this.tableHeight - this.instHeight; return t < 0 && (t = 0), t } }, { key: "tableVisibleWidth", get: function () { var t = this.tableWidth, e = this.instWidth; return e < t ? t - e : 0 } }, { key: "bottomLeftY", get: function () { return -(this.displayHeight * this.originY) + this.displayHeight } }, { key: "topRightX", get: function () { return -(this.displayWidth * this.originX) + this.displayWidth } }, { key: "topLeftX", get: function () { return -(this.displayWidth * this.originX) } }, { key: "topLeftY", get: function () { return -(this.displayHeight * this.originY) } }, { key: "bottomBound", get: function () { return 0 === this.scrollMode ? this.bottomLeftY : this.topRightX } }, { key: "rightBound", get: function () { return 0 === this.scrollMode ? this.topRightX : this.bottomLeftY } }, { key: "resize", value: function (t, e) { return this.width === t && this.height === e || (O(C(f.prototype), "resize", this).call(this, t, e), this.expandCellSize && this.table.setDefaultCellWidth(this.instWidth / this.table.colCount), this.updateTable(!0), this.layoutChildrenMask(), this.maskChildren()), this } }]), f }(); Object.assign(Sm.prototype, bm); function Pm(t, e, i, n, s, r, o) { var a; if (null != (a = void 0 === s ? n : i.pointToCellIndex(n, s))) { var h = i.getCellContainer(a); h && t.emit(e, h, a, r, o) } } function Tm(t, e) { t.setInteractive(), function (s) { s.on("pointerdown", function (t, e, i, n) { Pm(this.eventEmitter, "cell.down", s, t.x, t.y, t, n) }, this).on("pointerup", function (t, e, i, n) { Pm(this.eventEmitter, "cell.up", s, t.x, t.y, t, n) }, this) }.call(this, t, e), function (t) { t.on("pointermove", Mm, this).on("pointerover", Mm, this).on("pointerout", Em, this) }.call(this, t, e), function (t, e) { var i = _m(e, "click", void 0); !1 !== i && (void 0 === i && (i = {}), i.threshold = 10, t._click = new Uc(t, i), t._click.on("click", function (t, e, i, n) { Pm(this.eventEmitter, "cell.click", e, i.x, i.y, i, n) }, this)) }.call(this, t, e), function (t, e) { var i = Bm(e, "tap", void 0); !1 !== i && (t._tap = new bd(t, i), t._tap.on("tap", function (t, e, i) { var n = "cell.".concat(t.tapsCount, "tap"); Pm(this.eventEmitter, n, t.gameObject, t.x, t.y, i) }, this)) }.call(this, t, e), function (n, t) { var e = Im(t, "press", void 0); !1 !== e && (n._press = new Pd(n, e), n._press.on("pressstart", function (t, e, i) { Pm(this.eventEmitter, "cell.pressstart", n, t.x, t.y, i) }, this).on("pressend", function (t, e, i) { Pm(this.eventEmitter, "cell.pressend", n, t.x, t.y, i) }, this)) }.call(this, t, e), function (s, t) { var e = Rm(t, "swipe", void 0); !1 !== e && (void 0 === e && (e = {}), e.dir = "4dir", s._swipe = new Wd(s, e), s._swipe.on("swipe", function (t, e, i) { var n = t.left ? "left" : t.right ? "right" : t.up ? "up" : "down"; Pm(this.eventEmitter, "cell.swipe".concat(n), s, t.x, t.y, i) }, this)) }.call(this, t, e) } var Om = { v: 0, vertical: 0, h: 1, horizontal: 1 }, Mm = function (t, e, i, n) { var s = this.childrenMap.child, r = s.pointToCellIndex(t.x, t.y); if (r !== s.input.lastOverCellIndex) { var o = s.input.lastOverCellIndex; s.input.lastOverCellIndex = r, Pm(this.eventEmitter, "cell.out", s, o, void 0, t, n), Pm(this.eventEmitter, "cell.over", s, r, void 0, t, n) } }, Em = function (t, e) { var i = this.childrenMap.child, n = i.input.lastOverCellIndex; i.input.lastOverCellIndex = void 0, Pm(this.eventEmitter, "cell.out", i, n, void 0, t, e) }, _m = Phaser.Utils.Objects.GetValue, Bm = Phaser.Utils.Objects.GetValue, Im = Phaser.Utils.Objects.GetValue, Rm = Phaser.Utils.Objects.GetValue, Am = Phaser.Utils.Objects.GetValue, Dm = function () { w(g, Ky); var v = T(g); function g(t, e) { var i; z(this, g), void 0 === e && (e = {}); var n = Sy(e), s = Am(e, "table", void 0); void 0 === s && (s = {}), s.scrollMode = n, s.clamplTableOXY = Am(e, "clamplChildOY", !1); var r, o, a, h = Am(s, "width", void 0), l = Am(s, "height", void 0), u = new Sm(t, 0, 0, h, l, s); t.add.existing(u), o = 0 === n ? (r = void 0 === h ? 1 : 0, void 0 === l) : (r = void 0 === l ? 1 : 0, void 0 === h), a = u, Object.defineProperty(a, "childOY", { configurable: !0, get: function () { return a.tableOY }, set: function (t) { a.tableOY = t } }), Object.defineProperty(a, "topChildOY", { get: function () { return a.topTableOY } }), Object.defineProperty(a, "bottomChildOY", { get: function () { return a.bottomTableOY } }), Object.defineProperty(a, "childVisibleHeight", { get: function () { return a.instHeight } }), Object.defineProperty(a, "childHeight", { get: function () { return a.tableHeight } }), u.minWidth = void 0 === h ? 0 : void 0, u.minHeight = void 0 === l ? 0 : void 0, e.type = "rexGridTable", e.child = { gameObject: u, proportion: r, expand: o }; var c = Am(e, "space", void 0); c && (c.child = c.table), (i = v.call(this, t, e)).addChildrenMap("table", u), i.addChildrenMap("tableLayer", u.maskLayer), i.eventEmitter = Am(e, "eventEmitter", j(i)); var d = Am(e, "createCellContainerCallback", _), f = Am(e, "createCellContainerCallbackScope", void 0); i.setCreateCellContainerCallback(d, f), function (t) { t.on("cellvisible", function (t, e, i) { var n = this.createCellContainerCallback, s = this.createCellContainerCallbackScope; t.item = this.items[t.index], (e = s ? n.call(s, t, e, i) : n(t, e, i)) && (e.setOrigin && e.setOrigin(0), e.isRexSizer && e.layout()), t.item = void 0, t.setContainer(e) }, this) }.call(j(i), u), i.resizeControllerFlag = !1; var p = 0 === n ? "cellheightchange" : "cellwidthchange"; return u.on(p, function () { this.resizeControllerFlag = !0 }, j(i)), Am(s, "interactive", !0) && Tm.call(j(i), u, s), i.setItems(Am(e, "items", [])), t.game.events.on("poststep", i.onPostStep, j(i)), i } return k(g, [{ key: "destroy", value: function (t) { this.scene && (this.scene.game.events.off("poststep", this.onPostStep, this), O(C(g.prototype), "destroy", this).call(this, t)) } }, { key: "setCreateCellContainerCallback", value: function (t, e) { return this.createCellContainerCallback = t, this.createCellContainerCallbackScope = e, this } }, { key: "refresh", value: function () { return this.setItems(this.items), this } }, { key: "getCell", value: function (t) { return this.childrenMap.child.getCell(t) } }, { key: "getCellContainer", value: function (t) { return this.childrenMap.child.getCellContainer(t) } }, { key: "updateVisibleCell", value: function (t) { return this.childrenMap.child.updateVisibleCell(t) } }, { key: "onPostStep", value: function () { this.resizeControllerFlag && (this.resizeController(), this.resizeControllerFlag = !1) } }]), g }(), Lm = { setItems: function (t) { void 0 === t ? this.items.length = 0 : this.items = t; var e = this.childrenMap.child; return e.setCellsCount(this.items.length), e.updateTable(!0), this.resizeController(), this } }; Object.assign(Dm.prototype, Lm), c.register("gridTable", function (t) { var e = new Dm(this.scene, t); return this.scene.add.existing(e), e }), R(window, "RexPlugins.UI.GridTable", Dm); function zm(t, e) { return t.sameOrientation ? t.orientation = e.orientation : t.orientation = 0 === e.orientation ? 1 : 0, t } function jm(t) { t.popUp(zm(t.root.easeIn, t)) } function Fm(t) { t.scaleDown(zm(t.root.easeOut, t)) } function Ym(t, e, i, n, s) { var r = t.scene, o = r.sys.events; return r.time.delayedCall(e, o.once, ["postupdate", function () { i.call(n, s) }], o) } var Wm = { setTransitInCallback: function (t) { return void 0 === t && (t = jm), this.transitInCallback = t, this }, setTransitOutCallback: function (t) { return void 0 === t && (t = Fm), this.transitOutCallback = t, this } }, Vm = { delayCall: function (t, e, i) { return this.timer = Ym(this, t, e, i), this }, removeDelayCall: function () { return this.timer && (this.timer.remove(!1), this.timer = void 0), this } }, Xm = { expandSubMenu: function (t, e) { var i; if ((n = this.childrenMap.subMenu) && n.parentButton === t) return this; this.collapseSubMenu(), i = this.root.toggleOrientation ? 0 === this.orientation ? 1 : 0 : this.orientation; var n = new this.constructor(this.scene, { items: e, orientation: i, space: this.space, createBackgroundCallback: this.root.createBackgroundCallback, createBackgroundCallbackScope: this.root.createBackgroundCallbackScope, createButtonCallback: this.root.createButtonCallback, createButtonCallbackScope: this.root.createButtonCallbackScope, easeIn: this.root.easeIn, easeOut: this.root.easeOut, _rootMenu: this.root, _parentMenu: this, _parentButton: t }); return this.pin(n), this.childrenMap.subMenu = n, this.root.emit("expand", n, t, this), this }, collapse: function () { var t = this.root; t.emit("collapse", this, this.parentButton, t); var e = t.easeOut.duration; return t.transitOutCallback(this, e), this.collapseSubMenu(), this.delayCall(e, this.destroy, this), this }, collapseSubMenu: function () { var t = this.childrenMap.subMenu; return void 0 === t || (this.childrenMap.subMenu = void 0, this.remove(t), t.collapse()), this } }; Object.assign(Xm, Wm, Vm); function Gm(t, e) { return "number" == typeof e && (e = { duration: e }), e.hasOwnProperty("orientation") && void 0 !== e.orientation ? e.sameOrientation = kv(e.orientation) === t.orientation : e.sameOrientation = !0, e.destroy = !1, e } var Um = Phaser.Utils.Objects.GetValue, Hm = function () { w(P, Pg); var S = T(P); function P(t, e) { var i; z(this, P), void 0 === e && (e = {}), e.hasOwnProperty("orientation") || (e.orientation = 1); var n, s, r, o, a, h = e._rootMenu, l = e._parentMenu, u = e._parentButton, c = Um(e, "popup", !0), d = Um(e, "items", void 0), f = Um(e, "createBackgroundCallback", void 0), p = Um(e, "createBackgroundCallbackScope", void 0); e.background = (n = t, s = d, o = p, (r = f) && (s.scene = n, a = o ? r.call(o, s) : r(s), s.scene = void 0), a); var v = Um(e, "createButtonCallback", void 0), g = Um(e, "createButtonCallbackScope", void 0); if (e.buttons = function (t, e, i, n) { var s, r, o = []; if (e && i) for (var a = 0, h = e.length; a < h; a++)(s = e[a]).scene = t, r = n ? i.call(n, s, a, e) : i(s, a, e), s.scene = void 0, o.push(r); return o }(t, d, v, g), (i = S.call(this, t, e)).type = "rexMenu", i.items = d, i.root = void 0 === h ? j(i) : h, i.isRoot = i.root === j(i), i.parentMenu = l, i.parentButton = u, i.timer = void 0, i.isRoot) { i.isPopUpMode = c; var y = e.bounds; void 0 === y && (y = Bl(t)), i.bounds = y, i.subMenuSide = [i.y < y.centerY ? qm : Km, i.x < y.centerX ? Jm : Nm], void 0 !== (w = Um(e, "subMenuSide", void 0)) && ("string" == typeof w && (w = $m[w]), i.subMenuSide[i.orientation] = w), i.toggleOrientation = Um(e, "toggleOrientation", !1), i.expandEventName = Um(e, "expandEvent", "button.click"), i.easeIn = Gm(j(i), Um(e, "easeIn", 0)), i.easeOut = Gm(j(i), Um(e, "easeOut", 0)), i.setTransitInCallback(Um(e, "transitIn")), i.setTransitOutCallback(Um(e, "transitOut")), i.createBackgroundCallback = f, i.createBackgroundCallbackScope = p, i.createButtonCallback = v, i.createButtonCallbackScope = g, i.childrenKey = Um(e, "childrenKey", "children"), i._isPassedEvent = !1, i.pointerDownOutsideCollapsing = Um(e, "pointerDownOutsideCollapsing", !0), i.pointerDownOutsideCollapsing && t.input.on("pointerdown", i.onPointerDownOutside, j(i)) } var m, k = 0, b = 0; if (!i.root.easeIn.sameOrientation) { var x = zm(i.root.easeIn, j(i)).orientation, C = l ? l.orientation : i.orientation, w = i.root.subMenuSide[C]; 0 === x && w === Nm && (k = 1), 1 === x && w === Km && (b = 1) } if (c && i.setOrigin(k, b).layout(), !i.isRoot) switch (i.setScale(i.root.scaleX, i.root.scaleY), w = i.root.subMenuSide[l.orientation]) { case Nm: i.alignTop(u.top).alignRight(u.left); break; case Jm: i.alignTop(u.top).alignLeft(u.right); break; case Km: i.alignLeft(u.left).alignBottom(u.top); break; case qm: i.alignLeft(u.left).alignTop(u.bottom) }return (m = j(i)).on(m.root.expandEventName, function (t, e) { if (!this._isPassedEvent) { var i = this.root.childrenKey, n = this.items[e][i]; n && this.expandSubMenu(t, n) } }, m).on("button.click", function (t, e, i, n) { this !== this.root && (this.root._isPassedEvent = !0, this.root.emit("button.click", t, e, i, n), this.root._isPassedEvent = !1) }, m).on("button.over", function (t, e, i, n) { this !== this.root && (this.root._isPassedEvent = !0, this.root.emit("button.over", t, e, i, n), this.root._isPassedEvent = !1) }, m).on("button.out", function (t, e, i, n) { this !== this.root && (this.root._isPassedEvent = !0, this.root.emit("button.out", t, e, i, n), this.root._isPassedEvent = !1) }, m), c && (i.pushIntoBounds(i.root.bounds), function () { var t = this.root, e = t.easeIn.duration; t.transitInCallback(this, e), this !== this.root && this.delayCall(e, function () { this.root.emit("popup.complete", this) }, this) }.call(j(i))), i } return k(P, [{ key: "destroy", value: function (t) { this.scene && (this.isRoot && this.pointerDownOutsideCollapsing && this.scene.input.off("pointerdown", this.onPointerDownOutside, this), O(C(P.prototype), "destroy", this).call(this, t), this.removeDelayCall()) } }, { key: "isInTouching", value: function (t) { return !!O(C(P.prototype), "isInTouching", this).call(this, t) || !!this.childrenMap.subMenu && this.childrenMap.subMenu.isInTouching(t) } }, { key: "onPointerDownOutside", value: function (t) { this.isInTouching(t) || (this.isPopUpMode ? this.collapse() : this.collapseSubMenu()) } }]), P }(), Nm = 2, Jm = 0, Km = 3, qm = 1, $m = { up: Km, down: qm, left: Nm, right: Jm }; Object.assign(Hm.prototype, Xm), c.register("menu", function (t) { var e = new Hm(this.scene, t); return this.scene.add.existing(e), e }), R(window, "RexPlugins.UI.Menu", Hm); function Zm(t) { t.popUp(this.listEaseInDuration, "y", "Cubic") } function Qm(t) { t.scaleDown(this.listEaseOutDuration, "y", "Linear") } var tk = { setWrapEnable: function (t) { return void 0 === t && (t = !0), this.listWrapEnable = t, this }, setCreateButtonCallback: function (t) { return this.listCreateButtonCallback = t, this }, setCreateBackgroundCallback: function (t) { return this.listCreateBackgroundCallback = t, this }, setButtonClickCallback: function (t) { return this.listOnButtonClick = t, this }, setButtonOverCallback: function (t) { return this.listOnButtonOver = t, this }, setButtonOutCallback: function (t) { return this.listOnButtonOut = t, this }, setListEaseInDuration: function (t) { return void 0 === t && (t = 0), this.listEaseInDuration = t, this }, setListEaseOutDuration: function (t) { return void 0 === t && (t = 0), this.listEaseOutDuration = t, this }, setListTransitInCallback: function (t) { return void 0 === t && (t = Zm), this.listTransitInCallback = t, this }, settListTTransitOutCallback: function (t) { return void 0 === t && (t = Qm), this.listTransitOutCallback = t, this }, setListBounds: function (t) { return this.listBounds = t, this }, setListWidth: function (t) { return this.listWidth = t, this }, setListHeight: function (t) { return this.listHeight = t, this }, setListSize: function (t, e) { return this.setListWidth(t).setListHeight(e), this }, setListAlignmentMode: function (t) { return this.listAlignMode = t, this }, setListSpace: function (t) { return void 0 === t && (t = {}), this.listSpace = t, this }, setListDraggable: function (t) { return void 0 === t && (t = !0), this.listDraggable = t, this } }, ek = { delayCall: function (t, e, i) { return this.timer = Ym(this, t, e, i), this }, removeDelayCall: function () { return this.timer && (this.timer.remove(!1), this.timer = void 0), this } }, ik = { openListPanel: function () { if (this.listPanel) return this; var t = this.scene, r = function (t) { var e, i = this.listCreateBackgroundCallback; i && (e = i.call(this, t), t.add.existing(e)); var n = [], s = this.listCreateButtonCallback; if (s) for (var r = this.options, o = 0, a = r.length; o < a; o++) { var h = s.call(this, t, r[o], o, r); t.add.existing(h), n.push(h) } var l = this.listWidth; void 0 === l && (l = "text" === this.listAlignMode ? this.getElement("text").width : this.width); var u, c = this.listHeight; return u = this.listWrapEnable ? new Vg(t, { width: l, height: c, background: e, buttons: n, space: this.listSpace, draggable: this.listDraggable }) : new Pg(t, { width: l, height: c, orientation: "y", background: e, buttons: n, space: this.listSpace, draggable: this.listDraggable }), t.add.existing(u), u }.call(this, t).setOrigin(0, 0).layout(), e = this.getElement(this.listAlignMode).getTopLeft().x; r.setPosition(e, this.bottom); var i = this.listBounds; i = i || Bl(t), r.bottom > i.bottom && r.changeOrigin(0, 1).setPosition(e, this.top), r.on("button.over", function (t, e, i, n) { this.listOnButtonOver && this.listOnButtonOver.call(this, t, e, i, n), this.emit("button.over", this, r, t, e, i, n) }, this).on("button.out", function (t, e, i, n) { this.listOnButtonOut && this.listOnButtonOut.call(this, t, e, i, n), this.emit("button.out", this, r, t, e, i, n) }, this); var n = this.listEaseInDuration; return this.listTransitInCallback(r, n), this.delayCall(n, function () { var s = this.listOnButtonClick; s && r.on("button.click", function (t, e, i, n) { s.call(this, t, e, i, n), this.emit("button.click", this, r, t, e, i, n) }, this), t.input.once("pointerup", this.closeListPanel, this), this.emit("list.open", this, r) }, this), this.pin(r), this.listPanel = r, this }, closeListPanel: function () { if (!this.listPanel) return this; var t = this.listPanel; this.listPanel = void 0; var e = this.listEaseOutDuration; return this.listTransitOutCallback(t, e), this.delayCall(e, function () { this.emit("list.close", this, t), t.destroy() }, this), this }, toggleListPanel: function () { return this.listPanel ? this.closeListPanel() : this.openListPanel(), this } }; Object.assign(ik, tk, ek); var nk = Phaser.Utils.Objects.GetValue, sk = function () { w(r, sg); var s = T(r); function r(t, e) { var i; z(this, r), (i = s.call(this, t, e)).type = "rexDropDownList", i.timer = void 0, i.setOptions(nk(e, "options")); var n = nk(e, "list"); return i.setWrapEnable(nk(n, "wrap", !1)), i.setCreateButtonCallback(nk(n, "createButtonCallback")), i.setCreateBackgroundCallback(nk(n, "createBackgroundCallback")), i.setButtonClickCallback(nk(n, "onButtonClick")), i.setButtonOverCallback(nk(n, "onButtonOver")), i.setButtonOutCallback(nk(n, "onButtonOut")), i.setListEaseInDuration(nk(n, "easeIn", 500)), i.setListEaseOutDuration(nk(n, "easeOut", 100)), i.setListTransitInCallback(nk(n, "transitIn")), i.settListTTransitOutCallback(nk(n, "transitOut")), i.setListSize(nk(n, "width"), nk(n, "height")), i.setListAlignmentMode(nk(n, "alignParent", "text")), i.setListBounds(nk(n, "bounds")), i.setListSpace(nk(n, "space")), i.setListDraggable(nk(n, "draggable", !1)), i.setValueChangeCallback(nk(e, "setValueCallback"), nk(e, "setValueCallbackScope")), i.setValue(nk(e, "value")), i.onClick(i.toggleListPanel, j(i)), i } return k(r, [{ key: "destroy", value: function (t) { this.scene && (this.listPanel && (this.listPanel.destroy(t), this.listPanel = void 0), O(C(r.prototype), "destroy", this).call(this, t), this.removeDelayCall()) } }, { key: "setOptions", value: function (t) { return void 0 === t && (t = []), this.options = t, this } }, { key: "setValueChangeCallback", value: function (t, e) { return this.valueChangeCallback = t, this.valueChangeCallbackScope = e, this } }, { key: "setValue", value: function (t) { return this.value = t, this } }, { key: "value", get: function () { return this._value }, set: function (t) { if (this._value !== t) { var e = this._value; this._value = t; var i = this.valueChangeCallback, n = this.valueChangeCallbackScope; i && (n ? i.call(n, this, t, e) : i(this, t, e)) } } }]), r }(); Object.assign(sk.prototype, ik), c.register("dropDownList", function (t) { var e = new sk(this.scene, t); return this.scene.add.existing(e), e }), R(window, "RexPlugins.UI.DropDownList", sk); function rk(t) { return t instanceof ck } function ok(t) { return t instanceof dk } function ak(t) { return ok(t) ? 2 : rk(t) ? 0 : 1 } function hk(t, e, i) { switch (ak(t)) { case 0: i = t.getWrappedText(e); break; case 1: i = t.getPenManager(e, i); break; case 2: i = 0 < t.maxWidth ? t.setText(e).getTextBounds().wrappedText.split("\n") : e.split("\n") }return i } function lk(t) { return Array.isArray(t) ? t = t.join("\n") : "number" == typeof t && (t = t.toString()), t } function uk(t, e) { switch (ak(t)) { case 0: var i = (s = t.style).wordWrapWidth, n = s.wordWrapCallback; s.wordWrapWidth = 0, s.wordWrapCallback = void 0, t.setText(e), s.wordWrapWidth = i, s.wordWrapCallback = n; break; case 1: var s, r = (s = t.style).wrapMode; s.wrapMode = 0, t.setText(e), s.wrapMode = r; break; case 2: var o = t._maxWidth; t._maxWidth = 0, t.setText(e), t._maxWidth = o } } var ck = Phaser.GameObjects.Text, dk = Phaser.GameObjects.BitmapText, fk = { clearText: function () { return this.sections.length = 0, this.pageStartIndexes.length = 0, this.lines.length = 0, this }, appendPage: function (t) { var e = this.totalLinesCount; this.sections.push(lk(t)); t = this.sections.join("\n"); this.lines = hk(this.parent, t, this.lines); for (var i = this.totalLinesCount - e, n = Math.ceil(i / this.pageLinesCount), s = 0; s < n; s++)this.pageStartIndexes.push(e + s * this.pageLinesCount); return this }, setText: function (t, e) { void 0 === e && (e = !0), e && this.resetPageIdx(), this.clearText(); for (var i = lk(t).split(this.pageBreak), n = 0, s = i.length; n < s; n++)this.appendPage(i[n]); return this }, appendText: function (t) { var e = this.content + lk(t); return this.setText(e, !1), this } }, pk = Phaser.Math.Clamp, vk = { getPage: function (t) { return void 0 === t && (t = this.pageIndex), this.setPageIndex(t).getLines(this.startLineIndex, this.endLineIndex) }, getNextPage: function () { return this.getPage(this.pageIndex + 1) }, getPreviousPage: function () { return this.getPage(this.pageIndex - 1) }, resetPageIdx: function () { return this.pageIndex = -1, this }, setPageIndex: function (t) { return t = pk(t, 0, this.pageCount - 1), this.pageIndex = t, this.startLineIndex = this.pageStartIndexes[t], this.endLineIndex = this.pageStartIndexes[t + 1], this } }, gk = { showPage: function (t) { return this.displayText(this.getPage(t)), this }, showNextPage: function () { return this.displayText(this.getNextPage()), this }, showPreviousPage: function () { return this.displayText(this.getPreviousPage()), this }, show: function () { return this.displayText(this.getLines()), this }, showNextLine: function () { return this.displayText(this.setStartLineIndex(this.startLineIndex + 1).getLines()), this }, showPreviousLine: function () { return this.displayText(this.setStartLineIndex(this.startLineIndex - 1).getLines()), this }, displayText: function (t) { uk(this.parent, t) } }, yk = { getLines: function (t, e) { var i; switch (void 0 === t && (t = this.startLineIndex), void 0 === e && (e = t + this.pageLinesCount), this.textObjectType) { case 0: case 2: i = this.lines.slice(t, e).join("\n"); break; case 1: var n = this.lines.getLineStartIndex(t), s = this.lines.getLineEndIndex(e - 1); i = this.lines.getSliceTagText(n, s, !0) }return i } }; Object.assign(yk, fk, vk, gk); var mk = Phaser.Utils.Objects.GetValue, kk = Phaser.Math.Clamp, bk = function () { w(s, Ta); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, t, { eventEmitter: !1 })).textObjectType = ak(i.parent), i.pageStartIndexes = [], i.lines = hk(i.parent, ""), i.sections = [], i.resetFromJSON(e), i } return k(s, [{ key: "resetFromJSON", value: function (t) { return this.setMaxLines(mk(t, "maxLines", void 0)), this.setPageBreak(mk(t, "pageBreak", "\f\n")), this.setText(mk(t, "text", "")), this.setStartLineIndex(mk(t, "start", 0)), this.setPageIndex(mk(t, "page", -1)), this } }, { key: "toJSON", value: function () { return { maxLines: this.maxLines, text: this.content, start: this.startLineIndex, page: this.pageIndex, pageBreak: this.pageBreak } } }, { key: "shutdown", value: function (t) { if (!this.isShutdown) { switch (this.textObjectType) { case 0: this.lines.length = 0; break; case 1: this.lines.destroy(); break; case 2: this.lines.length = 0 }this.pageStartIndexes.length = 0, this.sections.length = 0, this.lines = void 0, this.pageStartIndexes = void 0, this.sections = void 0, O(C(s.prototype), "shutdown", this).call(this, t) } } }, { key: "setMaxLines", value: function (t) { return this.maxLines = t, this } }, { key: "setPageBreak", value: function (t) { return this.pageBreak = t, this } }, { key: "pageCount", get: function () { return this.pageStartIndexes.length } }, { key: "isFirstPage", get: function () { return this.pageIndex <= 0 } }, { key: "isLastPage", get: function () { return this.pageIndex >= this.pageCount - 1 } }, { key: "totalLinesCount", get: function () { return this.lines ? this.lines.length : 0 } }, { key: "startLineIndex", get: function () { return this._startLineIndex }, set: function (t) { t = kk(t, 0, this.totalLinesCount - 1), this._startLineIndex = t } }, { key: "setStartLineIndex", value: function (t) { return this.startLineIndex = t, this } }, { key: "pageLinesCount", get: function () { if (void 0 !== this.maxLines) return this.maxLines; var t; switch (this.textObjectType) { case 0: case 1: var e = this.parent.style.maxLines; t = 0 < e ? e : this.totalLinesCount; break; case 2: t = this.totalLinesCount }return t } }, { key: "content", get: function () { return this.sections.join(this.pageBreak) } }]), s }(); Object.assign(bk.prototype, yk); var xk = Phaser.Utils.Objects.GetFastValue, Ck = Phaser.Utils.Objects.GetValue, wk = function () { w(s, Ta); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, t, e)).timer = null, i.resetFromJSON(e), i } return k(s, [{ key: "resetFromJSON", value: function (t) { this.setTextWrapEnable(Ck(t, "wrap", !1)), this.setTypeMode(Ck(t, "typeMode", 0)), this.setTypeSpeed(Ck(t, "speed", 333)), this.setTextCallback = xk(t, "setTextCallback", null), this.setTextCallbackScope = xk(t, "setTextCallbackScope", null), this.setTypingContent(xk(t, "text", "")), this.typingIdx = xk(t, "typingIdx", 0), this.insertIdx = xk(t, "insertIdx", null); var e = xk(t, "elapsed", null); return null !== e && this.start(void 0, void 0, this.typingIdx, e), this } }, { key: "shutdown", value: function (t) { this.isShutdown || (this.freeTimer(), O(C(s.prototype), "shutdown", this).call(this, t)) } }, { key: "setTypeMode", value: function (t) { return "string" == typeof t && (t = Pk[t]), this.typeMode = t, this } }, { key: "setTypeSpeed", value: function (t) { return this.speed = t, this } }, { key: "setTextWrapEnable", value: function (t) { return void 0 === t && (t = !0), this.textWrapEnable = t, this } }, { key: "text", get: function () { return this._text }, set: function (t) { var e = Sk(t); this.textWrapEnable && (e = function (t, e) { switch (ak(t)) { case 0: t.style.syncFont(t.canvas, t.context), e = t.runWordWrap(e); break; case 1: e = t.getText(e, void 0, void 0, !0); break; case 2: e = t.setText(e).getTextBounds().wrappedText }return e }(this.parent, e)), this._text = e } }, { key: "isTyping", get: function () { return null !== this.getTimer() } }, { key: "isLastChar", get: function () { return this.typingIdx === this.textLen } }, { key: "start", value: function (t, e, i, n) { return void 0 !== t && this.setTypingContent(t), void 0 !== e && (this.speed = e), void 0 === i && (i = 0), this.typingIdx = i + 1, 0 === this.speed ? this.stop(!0) : (this.setText(""), this.startTimer(n)), this } }, { key: "appendText", value: function (t) { var e = this.text.concat(Sk(t)); return this.isTyping ? this.setTypingContent(e) : this.start(e, void 0, this.textLen), this } }, { key: "stop", value: function (t) { return this.getTimer() && this.freeTimer(), t && (this.typingIdx = this.textLen, this.setText(this.text), this.emit("type"), this.emit("complete", this, this.parent)), this } }, { key: "pause", value: function () { var t = this.getTimer(); return t && (t.paused = !0), this } }, { key: "resume", value: function () { var t = this.getTimer(); return t && (t.paused = !1), this } }, { key: "setTypingContent", value: function (t) { return this.text = t, this.textLen = this.getTextLength(this.text), this } }, { key: "onTyping", value: function () { var t = this.getTypingString(this.text, this.typingIdx, this.textLen, this.typeMode); this.setText(t), this.emit("type"), this.isLastChar ? (this.freeTimer(), this.emit("complete", this, this.parent)) : (this.timer.delay = this.speed, this.typingIdx++) } }, { key: "getTypingString", value: function (t, e, i, n) { var s; if (0 === n) { var r = 0, o = e; this.insertIdx = o, s = this.getSubString(t, r, o) } else if (1 === n) { r = (o = i) - e; this.insertIdx = 0, s = this.getSubString(t, r, o) } else if (2 === n) { var a = i / 2; o = (r = Math.floor(a - e / 2)) + e; this.insertIdx = e % 2 ? e : 0, s = this.getSubString(t, r, o) } else if (3 === n) { var h, l = Math.floor(e / 2); if (0 < l) { r = (o = i) - l; h = this.getSubString(t, r, o) } else h = ""; var u, c = e - l; if (0 < c) { o = (r = 0) + c; this.insertIdx = o, u = this.getSubString(t, r, o) } else u = "", this.insertIdx = 0; s = u + h } return s } }, { key: "startTimer", value: function (t) { var e; return this.timer && this.freeTimer(), e = void 0 === t ? 0 : (this.speed, t), this.timer = this.scene.time.addEvent({ delay: 0, startAt: e, loop: !0, callback: this.onTyping, callbackScope: this }), this } }, { key: "getTimer", value: function () { return this.timer } }, { key: "freeTimer", value: function () { return this.timer && (this.timer.remove(), this.timer = null), this } }, { key: "setText", value: function (t) { this.setTextCallback && (t = this.setTextCallbackScope ? this.setTextCallback.call(this.setTextCallbackScope, t, this.isLastChar, this.insertIdx) : this.setTextCallback(t, this.isLastChar, this.insertIdx)), this.textWrapEnable ? uk(this.parent, t) : this.parent.setText(t) } }, { key: "getTextLength", value: function (t) { var e = this.parent; return e.getPlainText ? e.getPlainText(t).length : t.length } }, { key: "getSubString", value: function (t, e, i) { var n = this.parent; return n.getSubString ? n.getSubString(t, e, i) : t.slice(e, i) } }]), s }(), Sk = function (t) { return Array.isArray(t) ? t = t.join("\n") : "number" == typeof t && (t = t.toString()), t }, Pk = { "left-to-right": 0, "right-to-left": 1, "middle-to-sides": 2, "sides-to-middle": 3 }, Tk = Phaser.Utils.Objects.GetValue, Ok = function () { w(r, sg); var s = T(r); function r(t, e) { var i; z(this, r), void 0 === e && (e = { text: Mk(t) }), (i = s.call(this, t, e)).type = "rexTextBox"; var n = i.childrenMap.text; return i.page = new bk(n, Tk(e, "page", void 0)), i.typing = new wk(n, Tk(e, "typing", e.type)), i.typing.on("complete", i.onPageEnd, j(i)).on("type", i.onType, j(i)), i.textWidth = n.width, i.textHeight = n.height, i } return k(r, [{ key: "start", value: function (t, e) { return this.page.setText(t), void 0 !== e && this.setTypeSpeed(e), this.typeNextPage(), this } }, { key: "typeNextPage", value: function () { if (this.isLastPage) this.emit("complete"); else { var t = this.page.getNextPage(); this.typing.start(t) } return this } }, { key: "pause", value: function () { return this.typing.pause(), this } }, { key: "resume", value: function () { return this.typing.resume(), this } }, { key: "stop", value: function (t) { return this.typing.stop(t), this } }, { key: "setTypeSpeed", value: function (t) { return this.typing.setTypeSpeed(t), this } }, { key: "isTyping", get: function () { return this.typing.isTyping } }, { key: "isLastPage", get: function () { return this.page.isLastPage } }, { key: "isFirstPage", get: function () { return this.page.isFirstPage } }, { key: "pageCount", get: function () { return this.page.pageCount } }, { key: "pageIndex", get: function () { return this.page.pageIndex } }, { key: "onType", value: function () { var t = this.childrenMap.text; this.textWidth === t.width && this.textHeight === t.height || (this.textWidth = t.width, this.textHeight = t.height, this.getTopmostSizer().layout()), this.emit("type") } }, { key: "onPageEnd", value: function () { this.emit("pageend"), this.isLastPage && this.emit("complete") } }]), r }(), Mk = function (t) { return t.add.text(0, 0, "", { wordWrap: { width: 200 }, maxLines: 5 }) }; c.register("textBox", function (t) { var e = new Ok(this.scene, t); return this.scene.add.existing(e), e }), R(window, "RexPlugins.UI.TextBox", Ok); var Ek = Phaser.Utils.Objects.GetValue, _k = function () { w(g, wv); var v = T(g); function g(t, e) { var i; z(this, g), (i = v.call(this, t, e)).type = "rexNumberBar"; var n, s = Ek(e, "background", void 0), r = Ek(e, "icon", void 0), o = Ek(e, "iconMask", void 0), a = Ek(e, "slider", void 0), h = Ek(e, "text", void 0), l = Ek(e, "space.icon", 0), u = Ek(e, "space.slider", 0); s && i.addBackground(s), r && (0 === i.orientation ? (a || h) && (c = { right: l }) : (a || h) && (c = { bottom: l }), i.add(r, { proportion: 0, align: "center", padding: c }), o = o && ig.call(j(i), r, r, 1)); if (a) { var c, d; if (a.orientation = i.orientation, a.eventEmitter = j(i), a.value = null, a.hasOwnProperty("input") || (a.input = -1), n = new xy(t, a), t.add.existing(n), 0 === i.orientation ? h && (c = { right: u }) : h && (c = { bottom: u }), 0 === i.orientation) d = void 0 === Ek(a, "width", void 0) ? 1 : 0; else d = void 0 === Ek(a, "height", void 0) ? 1 : 0; i.add(n, { proportion: d, align: "center", padding: c }) } h && i.add(h), i.addChildrenMap("background", s), i.addChildrenMap("icon", r), i.addChildrenMap("iconMask", o), i.addChildrenMap("slider", n), i.addChildrenMap("text", h); var f = Ek(e, "valuechangeCallback", null); if (null !== f) { var p = Ek(e, "valuechangeCallbackScope", void 0); i.on("valuechange", f, p) } return i.setEnable(Ek(e, "enable", void 0)), i.setValue(Ek(e, "value", 0)), i } return k(g, [{ key: "enable", get: function () { return !!this.childrenMap.slider && this.childrenMap.slider.enable }, set: function (t) { this.childrenMap.slider && this.childrenMap.slider.setEnable(t) } }, { key: "setEnable", value: function (t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "value", get: function () { return this.childrenMap.slider ? this.childrenMap.slider.value : 0 }, set: function (t) { this.childrenMap.slider && (this.childrenMap.slider.value = t) } }, { key: "setValue", value: function (t, e, i) { return this.childrenMap.slider && this.childrenMap.slider.setValue(t, e, i), this } }, { key: "addValue", value: function (t, e, i) { return this.childrenMap.slider && this.childrenMap.slider.addValue(t, e, i), this } }, { key: "getValue", value: function (t, e) { return this.childrenMap.slider ? this.childrenMap.slider.getValue(t, e) : 0 } }, { key: "easeValueTo", value: function (t, e, i) { return this.childrenMap.slider && this.childrenMap.slider.easeValueTo(t, e, i), this } }, { key: "stopEaseValue", value: function () { return this.childrenMap.slider && this.childrenMap.slider.stopEaseValue(), this } }, { key: "setEaseValueDuration", value: function (t) { return this.childrenMap.slider && this.childrenMap.slider.setEaseValueDuration(t), this } }, { key: "setEaseValueFunction", value: function (t) { return this.childrenMap.slider && this.childrenMap.slider.setEaseValueFunction(t), this } }, { key: "text", get: function () { var t = this.childrenMap.text; return void 0 === t ? "" : t.text ? t.text : t.getData("text") }, set: function (t) { var e = this.childrenMap.text; void 0 !== e && (e.setText ? e.setText(t) : e.setData("text", t)) } }, { key: "setText", value: function (t) { return this.text = t, this } }]), g }(); c.register("numberBar", function (t) { var e = new _k(this.scene, t); return this.scene.add.existing(e), e }), R(window, "RexPlugins.UI.NumberBar", _k), c.register("scrollBar", function (t) { var e = new My(this.scene, t); return this.scene.add.existing(e), e }), R(window, "RexPlugins.UI.ScrollBar", My); var Bk = Phaser.Utils.Objects.GetValue, Ik = { leftTop: "left-top", centerTop: "center-top", rightTop: "right-top", leftCenter: "left-center", center: "center", rightCenter: "right-center", leftBottom: "left-bottom", centerBottom: "center-bottom", rightBottom: "right-bottom" }, Rk = function () { w(h, Gf); var a = T(h); function h(t, e) { var i; z(this, h), (i = a.call(this, t, e)).type = "rexBadge"; var n = Bk(e, "background", void 0); n && i.addBackground(n), i.addChildrenMap("background", n); var s = Bk(e, "main", void 0); for (var r in s && i.add(s, { key: "main", align: "center", expand: !1 }), i.addChildrenMap("main", s), Ik) { var o = Bk(e, r, void 0); o && (i.add(o, { key: r, align: Ik[r], expand: !1 }), i.addChildrenMap(r, o)) } return i } return k(h) }(); c.register("badgeLabel", function (t) { var e = new Rk(this.scene, t); return this.scene.add.existing(e), e }), R(window, "RexPlugins.UI.BadgeLabel", Rk); function Ak(t, e, i, n, s, r, o, a, h) { return t.setVisible(!1), Dk.call(this, t, e, i, n, s, r, o, a, h), this } var Dk = Gf.prototype.add, Lk = { add: Ak, addPage: Ak }, zk = dr.prototype.setChildVisible, jk = { getPage: function (t) { return void 0 !== t && this.sizerChildren.hasOwnProperty(t) ? this.sizerChildren[t] : null }, swapPage: function (t) { this._previousKey = this._currentKey; var e = this.previousPage; e && (0 === this.swapMode ? (zk.call(this, e, !1), this.emit("pageinvisible", e, this._previousKey, this)) : e.destroy()), t && !this.sizerChildren.hasOwnProperty(t) && this.emit("createpage", t, this), this._currentKey = t; var i = this.currentPage; return i && (zk.call(this, i, !0), this.emit("pagevisible", i, this._currentKey, this), 0 < this.fadeInDuration && i.setAlpha(0).fadeIn(this.fadeInDuration, 1)), this }, hasPage: function (t) { return this.sizerChildren.hasOwnProperty(t) } }; Object.assign(jk, Lk); var Fk = Phaser.Utils.Objects.GetValue, Yk = function () { w(s, Gf); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, t, e)).type = "rexPages", i.childrenMap = i.sizerChildren, i._previousKey = void 0, i._currentKey = void 0, i.setSwapMode(Fk(e, "swapMode", 0)), i.setFadeInDuration(Fk(e, "fadeIn", 0)), i } return k(s, [{ key: "setSwapMode", value: function (t) { return "string" == typeof t && (t = Wk[t]), this.swapMode = t, this } }, { key: "setFadeInDuration", value: function (t) { return this.fadeInDuration = t, this } }, { key: "previousKey", get: function () { return this._previousKey } }, { key: "currentKey", get: function () { return this._currentKey }, set: function (t) { this.swapPage(t) } }, { key: "currentPage", get: function () { return this.getPage(this.currentKey) } }, { key: "previousPage", get: function () { return this.getPage(this.previousKey) } }, { key: "keys", get: function () { return Object.keys(this.sizerChildren) } }]), s }(); Object.assign(Yk.prototype, jk); var Wk = { invisible: 0, destroy: 1 }; c.register("pages", function (t) { var e = new Yk(this.scene, t); return this.scene.add.existing(e), e }), R(window, "RexPlugins.UI.Pages", Yk); var Vk = Phaser.Utils.Objects.IsPlainObject, Xk = Phaser.Utils.Objects.GetValue, Gk = Phaser.Utils.String.UUID, Uk = { swapPage: function (t) { var e; return null != (e = "number" == typeof t ? t : this.getPageIndex(t)) && this.childrenMap.tabs.emitButtonClick(e), this }, swapFirstPage: function () { return this.swapPage(0), this }, swapLastPage: function () { return this.swapPage(this.getElement("tabs.buttons").length - 1), this } }, Hk = { removePage: function (t, e) { "number" == typeof t && (t = this.getPageKey(t)); var i = this.childrenMap.tabs, n = i.getByName(t), s = this.childrenMap.pages, r = s.getElement(t); return n && r && (s.removeChildrenMap(t), i.removeButton(n, e), s.remove(r, e)), this } }, Nk = { getPageKey: function (t) { var e = this.getElement("tabs.buttons"); if (!(t >= e.length)) return e[t].name }, getPageIndex: function (t) { for (var e = this.getElement("tabs.buttons"), i = 0, n = e.length; i < n; i++)if (e[i].name === t) return i }, addPage: function (t, e, i) { if (Vk(t)) { var n = t; t = Xk(n, "key"), e = Xk(n, "tab"), i = Xk(n, "page") } return t = t || Gk(), e.name = t, this.childrenMap.tabs.addButton(e), this.childrenMap.pages.addPage(i, { key: t }), this }, getPage: function (t) { return "number" == typeof t && (t = this.getPageKey(t)), this.childrenMap.pages.getPage(t) }, getTab: function (t) { var e; return e = "number" == typeof t ? t : this.getPageIndex(t), this.getElement("tabs.buttons")[e] } }; Object.assign(Nk, Uk, Hk); var Jk = Phaser.Utils.Objects.GetValue, Kk = wv.prototype.add, qk = function () { w(g, wv); var v = T(g); function g(t, e) { var i; z(this, g), void 0 === e && (e = {}); var n = Jk(e, "tabPosition", "top"), s = "left" === n || "right" === n ? "x" : "y"; e.orientation = s, (i = v.call(this, t, e)).type = "rexTabPages"; var r = Jk(e, "background", void 0); r && i.addBackground(r); var o = Jk(e, "pages"), a = new Yk(t, o); t.add.existing(a); var h = "y" == s, l = h && Jk(e, "wrapTabs", !1), u = Jk(e, "tabs", void 0); void 0 === u && (u = {}); var c = l ? Vg : Pg; u.orientation = h ? "x" : "y", u.buttonsType = "radio"; var d = new c(t, u); t.add.existing(d); var f = !!l || Jk(e, "expand.tabs", !1), p = Jk(e, "align.tabs", "left"); switch (n) { case "top": case "left": Kk.call(j(i), d, { proportion: 0, expand: f, align: p }), Kk.call(j(i), a, { proportion: 1, expand: !0 }); break; case "bottom": case "right": Kk.call(j(i), a, { proportion: 1, expand: !0 }), Kk.call(j(i), d, { proportion: 0, expand: f, align: p }) }return i.addChildrenMap("background", r), i.addChildrenMap("tabs", d), i.addChildrenMap("pages", a), d.on("button.click", function (t) { var e = t.name; a.hasPage(e) && a.swapPage(e) }), d.on("button.statechange", function (t, e, i, n) { var s = i ? "tab.focus" : "tab.blur"; this.emit(s, t, t.name) }, j(i)), a.on("pagevisible", function (t, e, i) { this.emit("page.focus", t, e) }), a.on("pageinvisible", function (t, e, i) { this.emit("page.blur", t, e) }), i } return k(g, [{ key: "currentKey", get: function () { return this.getElement("pages").currentKey }, set: function (t) { this.showPage(t) } }, { key: "keys", get: function () { return this.getElement("pages").keys } }, { key: "currentPage", get: function () { return this.getElement("pages").currentPage } }, { key: "previousPage", get: function () { return this.getElement("pages").previousPage } }]), g }(); Object.assign(qk.prototype, Nk), c.register("tabPages", function (t) { var e = new qk(this.scene, t); return this.scene.add.existing(e), e }), R(window, "RexPlugins.UI.TabPages", qk); function $k(t) { return (t - this.textLineSpacing) / (this.textLineHeight + this.textLineSpacing) } function Zk(t) { return t * (this.textLineHeight + this.textLineSpacing) - this.textLineSpacing } function Qk() { var t = this.textObject.rexSizer; this.textObject.y += t.offsetY - t.preOffsetY, t.preOffsetY = t.offsetY, this.resetChildPositionState(this.textObject), this.textCropEnable && tb.call(this) } var tb = function () { if (this.textObject.setCrop) { var t, e, i = this.textObject.rexSizer.offsetY; e = i <= 0 ? (t = -i, this.height) : (t = 0, this.height - i), this.textObject.setCrop(0, t, this.width, e) } }, eb = { setText: function (t) { return void 0 !== t && (this.text = t), this.lines = hk(this.textObject, this.text, this.lines), this.linesCount = this.lines.length, this._textHeight = void 0, this._textVisibleHeight = void 0, this.updateTextObject(), this }, updateTextObject: function () { var t = Math.max(Math.floor($k.call(this, -this.textOY)), 0), e = Zk.call(this, t) + this.textOY, i = function (t) { var e, i = t + this.visibleLinesCount + 1; switch (this.textObjectType) { case 0: e = this.lines.slice(t, i).join("\n"); break; case 1: var n = this.lines.getLineStartIndex(t), s = this.lines.getLineEndIndex(i - 1); e = this.lines.getSliceTagText(n, s, !0); break; case 2: e = this.lines.slice(t, i).join("\n") }return e }.call(this, t); return uk(this.textObject, i), this.textObject.rexSizer.offsetY = e, Qk.call(this), this }, preLayout: function () { return this._textLineHeight = void 0, this._textLineSpacing = void 0, this._visibleLinesCount = void 0, this._textHeight = void 0, this._textVisibleHeight = void 0, vu.call(this), this }, layoutChildren: function () { var t, e, i, n, s, r, o, a = this.left, h = this.top; (t = this.textObject).rexSizer.hidden || (n = a + (i = (e = t.rexSizer).padding).left, s = h + i.top, r = this.width - i.left - i.right, o = this.height - i.top - i.bottom, function (t, e, i) { if (i += this.textLineHeight + this.textLineSpacing, this.textObjectWidth !== e || this._textObjectRealHeight !== i) { switch (this.textObjectWidth = e, this._textObjectRealHeight = i, this.textObjectType) { case 0: case 1: t.setFixedSize(e, i); var n = t.style, s = Math.max(e, 0); 0 === this.textObjectType ? n.wordWrapWidth = s : (0 === n.wrapMode && (n.wrapMode = 1), n.wrapWidth = s); break; case 2: t.setMaxWidth(e) }this.setText() } }.call(this, t, r, o), hu(t, n, s, r, o, e.align), e.preOffsetY = 0, Qk.call(this), this.textMask && (this.textMask.setPosition().resize(), this.resetChildPositionState(this.textMask))) } }, ib = Phaser.Utils.Objects.IsPlainObject, nb = Phaser.Utils.Objects.GetValue, sb = Phaser.Display.Align.TOP_LEFT, rb = function () { w(d, Of); var c = T(d); function d(t, e, i, n, s, r) { var o; z(this, d), ib(e) ? (e = nb(r = e, "x", 0), i = nb(r, "y", 0), n = nb(r, "width", void 0), s = nb(r, "height", void 0)) : ib(n) && (n = nb(r = n, "width", void 0), s = nb(r, "height", void 0)), (o = c.call(this, t, e, i, n, s, r)).type = "rexTextBlock", o.textObject = void 0, o.linesCount = 0, o.textMask = void 0, o.textObjectType = void 0, o._textLineHeight = void 0, o._textLineSpacing = void 0, o._visibleLinesCount = void 0, o._textHeight = void 0, o._textVisibleHeight = void 0, o.lines = void 0, o.text = nb(r, "content", ""), o._textOY = 0, o.execeedTopState = !1, o.execeedBottomState = !1, o.setClampMode(nb(r, "clamplTextOY", !0)), o.alwaysScrollable = nb(r, "alwaysScrollable", !1); var a = nb(r, "background", void 0), h = nb(r, "text", void 0); void 0 === h && (h = ob(t)), o.textCropEnable = nb(r, "textCrop", !!h.setCrop); var l = nb(r, "textMask", !o.textCropEnable); a && o.addBackground(a), o.add(h), o.sizerChildren = [h]; var u = o.getSizerConfig(h); return u.align = sb, u.padding = uu(0), u.expand = !0, o.textObject = h, o.textObjectType = ak(h), u.preOffsetY = 0, u.offsetY = 0, l && (o.textMask = ig.call(j(o), o.textObject, j(o))), o.addChildrenMap("background", a), o.addChildrenMap("text", h), o } return k(d, [{ key: "destroy", value: function (t) { if (this.scene) { if (this.textObject = void 0, this.textMask = void 0, this.lines) { switch (this.textObjectType) { case 0: this.lines.length = 0; break; case 1: this.lines.destroy(); break; case 2: this.lines.length = 0 }this.lines = void 0 } O(C(d.prototype), "destroy", this).call(this, t) } } }, { key: "setClampMode", value: function (t) { return void 0 === t && (t = !0), this.clampTextOY = t, this } }, { key: "textLineHeight", get: function () { if (void 0 === this._textLineHeight) { var t; switch (this.textObjectType) { case 0: case 1: var e = this.textObject.style; t = e.metrics.fontSize + e.strokeThickness; break; case 2: var i = this.textObject.fontSize / this.textObject.fontData.size; t = this.textObject.fontData.lineHeight * i }this._textLineHeight = t } return this._textLineHeight } }, { key: "textLineSpacing", get: function () { if (void 0 === this._textLineSpacing) { var t; switch (this.textObjectType) { case 0: case 1: t = this.textObject.lineSpacing; break; case 2: t = 0 }this._textLineSpacing = t } return this._textLineSpacing } }, { key: "visibleLinesCount", get: function () { return void 0 === this._visibleLinesCount && (this._visibleLinesCount = Math.floor($k.call(this, this._textObjectRealHeight))), this._visibleLinesCount } }, { key: "topTextOY", get: function () { return 0 } }, { key: "bottomTextOY", get: function () { return -this.textVisibleHeight } }, { key: "textHeight", get: function () { return void 0 === this._textHeight && (this._textHeight = Zk.call(this, this.linesCount)), this._textHeight } }, { key: "textObjectHeight", get: function () { return this._textObjectRealHeight - (this.textLineHeight + this.textLineSpacing) } }, { key: "textVisibleHeight", get: function () { if (void 0 === this._textVisibleHeight) { var t = this.textHeight - this.textObjectHeight; !this.alwaysScrollable && t < 0 && (t = 0), this._textVisibleHeight = t } return this._textVisibleHeight } }, { key: "textOYExceedTop", value: function (t) { return void 0 === t && (t = this.textOY), t > this.topTextOY } }, { key: "textOYExeceedBottom", value: function (t) { return void 0 === t && (t = this.textOY), t < this.bottomTextOY } }, { key: "textOY", get: function () { return this._textOY }, set: function (t) { var e = this.topTextOY, i = this.bottomTextOY, n = this.textOYExceedTop(t), s = this.textOYExeceedBottom(t); this.clampTextOY && (this.visibleLinesCount > this.linesCount ? t = 0 : n ? t = e : s && (t = i)), this._textOY !== t && (this._textOY = t, this.updateTextObject()), n && (this.execeedTopState || this.emit("execeedtop", this, t, e)), this.execeedTopState = n, s && (this.execeedBottomState || this.emit("execeedbottom", this, t, i)), this.execeedBottomState = s } }, { key: "setTextOY", value: function (t) { return this.textOY = t, this } }, { key: "t", get: function () { var t = this.textVisibleHeight; return 0 === t ? 0 : this.textOY / -t }, set: function (t) { this.textOY = -this.textVisibleHeight * t } }, { key: "setTextOYByPercentage", value: function (t) { return this.t = t, this } }]), d }(), ob = function (t) { return t.add.text(0, 0, "") }; Object.assign(rb.prototype, eb); var ab = Phaser.Utils.Objects.GetValue, hb = function () { w(v, Ky); var p = T(v); function v(t, e) { var i; z(this, v), void 0 === e && (e = {}); var n = ab(e, "text", void 0), s = ab(e, "textWidth", void 0), r = ab(e, "textHeight", void 0), o = ab(e, "textCrop", !!n.setCrop), a = ab(e, "textMask", !o), h = ab(e, "content", ""), l = new rb(t, { width: s, height: r, text: n, textMask: a, textCrop: o && !a, content: h, clamplTextOY: ab(e, "clamplChildOY", !1), alwaysScrollable: ab(e, "alwaysScrollable", !1) }); t.add.existing(l); var u, c = void 0 === s ? 1 : 0, d = void 0 === r; u = l, Object.defineProperty(u, "childOY", { configurable: !0, get: function () { return u.textOY }, set: function (t) { u.textOY = t } }), Object.defineProperty(u, "topChildOY", { get: function () { return u.topTextOY } }), Object.defineProperty(u, "bottomChildOY", { get: function () { return u.bottomTextOY } }), Object.defineProperty(u, "childVisibleHeight", { get: function () { return u.textObjectHeight } }), Object.defineProperty(u, "childHeight", { get: function () { return u.textHeight } }), e.scrollMode = 0, e.type = "rexTextArea", e.child = { gameObject: l, proportion: c, expand: d }; var f = ab(e, "space", void 0); return f && (f.child = f.text), (i = p.call(this, t, e)).addChildrenMap("text", n), i } return k(v, [{ key: "text", get: function () { return this.childrenMap.child.text } }, { key: "linesCount", get: function () { return this.childrenMap.child.linesCount } }, { key: "contentHeight", get: function () { return this.childrenMap.child.textHeight } }]), v }(), lb = { setText: function (t) { return this.childrenMap.child.setText(t), this.resizeController(), this }, appendText: function (t) { return this.setText(this.text + t), this } }; Object.assign(hb.prototype, lb), c.register("textArea", function (t) { var e = new hb(this.scene, t); return this.scene.add.existing(e), e }), R(window, "RexPlugins.UI.TextArea", hb); var ub = { getChildrenWidth: function () { if (this.rexSizer.hidden) return 0; var t = this.child; return !t.rexSizer.hidden && 0 === this.scrollMode ? this.getChildWidth(t) : 0 }, getChildrenHeight: function () { if (this.rexSizer.hidden) return 0; var t = this.child; return t.rexSizer.hidden || 0 === this.scrollMode ? 0 : t.isRexSizer ? Math.max(t.minHeight, t.childrenHeight) : t.hasOwnProperty("minHeight") ? t.minHeight : Fl(t) }, getChildrenSizers: function (t) { return void 0 === t && (t = []), this.child && this.child.isRexSizer && t.push(this.child), t }, resetChildPosition: function () { var t = this.left, e = this.top; 0 === this.scrollMode ? e += this.childOY : t += this.childOY, this.child.setPosition(t, e), this.resetChildPositionState(this.child), this.setMaskChildrenFlag() }, layoutChildren: function () { var t, e, i = this.child; i.rexSizer.hidden || (0 === this.scrollMode ? t = this.width : e = this.height, i.isRexSizer ? i.runLayout(this, t, e) : Lu(i, t, e), this.resetChildPosition(), this.layoutChildrenMask(), this.maskChildren()) } }; Object.assign(ub, vm); var cb = Phaser.Utils.Objects.IsPlainObject, db = Phaser.Utils.Objects.GetValue, fb = Phaser.Display.Align.TOP_LEFT, pb = function () { w(c, Of); var u = T(c); function c(t, e, i, n, s, r) { var o; z(this, c), cb(e) ? (e = db(r = e, "x", 0), i = db(r, "y", 0), n = db(r, "width", void 0), s = db(r, "height", void 0)) : cb(n) && (n = db(r = n, "width", void 0), s = db(r, "height", void 0)), (o = u.call(this, t, e, i, n, s, r)).type = "rexScrollableBlock", o.child = void 0, o.childrenMask = void 0, o._childOY = 0, o.execeedTopState = !1, o.execeedBottomState = !1, o.setScrollMode(db(r, "scrollMode", !0)), o.setClampMode(db(r, "clamplChildOY", !0)); var a = db(r, "child", void 0), h = db(r, "expand", !0); a.setOrigin && a.setOrigin(0), o.add(a), o.sizerChildren = [a]; var l = o.getSizerConfig(a); return l.align = fb, l.expand = h, o.child = a, o.setupChildrenMask(db(r, "mask", void 0)), o } return k(c, [{ key: "destroy", value: function (t) { this.scene && (this.destroyChildrenMask(), this.child = void 0, O(C(c.prototype), "destroy", this).call(this, t)) } }, { key: "setScrollMode", value: function (t) { return "string" == typeof t && (t = Py[t.toLowerCase()]), this.scrollMode = t, this } }, { key: "setClampMode", value: function (t) { return void 0 === t && (t = !0), this.clampChildOY = t, this } }, { key: "instHeight", get: function () { return 0 === this.scrollMode ? this.height : this.width } }, { key: "instWidth", get: function () { return 0 === this.scrollMode ? this.width : this.height } }, { key: "childHeight", get: function () { return (0 === this.scrollMode ? Fl : jl)(this.child) } }, { key: "childWidth", get: function () { return (0 === this.scrollMode ? jl : Fl)(this.child) } }, { key: "topChildOY", get: function () { return 0 } }, { key: "bottomChildOY", get: function () { return -this.visibleHeight } }, { key: "childVisibleHeight", get: function () { return this.instHeight } }, { key: "visibleHeight", get: function () { var t = this.childHeight - this.childVisibleHeight; return t < 0 && (t = 0), t } }, { key: "childOYExceedTop", value: function (t) { return void 0 === t && (t = this.childOY), t > this.topChildOY } }, { key: "childOYExeceedBottom", value: function (t) { return void 0 === t && (t = this.childOY), t < this.bottomChildOY } }, { key: "childOY", get: function () { return this._childOY }, set: function (t) { var e = this.topChildOY, i = this.bottomChildOY, n = this.childOYExceedTop(t), s = this.childOYExeceedBottom(t); this.clampChildOY && (this.childVisibleHeight > this.childHeight ? t = 0 : n ? t = e : s && (t = i)), this._childOY !== t && (this._childOY = t, this.resetChildPosition()), n && (this.execeedTopState || this.emit("execeedtop", this, t, e)), this.execeedTopState = n, s && (this.execeedBottomState || this.emit("execeedbottom", this, t, i)), this.execeedBottomState = s } }, { key: "setChildOY", value: function (t) { return this.childOY = t, this } }, { key: "t", get: function () { var t = this.visibleHeight; return 0 === t ? 0 : this.childOY / -t }, set: function (t) { this.childOY = -this.visibleHeight * t } }, { key: "setChildOYByPercentage", value: function (t) { return this.t = t, this } }]), c }(); Object.assign(pb.prototype, ub); var vb = Phaser.Utils.Objects.GetValue, gb = function () { w(d, Ky); var c = T(d); function d(t, e) { var i; z(this, d), void 0 === e && (e = {}); var n = Sy(e), s = vb(e, "panel", void 0); void 0 === s && (s = {}), s.scrollMode = n, s.clamplChildOY = vb(e, "clamplChildOY", !1); var r = new pb(t, s); t.add.existing(r); var o, a, h = vb(s, "width", void 0), l = vb(s, "height", void 0); a = 0 === n ? (o = void 0 === h ? 1 : 0, void 0 === l) : (o = void 0 === l ? 1 : 0, void 0 === h), e.type = "rexScrollablePanel", e.child = { gameObject: r, proportion: o, expand: a }; var u = vb(e, "space", void 0); return u && (u.child = u.panel), (i = c.call(this, t, e)).addChildrenMap("panel", r.child), i.addChildrenMap("panelLayer", r.maskLayer), i } return k(d, [{ key: "setChildrenInteractive", value: function (t) { return void 0 === t && (t = {}), t.hasOwnProperty("eventEmitter") || (t.eventEmitter = this), t.hasOwnProperty("targets") || (t.targets = [this.childrenMap.panel]), yf(this.childrenMap.child, t), this } }]), d }(); c.register("scrollablePanel", function (t) { var e = new gb(this.scene, t); return this.scene.add.existing(e), e }), R(window, "RexPlugins.UI.ScrollablePanel", gb); function yb(t, e, i, n) { void 0 === i && (i = 0), void 0 === n && (n = e.length), t.length = n - i; for (var s = 0, r = t.length; s < r; s++)t[s] = e[s + i]; return t } function mb(t, e, i) { var n, s = wb(i, "reverse", !1); if (Ru(t[0])) if (s) for (r = (o = t.length) - 1; 0 <= r; r--)n = mb(t[r], e, i); else for (var r = 0, o = t.length; r < o; r++)n = mb(t[r], e, i); else n = Sb(t, e, i); return n } var kb = function (t, e) { t.popUp(e) }, bb = function (t, e) { t.scaleDown(e) }, xb = function (t, e) { t.fadeIn(e) }, Cb = function (t, e) { t.fadeOut(e) }, wb = Phaser.Utils.Objects.GetValue, Sb = function (t, e, i) { var n, s = wb(i, "argsConvert", void 0), r = wb(i, "argsConvertScope", void 0), o = t[0]; if (Pb = yb(Pb, t, 1), s) { !0 === s && (s = oo, r = void 0); for (var a = 0, h = Pb.length; a < h; a++)Pb[a] = r ? s.call(r, Pb[a], t) : s(Pb[a], t) } return "string" == typeof o ? null == (n = e[o]) && (n = wb(e, o, null)) : n = o, n.apply(e, Pb) }, Pb = [], Tb = Phaser.Utils.Objects.GetValue, Ob = function () { w(r, Ta); var s = T(r); function r(t, e) { var i; z(this, r), i = s.call(this, t, e); var n = Tb(e, "clock", void 0); return n = n || new Ia(t), i.clock = n, i.clock.on("update", i.update, j(i)), i.resetFromJSON(e), i } return k(r, [{ key: "resetFromJSON", value: function (t) { return this.clock.resetFromJSON(Tb(t, "clock", void 0)), this.state = Tb(t, "state", 0), this.commands = Tb(t, "commands", []), this.scope = Tb(t, "scope", void 0), this.setTimeUnit(Tb(t, "timeUnit", 0)), this.setDtMode(Tb(t, "dtMode", 0)), this.index = Tb(t, "index", 0), this.nextTime = Tb(t, "nextTime", 0), this } }, { key: "toJSON", value: function () { return { clock: this.clock.toJSON(), state: this.state, commands: this.commands, scope: this.scope, timeUnit: this.timeUnit, dtMode: this.dtMode, index: this.index, nextTime: this.nextTime } } }, { key: "shutdown", value: function (t) { this.isShutdown || (this.clock.shutdown(t), this.commands = void 0, O(C(r.prototype), "shutdown", this).call(this, t)) } }, { key: "load", value: function (t, e, i) { this.stop(); var n = Tb(i, "timeUnit", void 0); void 0 !== n && this.setTimeUnit(n); var s = Tb(i, "dtMode", void 0); return void 0 !== s && this.setDtMode(s), t = t.filter(function (t) { var e = t[0]; return !isNaN(e) }).map(function (t) { return "string" == typeof t[0] && (t[0] = parseFloat(t[0])), t }), 0 === this.dtMode && t.sort(function (t, e) { var i = t[0], n = e[0]; return n < i ? 1 : i < n ? -1 : 0 }), this.commands = t, this.scope = e, this } }, { key: "start", value: function (t) { return void 0 === t && (t = 0), this.stop(), this.index = 0, this.state = 1, this.nextTime = this.getNextDt(0), this.clock.start(t), this.update(t), this.emit("start", this.parent, this), this } }, { key: "pause", value: function () { return this.clock.pause(), this.emit("pause", this.parent, this), this } }, { key: "resume", value: function () { return this.clock.resume(), this.emit("resume", this.parent, this), this } }, { key: "stop", value: function () { return this.clock.stop(), this.state = 0, this.emit("stop", this.parent, this), this } }, { key: "seek", value: function (t) { return this.clock.seek(t), this } }, { key: "isPlaying", get: function () { return this.clock.isRunning } }, { key: "completed", get: function () { return 2 === this.state } }, { key: "timeScale", get: function () { return this.clock.timeScale }, set: function (t) { this.clock.timeScale = t } }, { key: "setTimeScale", value: function (t) { return this.timeScale = t, this } }, { key: "now", get: function () { return this.clock.now } }, { key: "update", value: function (t) { if (this.nextTime > t) return this; for (var e = this.commands.length - 1; ;) { var i = this.commands[this.index], n = i[1]; if (Ru(n) || (n = yb(Mb, i, 1)), mb(n, this.scope), this.emit("runcommand", n, this.scope), this.index === e) return this.complete(), this; if (this.index++, this.nextTime = this.getNextDt(this.nextTime), this.nextTime > t) return this } } }, { key: "complete", value: function () { this.clock.stop(), this.state = 2, this.emit("complete", this.parent, this) } }, { key: "getNextDt", value: function (t) { var e = this.commands[this.index][0]; return 1 === this.timeUnit && (e *= 1e3), 1 === this.dtMode && (e += t), e } }, { key: "setDtMode", value: function (t) { return "string" == typeof t && (t = _b[t]), this.dtMode = t, this } }, { key: "setTimeUnit", value: function (t) { return "string" == typeof t && (t = Eb[t]), this.timeUnit = t, this } }]), r }(), Mb = [], Eb = { ms: 0, s: 1, sec: 1 }, _b = { abs: 0, absolute: 0, inc: 1, increment: 1 }, Bb = Phaser.Utils.Objects.GetValue, Ib = function () { w(s, sg); var n = T(s); function s(t, e) { var i; return z(this, s), void 0 === e && (e = { text: createDefaultTextObject(t) }), (i = n.call(this, t, e)).type = "rexToast", i.setTransitInTime(Bb(e, "duration.in", 200)), i.setDisplayTime(Bb(e, "duration.hold", 1200)), i.setTransitOutTime(Bb(e, "duration.out", 200)), i.setTransitInCallback(Bb(e, "transitIn", Rb.popUp)), i.setTransitOutCallback(Bb(e, "transitOut", Rb.scaleDown)), i.player = new Ob(j(i), { dtMode: 1 }), i.messages = [], i.scaleX0 = void 0, i.scaleY0 = void 0, i.setVisible(!1), i } return k(s, [{ key: "destroy", value: function (t) { this.scene && (this.player.destroy(), this.player = void 0, this.messages = void 0, O(C(s.prototype), "destroy", this).call(this, t)) } }, { key: "setDisplayTime", value: function (t) { return this.displayTime = t, this } }, { key: "setTransitOutTime", value: function (t) { return this.transitOutTime = t, this } }, { key: "setTransitInTime", value: function (t) { return this.transitInTime = t, this } }, { key: "setTransitInCallback", value: function (t) { switch ("string" == typeof t && (t = Rb[t]), t) { case Rb.popUp: t = kb; break; case Rb.fadeIn: t = xb }return t = t || _, this.transitInCallback = t, this } }, { key: "setTransitOutCallback", value: function (t) { switch ("string" == typeof t && (t = Rb[t]), t) { case Rb.scaleDown: t = bb; break; case Rb.fadeOut: t = Cb }return t = t || _, this.transitOutCallback = t, this } }, { key: "setScale", value: function (t, e) { return void 0 === e && (e = t), this.scaleX0 = t, this.scaleY0 = e, O(C(s.prototype), "setScale", this).call(this, t, e), this } }, { key: "showMessage", value: function (t) { if (void 0 === this.scaleX0 && (this.scaleX0 = this.scaleX), void 0 === this.scaleY0 && (this.scaleY0 = this.scaleY), void 0 === t) { if (0 === this.messages.length) return this; t = this.messages.shift() } if (this.player.isPlaying) return this.messages.push(t), this; this.setScale(this.scaleX0, this.scaleY0).setVisible(!0), "string" == typeof t ? this.setText(t) : t(this), this.layout(); var e = [[0, [this.transitInCallback, this, this.transitInTime]], [this.transitInTime, [_]], [this.displayTime, [this.transitOutCallback, this, this.transitOutTime]], [this.transitOutTime, [this.setVisible, !1]], [30, [_]]]; return this.player.load(e, this).once("complete", function () { this.showMessage() }, this).start(), this } }]), s }(), Rb = { popUp: 0, fadeIn: 1, scaleDown: 0, fadeOut: 1 }; c.register("toast", function (t) { var e = new Ib(this.scene, t); return this.scene.add.existing(e), e }), R(window, "RexPlugins.UI.Toast", Ib); function Ab(s, r) { return function (t, e, i, n) { "panel" !== e && i.moveChild(t, n ? 0 : s, r) } } function Db(s, r) { return function (t, e, i, n) { "panel" === e && i.moveChild(t, n ? 0 : s, r) } } var Lb = { visible: { show: function () { return function (t, e, i, n) { "panel" !== e && i.setChildVisible(t, !0) } }, hide: function () { return function (t, e, i, n) { "panel" !== e && i.setChildVisible(t, !1) } } }, fade: { show: function (s, r) { return void 0 === r && (r = 1), function (t, e, i, n) { "panel" !== e && i.fadeChild(t, n ? 0 : s, r) } }, hide: function (s, r) { return void 0 === r && (r = 0), function (t, e, i, n) { "panel" !== e && i.fadeChild(t, n ? 0 : s, r) } } }, move: { show: Ab, hide: Ab }, "move-panel": { show: Db, hide: Db } }, zb = dr.prototype.setChildVisible, jb = { setChildVisible: function (t, e) { if ("string" == typeof t) { var i = t; t = this.sizerChildren[i] } else i = Wf(this.sizerChildren, t); return void 0 === e && (e = this.currentChildKey === i), zb.call(this, t, e), this } }, Fb = { fadeChild: function (t, e, i) { var n; return "string" == typeof t ? (n = t, t = this.sizerChildren[n]) : n = Wf(this.sizerChildren, t), void 0 === e && (e = 500), void 0 === i && (i = this.currentChildKey === n ? 1 : 0), t.fadeIn(e, { start: t.alpha, end: i }), this }, fadeChildPromise: function (t, e, i) { return "string" == typeof t && (t = this.sizerChildren[key]), this.fadeChild(t, e, i), t._fade ? _o(t._fade) : Promise.resolve() } }, Yb = { moveChild: function (t, e, i, n) { var s; "string" == typeof t ? (s = t, t = this.sizerChildren[s]) : s = Wf(this.sizerChildren, t), void 0 === e && (e = 500); var r, o, a, h, l = this.currentChildKey === s; if (void 0 === n) switch (s) { case "leftSide": case "rightSide": n = jl(t); break; case "topSide": case "bottomSide": n = Fl(t); break; default: if (l) switch (this.previousChildKey) { case "leftSide": case "rightSide": n = jl(this.sizerChildren[this.previousChildKey]); break; case "topSide": case "bottomSide": n = Fl(this.sizerChildren[this.previousChildKey]); break; default: n = 0 } else switch (this.currentChildKey) { case "leftSide": case "rightSide": n = jl(this.sizerChildren[this.currentChildKey]); break; case "topSide": case "bottomSide": n = Fl(this.sizerChildren[this.currentChildKey]); break; default: n = 0 } }if (l) switch (s) { case "panel": switch (this.previousChildKey) { case "leftSide": r = !0; break; case "rightSide": o = !0; break; case "topSide": a = !0; break; case "bottomSide": h = !0 }break; case "leftSide": o = !0; break; case "rightSide": r = !0; break; case "topSide": h = !0; break; case "bottomSide": a = !0 } else switch (s) { case "panel": switch (this.currentChildKey) { case "leftSide": o = !0; break; case "rightSide": r = !0; break; case "topSide": h = !0; break; case "bottomSide": a = !0 }break; case "leftSide": r = !0; break; case "rightSide": o = !0; break; case "topSide": a = !0; break; case "bottomSide": h = !0 }return r ? t.moveTo(e, "-=".concat(n), void 0, i) : o ? t.moveTo(e, "+=".concat(n), void 0, i) : a ? t.moveTo(e, void 0, "-=".concat(n), i) : h ? t.moveTo(e, void 0, "+=".concat(n), i) : t.moveTo(0), this }, moveChildPromise: function (t, e, i, n) { return "string" == typeof t && (t = this.sizerChildren[key]), this.moveChild(t, e, i, n), t._easeMove ? _o(t._easeMove) : Promise.resolve() } }, Wb = {}; Object.assign(Wb, jb, Fb, Yb); var Vb = Phaser.Utils.Objects.GetValue, Xb = function () { w(C, Gf); var x = T(C); function C(t, e) { var i; z(this, C), (i = x.call(this, t, e)).type = "rexSides", i.childrenMap = i.sizerChildren, i.previousChildKey = void 0, i.currentChildKey = void 0; var n, s, r, o, a, h, l = Vb(e, "showChildCallback", void 0); if (l) if (Iu(l)) { var u = Vb(e, "showChildCallbackScope", void 0); i.on("showchild", l, u); var c = Vb(e, "hideChildCallback", void 0), d = Vb(e, "hideChildCallbackScope", void 0); i.on("hidechild", c, d) } else { var f = (h = S("string" == typeof (n = l) ? [n] : n), s = h[0], r = h.slice(1), a = Lb.hasOwnProperty(s) ? (o = Lb[s].show.apply(null, r), Lb[s].hide.apply(null, r)) : o = _, { show: o, hide: a }); i.on("showchild", f.show), i.on("hidechild", f.hide) } var p = Vb(e, "background", void 0), v = Vb(e, "panel", void 0), g = Vb(e, "leftSide", void 0), y = Vb(e, "rightSide", void 0), m = Vb(e, "topSide", void 0), k = Vb(e, "bottomSide", void 0); if (p && i.addBackground(p), v && i.add(v, "panel", "center", 0, !0), g) { var b = Vb(e, "expand.left", !0); i.add(g, "leftSide", "left-top", 0, { height: b }) } if (y) { b = Vb(e, "expand.right", !0); i.add(y, "rightSide", "right-top", 0, { height: b }) } if (m) { b = Vb(e, "expand.top", !0); i.add(m, "topSide", "left-top", 0, { width: b }) } if (k) { b = Vb(e, "expand.bottom", !0); i.add(k, "bottomSide", "left-bottom", 0, { width: b }) } return i } return k(C, [{ key: "reset", value: function () { return this.previousChildKey = void 0, this.currentChildKey = "panel", this.showChild("panel", !0), this.hideChild("leftSide", !0), this.hideChild("rightSide", !0), this.hideChild("topSide", !0), this.hideChild("bottomSide", !0), this } }]), C }(); Object.assign(Xb.prototype, { showChild: function (t, e) { var i = this.sizerChildren[t]; return i && (this.emit("showchild", i, t, this, e), this.resetChildState(i)), this }, hideChild: function (t, e) { var i = this.sizerChildren[t]; return i && (this.emit("hidechild", i, t, this, e), this.resetChildState(i)), this }, swapChild: function (t, e) { return this.currentChildKey === t || ("panel" === this.currentChildKey || "panel" === t ? (this.previousChildKey = this.currentChildKey, this.currentChildKey = t, this.hideChild(this.previousChildKey, e), this.showChild(this.currentChildKey, e)) : (this.swapChild("panel", e), this.swapChild(t, e))), this }, showPanel: function (t) { return this.swapChild("panel", t), this }, showLeftSide: function () { return this.swapChild("leftSide"), this }, showRightSide: function () { return this.swapChild("rightSide"), this }, showTopSide: function () { return this.swapChild("topSide"), this }, showBottomSide: function () { return this.swapChild("bottomSide"), this }, hideLeftSide: function () { return "leftSide" == this.currentChildKey && this.showPanel(), this }, hideRightSide: function () { return "rightSide" == this.currentChildKey && this.showPanel(), this }, hideTopSide: function () { return "topSide" == this.currentChildKey && this.showPanel(), this }, hideBottomSide: function () { return "bottomSide" == this.currentChildKey && this.showPanel(), this }, toggleLeftSide: function () { var t = "panel" !== this.currentChildKey ? "panel" : "leftSide"; return this.swapChild(t), this }, toggleRightSide: function () { var t = "panel" !== this.currentChildKey ? "panel" : "rightSide"; return this.swapChild(t), this }, toggleTopSide: function () { var t = "panel" !== this.currentChildKey ? "panel" : "topSide"; return this.swapChild(t), this }, toggleBottomSide: function () { var t = "panel" !== this.currentChildKey ? "panel" : "bottomSide"; return this.swapChild(t), this } }, Wb), c.register("sides", function (t) { var e = new Xb(this.scene, t); return this.scene.add.existing(e), e }), R(window, "RexPlugins.UI.Sides", Xb), c.register("click", function (t, e) { return new Uc(t, e) }), R(window, "RexPlugins.UI.Click", Uc), c.register("clickOutside", function (t, e) { return new Kc(t, e) }), R(window, "RexPlugins.UI.ClickOutside", Kc), c.register("inTouching", function (t, e) { return new nd(t, e) }), R(window, "RexPlugins.UI.InTouching", nd); function Gb(t) { return t instanceof Ub } var Ub = Phaser.GameObjects.GameObject; c.register("tap", function (t, e) { return Gb(t) || (e = t, t = this.scene), new bd(t, e) }), R(window, "RexPlugins.UI.Tap", bd), c.register("press", function (t, e) { return Gb(t) || (e = t, t = this.scene), new Pd(t, e) }), R(window, "RexPlugins.UI.Press", Pd), c.register("swipe", function (t, e) { return Gb(t) || (e = t, t = this.scene), new Wd(t, e) }), R(window, "RexPlugins.UI.Swipe", Wd), c.register("pan", function (t, e) { return Gb(t) || (e = t, t = this.scene), new _d(t, e) }), R(window, "RexPlugins.UI.Pan", _d); function Hb(t) { for (var e, i = t.scene.input, n = i.manager, s = n.pointersTotal, r = n.pointers, o = 0; o < s; o++)if ((e = r[o]).primaryDown && 0 === i.getDragState(e) && ds(t, e)) return i.setDragState(e, 1), i._drag[e.id] = [t], 0 === i.dragDistanceThreshold || 0 === i.dragTimeThreshold ? (i.setDragState(e, 3), i.processDragStartList(e)) : i.setDragState(e, 2), !0; return !1 } var Nb = Phaser.Utils.Objects.GetValue, Jb = Phaser.Math.Distance.Between, Kb = Phaser.Math.RotateAroundDistance, qb = function () { w(s, Ta); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, t, { eventEmitter: !1 }))._enable = void 0, t.setInteractive(Nb(e, "inputConfig", void 0)), i.resetFromJSON(e), i.boot(), i } return k(s, [{ key: "resetFromJSON", value: function (t) { return this.pointer = void 0, this.setEnable(Nb(t, "enable", !0)), this.setAxisMode(Nb(t, "axis", 0)), this.setAxisRotation(Nb(t, "rotation", 0)), this } }, { key: "toJSON", value: function () { return { enable: this.enable, axis: this.axisMode, rotation: this.axisRotation } } }, { key: "boot", value: function () { var t = this.parent; t.on("dragstart", this.onDragStart, this), t.on("drag", this.onDrag, this), t.on("dragend", this.onDragEnd, this) } }, { key: "shutdown", value: function (t) { this.isShutdown || (this.pointer = void 0, O(C(s.prototype), "shutdown", this).call(this, t)) } }, { key: "enable", get: function () { return this._enable }, set: function (t) { if (this._enable !== t) return t || this.dragend(), this._enable = t, this.scene.input.setDraggable(this.parent, t), this } }, { key: "setEnable", value: function (t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "toggleEnable", value: function () { return this.setEnable(!this.enable), this } }, { key: "setAxisMode", value: function (t) { return "string" == typeof t && (t = $b[t]), this.axisMode = t, this } }, { key: "setAxisRotation", value: function (t) { return this.axisRotation = t, this } }, { key: "drag", value: function () { return Hb(this.parent), this } }, { key: "dragend", value: function () { if (this.isDragging) return this.scene.input.setDragState(this.pointer, 5), this } }, { key: "onDragStart", value: function (t) { this.isDragging || (this.pointer = t) } }, { key: "onDrag", value: function (t, e, i) { if (this.pointer === t) { var n = this.parent; if (0 === this.axisMode) n.x = e, n.y = i; else if (0 === this.axisRotation) 1 === this.axisMode ? n.x = e : 2 === this.axisMode && (n.y = i); else { var s, r = { x: e, y: i }; s = Jb(r.x, r.y, n.x, n.y), r = Kb(r, n.x, n.y, -this.axisRotation, s), 1 === this.axisMode ? r.y = n.y : 2 === this.axisMode && (r.x = n.x), s = Jb(r.x, r.y, n.x, n.y), r = Kb(r, n.x, n.y, this.axisRotation, s), n.x = r.x, n.y = r.y } } } }, { key: "onDragEnd", value: function (t) { this.pointer === t && (this.pointer = void 0) } }, { key: "isDragging", get: function () { return void 0 !== this.pointer } }]), s }(), $b = { both: 0, "h&v": 0, "x&y": 0, horizontal: 1, h: 1, x: 1, vertical: 2, v: 2, y: 2 }; c.register("drag", function (t, e) { return new qb(t, e) }), R(window, "RexPlugins.UI.Drag", qb), c.register("pinch", function (t) { return new sf(this.scene, t) }), R(window, "RexPlugins.UI.Pinch", sf), c.register("rotate", function (t) { return new vf(this.scene, t) }), R(window, "RexPlugins.UI.Rotate", vf); function Zb(e, i, t) { var n; if (void 0 === e) e = t.texture.key, i = t.frame.name; else if (Qb(e)) { var s = e; e = tx(s, "key", t.texture.key), i = tx(s, "frame", t.frame.name) } else "string" == typeof e || (n = e); return void 0 === n && (n = function (t) { t.setTexture(e, i) }), n } var Qb = Phaser.Utils.Objects.IsPlainObject, tx = Phaser.Utils.Objects.GetValue, ex = Phaser.Utils.Objects.GetValue, ix = Phaser.Utils.Objects.GetAdvancedValue, nx = Phaser.Math.Linear, sx = function () { w(s, ah); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, t, e)).resetFromJSON(e), i.boot(), i } return k(s, [{ key: "resetFromJSON", value: function (t) { return O(C(s.prototype), "resetFromJSON", this).call(this, t), this.setDuration(ix(t, "duration", 500)), this.setEase(ex(t, "ease", "Sine")), this.setOrientation(ex(t, "orientation", 0)), this.setFrontFace(ex(t, "front", void 0)), this.setBackFace(ex(t, "back", void 0)), this.setFace(ex(t, "face", 0)), this } }, { key: "setOrientation", value: function (t) { return "string" == typeof t && (t = rx[t]), this.orientation = t, this } }, { key: "face", get: function () { return this._face }, set: function (t) { "string" == typeof t && (t = ox[t]), 0 === (this._face = t) && this.frontFaceCallback ? this.frontFaceCallback(this.parent) : 1 === t && this.backFaceCallback && this.backFaceCallback(this.parent) } }, { key: "setFace", value: function (t) { return this.face = t, this } }, { key: "toggleFace", value: function () { var t = 0 === this.face ? 1 : 0; return this.setFace(t), this } }, { key: "setFrontFace", value: function (t, e) { return this.frontFaceCallback = Zb(t, e, this.parent), this } }, { key: "setBackFace", value: function (t, e) { return this.backFaceCallback = Zb(t, e, this.parent), this } }, { key: "start", value: function () { return this.timer.isRunning || (this.timer.setDelay(this.delay).setDuration(this.duration / 2).setRepeat(1), O(C(s.prototype), "start", this).call(this)), this } }, { key: "flip", value: function (t) { return this.isRunning || (void 0 !== t && this.setDuration(t), this.start()), this } }, { key: "updateGameObject", value: function (t, e) { e.justRestart && this.toggleFace(); var i = e.t; e.isOddIteration && (i = 1 - i), i = this.easeFn(i); var n = nx(1, 0, i); 0 === this.orientation ? t.scaleX = n : t.scaleY = n } }]), s }(), rx = { x: 0, horizontal: 0, y: 1, vertical: 1 }, ox = { front: 0, back: 1 }; c.register("flip", function (t, e) { return new sx(t, e) }), R(window, "RexPlugins.UI.Flip", sx), c.register("shake", function (t, e) { return new _c(t, e) }), R(window, "RexPlugins.UI.Shake", _c), c.register("touchEventStop", function (t, e) { return new ev(t, e) }), R(window, "RexPlugins.UI.TouchEventStop", ev); var ax = Phaser.Math.Vector3, hx = Phaser.Math.Matrix4, lx = new ax, ux = new ax, cx = new hx, dx = Phaser.GameObjects.Mesh, fx = Phaser.Utils.Objects.IsPlainObject, px = Phaser.Utils.Objects.GetValue, vx = Phaser.Geom.Mesh.GenerateGridVerts, gx = Phaser.Math.RadToDeg, yx = Phaser.Math.DegToRad, mx = 1 + 1 / Math.sin(yx(45)), kx = function () { w(u, dx); var l = T(u); function u(t, e, i, n, s, r) { var o; z(this, u), fx(e) && (e = px(r = e, "x", 0), i = px(r, "y", 0), n = px(r, "key", null), s = px(r, "frame", null)), (o = l.call(this, t, e, i, n, s)).type = "rexPerspectiveImage", o.setSizeToFrame(), o.resetPerspective(), o.panZ(mx), o.hideCCW = px(r, "hideCCW", !0); var a = px(r, "gridWidth", 32), h = px(r, "gridHeight", a); return o.resetVerts(a, h), o } return k(u, [{ key: "resetPerspective", value: function () { return this.setPerspective(this.width, this.height, 45), this } }, { key: "resetVerts", value: function (t, e) { if (void 0 !== t && (this.gridWidth = t), void 0 !== e && (this.gridHeight = e), this.clear(), this.dirtyCache[9] = -1, 0 === this.width || 0 === this.height) return this; var i = this.frame.cutWidth, n = this.frame.cutHeight; return vx({ mesh: this, texture: this.texture.key, frame: this.frame.name, width: i / this.height, height: n / this.height, widthSegments: Math.ceil(i / this.gridWidth), heightSegments: Math.ceil(n / this.gridHeight), flipY: this.frame.source.isRenderTexture }), this } }, { key: "syncSize", value: function () { return this.setSizeToFrame(), this.resetPerspective(), this.resetVerts(), this } }, { key: "rotationX", get: function () { return this.modelRotation.x }, set: function (t) { this.modelRotation.x = t } }, { key: "angleX", get: function () { return gx(this.rotationX) }, set: function (t) { this.rotationX = yx(t) } }, { key: "rotationY", get: function () { return this.modelRotation.y }, set: function (t) { this.modelRotation.y = t } }, { key: "angleY", get: function () { return gx(this.rotationY) }, set: function (t) { this.rotationY = yx(t) } }, { key: "rotationZ", get: function () { return this.modelRotation.z }, set: function (t) { this.modelRotation.z = t } }, { key: "angleZ", get: function () { return gx(this.rotationZ) }, set: function (t) { this.rotationZ = yx(t) } }, { key: "transformVerts", value: function (t, e, i, n, s, r) { return function (t, e, i, n, s, r, o) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 0), void 0 === o && (o = 0), lx.set(e, i, n), ux.set(s, r, o), cx.fromRotationXYTranslation(ux, lx, !0); for (var a = 0, h = t.vertices.length; a < h; a++)t.vertices[a].transformMat4(cx) }(this, t, e, i, n, s, r), this } }, { key: "forceUpdate", value: function () { return this.dirtyCache[10] = 1, this } }, { key: "tint", get: function () { return 0 === this.vertices.length ? 16777215 : this.vertices[0].color }, set: function (t) { for (var e = this.vertices, i = 0, n = e.length; i < n; i++)e[i].color = t } }, { key: "setTint", value: function (t) { return this.tint = t, this } }]), u }(), bx = Phaser.GameObjects.RenderTexture, xx = Phaser.Utils.Objects.IsPlainObject, Cx = Phaser.Utils.Objects.GetValue, wx = function () { w(l, kx); var h = T(l); function l(t, e, i, n, s, r) { var o; z(this, l), xx(e) && (e = Cx(r = e, "x", 0), i = Cx(r, "y", 0), n = Cx(r, "width", 32), s = Cx(r, "height", 32)); var a = new bx(t, e, i, n, s).setOrigin(.5); return (o = h.call(this, t, e, i, a.texture.key, null, r)).type = "rexPerspectiveRenderTexture", o.rt = a, o } return k(l, [{ key: "destroy", value: function (t) { O(C(l.prototype), "destroy", this).call(this, t), this.rt.destroy(), this.rt = null } }]), l }(); Phaser.Animations.AnimationState, Phaser.Utils.Objects.IsPlainObject, Phaser.Utils.Objects.GetValue, Phaser.Math.RadToDeg, Phaser.Math.DegToRad, Phaser.Utils.Objects.IsPlainObject, (0, Phaser.Math.DegToRad)(180), Phaser.Utils.Objects.GetValue, Phaser.Math.Linear, Phaser.Utils.Objects.IsPlainObject, Phaser.Utils.Objects.GetValue, Phaser.Utils.Objects.GetValue, Phaser.Math.RadToDeg, Phaser.Math.DegToRad, Phaser.Math.Angle.WrapDegrees, Phaser.Math.Angle.ShortestBetween, Phaser.Math.Wrap, Phaser.Math.Linear, Phaser.Utils.Objects.IsPlainObject, Phaser.Utils.Objects.GetValue, Phaser.Math.DegToRad, Phaser.Math.RadToDeg, Phaser.Math.Angle.WrapDegrees, Phaser.Math.Linear, Phaser.Math.Wrap, Phaser.Utils.Objects.IsPlainObject, Phaser.Utils.Objects.GetValue, Phaser.Math.Wrap; function Sx(t, e) { if (t) { for (var i = e.visibleSibling, n = 0, s = i.length; n < s; n++)t.setChildVisible(i[n], !0); return i.length = 0, t.setChildVisible(e, !1), e.isRunning = !1, 1 } } function Px(t) { var e = t.gameObjects, i = t.renderTexture; if (0 === e.length) return i && i.setSize(1, 1).clear(), i; var n, s, r = Bx(t, "x", void 0), o = Bx(t, "y", void 0), a = Bx(t, "width", void 0), h = Bx(t, "height", void 0), l = Bx(t, "originX", 0), u = Bx(t, "originY", 0); if (void 0 === a || void 0 === h || void 0 === r || void 0 === o) { var c = function (t, e) { var i; void 0 === e ? e = new Ex : !0 === e && (void 0 === Ox && (Ox = new Ex), e = Ox); for (var n = !0, s = 0, r = t.length; s < r; s++)if ((i = t[s]).getBounds) { var o = lu(i, !0); n ? (e.setTo(o.x, o.y, o.width, o.height), n = !1) : _x(o, e, e) } return e }(e, !0); u = l = void 0 !== r && void 0 !== o ? (a = 2 * Math.max(r - c.left, c.right - r), h = 2 * Math.max(o - c.top, c.bottom - o), .5) : (r = c.x, o = c.y, a = c.width, h = c.height, 0), n = c.x, s = c.y } else n = r + (0 - l) * a, s = o + (0 - u) * h; return i ? (i.setPosition(r, o), i.width === a && i.height === h || i.setSize(a, h)) : i = e[0].scene.add.renderTexture(r, o, a, h), i.setOrigin(l, u), i.camera.setScroll(n, s), e = Is(rt(e)), i.draw(e), i } function Tx(t) { return function () { w(h, t); var a = T(h); function h(t, e) { var i; z(this, h); var n, s, r, o = t.scene; return i = a.call(this, o, 0, 0, 1, 1, e), o.add.existing(j(i)), n = t, s = j(i), r = e, s.visibleSibling = [], s.isRunning = !1, s.useParentBounds = Mx(r, "useParentBounds", !1), s.setPosition(n.x, n.y).setVisible(!1), n.pin(s), i } return k(h, [{ key: "destroy", value: function (t) { this.scene && (this.exit(), O(C(h.prototype), "destroy", this).call(this, t)) } }, { key: "enter", value: function () { return function (t, e) { if (!t) return !1; Sx(t, e); var i = e.useParentBounds; Px({ gameObjects: t.getAllVisibleChildren(), renderTexture: e.rt, x: e.x, y: e.y, width: i ? t.displayWidth : void 0, height: i ? t.displayHeighth : void 0, originX: i ? t.originX : void 0, originY: i ? t.originY : void 0 }), t.setChildVisible(e, !0); for (var n = e.visibleSibling, s = t.children, r = 0, o = s.length; r < o; r++) { var a = s[r]; a.visible && a !== e && (t.setChildVisible(a, !1), n.push(a)) } return e.isRunning = !0 }(this.rexContainer.parent, this) && this.syncSize(), this } }, { key: "exit", value: function () { return Sx(this.rexContainer.parent, this), this } }]), h }() } var Ox, Mx = Phaser.Utils.Objects.GetValue, Ex = Phaser.Geom.Rectangle, _x = Phaser.Geom.Rectangle.Union, Bx = Phaser.Utils.Objects.GetValue, Ix = function () { w(e, Tx(wx)); var t = T(e); function e() { return z(this, e), t.apply(this, arguments) } return k(e, [{ key: "perspectiveState", get: function () { return this.isRunning } }]), e }(); c.register("perspective", function (t, e) { return new Ix(t, e) }), R(window, "RexPlugins.UI.Perspective", Ix); function Rx(t, e, i) { var n = t.width / 2, s = t.height / 2; return Dx.x = e - n, Dx.y = i - s, Ax(Dx, 0, 0, t.rotation), Dx.x *= t.scaleX, Dx.y *= t.scaleY, Dx.x += t.x, Dx.y += t.y, Dx } var Ax = Phaser.Math.RotateAround, Dx = { x: 0, y: 0 }, Lx = function () { function i(t, e) { z(this, i), this.parent = t, this.vertex = e, this._localX = void 0, this._localY = void 0 } return k(i, [{ key: "destroy", value: function () { this.parent = void 0, this.vertex = void 0 } }, { key: "updateVertexPosition", value: function (t, e) { var i = this.parent, n = i.height, s = t / n - i.frame.cutWidth / n / 2, r = e / n - i.frame.cutHeight / n / 2, o = this.vertex; return o.x = s, o.y = -r, i.forceUpdate(), this } }, { key: "localX", get: function () { return this._localX }, set: function (t) { this.setLocalXY(t, this._localY) } }, { key: "localY", get: function () { return this._localY }, set: function (t) { this.setLocalXY(this._localX, t) } }, { key: "localXOrigin", get: function () { return this._localXOrigin } }, { key: "localYOrigin", get: function () { return this._localYOrigin } }, { key: "resetLocalXY", value: function (t, e) { return this._localXOrigin = t, this._localYOrigin = e, this._localX = t, this._localY = e, this } }, { key: "setLocalXY", value: function (t, e, i) { return this._localX === t && this._localY === e || (this._localX = t, this._localY = e, i || this.updateVertexPosition(t, e)), this } }, { key: "setWorldXY", value: function (t, e) { if (this._worldX === t && this._worldY === e) return this; var i, n, s, r, o, a = (i = this.parent, n = t, s = e, r = i.width / 2, o = i.height / 2, Dx.x = n - i.x, Dx.y = s - i.y, Dx.x /= i.scaleX, Dx.y /= i.scaleY, Ax(Dx, 0, 0, -i.rotation), Dx.x += r, Dx.y += o, Dx); return this.setLocalXY(a.x, a.y), this } }, { key: "setPosition", value: function (t, e) { return this.setWorldXY(t, e), this } }, { key: "getWorldXY", value: function () { return Rx(this.parent, this._localX, this._localY) } }, { key: "x", get: function () { return Rx(this.parent, this._localX, this._localY).x }, set: function (t) { this.setWorldXY(t, this.y) } }, { key: "y", get: function () { return Rx(this.parent, this._localX, this._localY).y }, set: function (t) { this.setWorldXY(this.x, t) } }]), i }(), zx = Phaser.Geom.Mesh.Vertex, jx = Phaser.Geom.Mesh.Face, Fx = [0, 2, 3, 0, 3, 1], Yx = [0, 3, 4, 0, 4, 1, 1, 4, 2, 4, 5, 2, 3, 6, 4, 6, 7, 4, 4, 7, 8, 4, 8, 5], Wx = Phaser.GameObjects.Mesh, Vx = Phaser.Utils.Objects.IsPlainObject, Xx = Phaser.Utils.Objects.GetValue, Gx = function () { w(h, Wx); var a = T(h); function h(t, e, i, n, s, r) { var o; return z(this, h), Vx(e) && (e = Xx(r = e, "x", 0), i = Xx(r, "y", 0), n = Xx(r, "key", null), s = Xx(r, "frame", null)), (o = a.call(this, t, e, i, n, s)).type = "rexQuadImage", o.isNinePointMode = Xx(r, "ninePointMode", !1), o.controlPoints = [], function (t) { for (var e = t.isNinePointMode, i = e ? 9 : 4, n = t.vertices, s = t.faces, r = t.controlPoints, o = 0; o < i; o++) { var a = new zx; n.push(a), r.push(new Lx(t, a)) } for (var h = e ? Yx : Fx, l = (o = 0, h.length); o < l; o += 3) { var u = n[h[o + 0]], c = n[h[o + 1]], d = n[h[o + 2]]; s.push(new jx(u, c, d)) } e ? (t.topLeft = r[0], t.topCenter = r[1], t.topRight = r[2], t.centerLeft = r[3], t.center = r[4], t.centerRight = r[5], t.bottomLeft = r[6], t.bottomCenter = r[7], t.bottomRight = r[8]) : (t.topLeft = r[0], t.topRight = r[1], t.bottomLeft = r[2], t.bottomRight = r[3]) }(j(o)), o.hideCCW = !1, o.syncSize(), o } return k(h, [{ key: "preDestroy", value: function () { for (var t = 0, e = this.controlPoints.length; t < e; t++)this.controlPoints[t].destroy(); this.controlPoints = void 0, O(C(h.prototype), "preDestroy", this).call(this) } }, { key: "resetVerts", value: function () { this.dirtyCache[9] = -1; for (var t = function (t) { var e, i = t.height, n = t.width; if (t.isNinePointMode) { var s = (0 + n) / 2, r = (0 + i) / 2; e = [0, 0, s, 0, n, 0, 0, r, s, r, n, r, 0, i, s, i, n, i] } else e = [0, 0, n, 0, 0, i, n, i]; return e }(this), e = this.width, i = this.height, n = this.frame.cutWidth / i / 2, s = this.frame.cutHeight / i / 2, r = this.frame.source.isRenderTexture, o = this.frame.u0, a = this.frame.u1, h = r ? this.frame.v1 : this.frame.v0, l = a - o, u = (r ? this.frame.v0 : this.frame.v1) - h, c = this.controlPoints, d = 0, f = t.length; d < f; d += 2) { var p = t[d + 0], v = t[d + 1], g = d / 2, y = p / i - n, m = v / i - s, k = o + p / e * l, b = h + v / i * u; this.vertices[g].set(y, -m, 0).setUVs(k, b), c[g].resetLocalXY(p, v) } return this } }, { key: "syncSize", value: function () { return this.setSizeToFrame(), this.setOrtho(this.width / this.height, 1), this.resetVerts(), this } }, { key: "forceUpdate", value: function () { return this.dirtyCache[10] = 1, this } }, { key: "tint", get: function () { return 0 === this.vertices.length ? 16777215 : this.vertices[0].color }, set: function (t) { for (var e = this.vertices, i = 0, n = e.length; i < n; i++)e[i].color = t } }, { key: "setTint", value: function (t) { return this.tint = t, this } }]), h }(); Phaser.GameObjects.RenderTexture, Phaser.Utils.Objects.IsPlainObject, Phaser.Utils.Objects.GetValue; function Ux(t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 0); for (var n = .5 * t.width, s = .5 * t.height, r = Math.tan(e) * s, o = Math.tan(i) * n, a = t.controlPoints, h = 0, l = a.length; h < l; h++) { var u = a[h], c = u.localXOrigin, d = u.localYOrigin; u.localX = c + (s < d ? r : -r), u.localY = d + (n < c ? o : -o) } } var Hx = Phaser.Utils.Objects.IsPlainObject, Nx = Phaser.Utils.Objects.GetValue, Jx = Phaser.Math.DegToRad, Kx = Phaser.Math.RadToDeg, qx = function () { w(h, Gx); var a = T(h); function h(t, e, i, n, s) { var r; if (z(this, h), Hx(e)) { var o = e; e = Nx(o, "x", 0), i = Nx(o, "y", 0), n = Nx(o, "key", null), s = Nx(o, "frame", null) } return (r = a.call(this, t, e, i, n, s)).type = "rexSkewmage", r._skewX = 0, r._skewY = 0, r } return k(h, [{ key: "skewX", get: function () { return this._skewX }, set: function (t) { this._skewX = t, Ux(this, this._skewX, this._skewY) } }, { key: "skewXDeg", get: function () { return Kx(this._skewX) }, set: function (t) { this.skewX = Jx(t) } }, { key: "skewY", get: function () { return this._skewY }, set: function (t) { this._skewY = t, Ux(this, this._skewX, this._skewY) } }, { key: "skewYDeg", get: function () { return Kx(this._skewY) }, set: function (t) { this.skewY = Jx(t) } }, { key: "setSkewX", value: function (t) { return this.skewX = t, this } }, { key: "setSkewY", value: function (t) { return this.skewY = t, this } }, { key: "setSkew", value: function (t, e) { return void 0 === e && (e = t), this.skewX = t, this.skewY = e, this } }, { key: "setSkewXDeg", value: function (t) { return this.skewXDeg = t, this } }, { key: "setSkewYDeg", value: function (t) { return this.skewYDeg = t, this } }, { key: "setSkewDeg", value: function (t, e) { return void 0 === e && (e = t), this.skewXDeg = t, this.skewYDeg = e, this } }]), h }(), $x = Phaser.GameObjects.RenderTexture, Zx = Phaser.Utils.Objects.IsPlainObject, Qx = Phaser.Utils.Objects.GetValue, tC = function () { w(l, qx); var h = T(l); function l(t, e, i, n, s) { var r; if (z(this, l), Zx(e)) { var o = e; e = Qx(o, "x", 0), i = Qx(o, "y", 0), n = Qx(o, "width", 32), s = Qx(o, "height", 32) } var a = new $x(t, e, i, n, s).setOrigin(.5); return (r = h.call(this, t, e, i, a.texture.key, null)).type = "rexSkewRenderTexture", r.rt = a, r } return k(l, [{ key: "destroy", value: function (t) { O(C(l.prototype), "destroy", this).call(this, t), this.rt.destroy(), this.rt = null } }]), l }(), eC = function () { w(e, Tx(tC)); var t = T(e); function e() { return z(this, e), t.apply(this, arguments) } return k(e, [{ key: "skewState", get: function () { return this.isRunning } }]), e }(); function iC(t) { return null == t } c.register("skew", function (t, e) { return new eC(t, e) }), R(window, "RexPlugins.UI.Skew", eC), c.register("anchor", function (t, e) { return new rc(t, e) }), R(window, "RexPlugins.UI.Anchor", rc); var nC = { isNothing: iC, isObject: function (t) { return "object" == typeof t && null !== t }, toArray: function (t) { return Array.isArray(t) ? t : iC(t) ? [] : [t] }, repeat: function (t, e) { var i, n = ""; for (i = 0; i < e; i += 1)n += t; return n }, isNegativeZero: function (t) { return 0 === t && Number.NEGATIVE_INFINITY === 1 / t }, extend: function (t, e) { var i, n, s, r; if (e) for (i = 0, n = (r = Object.keys(e)).length; i < n; i += 1)t[s = r[i]] = e[s]; return t } }; function sC(t, e) { var i = "", n = t.reason || "(unknown reason)"; return t.mark ? (t.mark.name && (i += 'in "' + t.mark.name + '" '), i += "(" + (t.mark.line + 1) + ":" + (t.mark.column + 1) + ")", !e && t.mark.snippet && (i += "\n\n" + t.mark.snippet), n + " " + i) : n } function rC(t, e) { Error.call(this), this.name = "YAMLException", this.reason = t, this.mark = e, this.message = sC(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack || "" } ((rC.prototype = Object.create(Error.prototype)).constructor = rC).prototype.toString = function (t) { return this.name + ": " + sC(this, t) }; var oC = rC; function aC(t, e, i, n, s) { var r = "", o = "", a = Math.floor(s / 2) - 1; return a < n - e && (e = n - a + (r = " ... ").length), a < i - n && (i = n + a - (o = " ...").length), { str: r + t.slice(e, i).replace(/\t/g, "→") + o, pos: n - e + r.length } } function hC(t, e) { return nC.repeat(" ", e - t.length) + t } var lC = function (t, e) { if (e = Object.create(e || null), !t.buffer) return null; e.maxLength || (e.maxLength = 79), "number" != typeof e.indent && (e.indent = 1), "number" != typeof e.linesBefore && (e.linesBefore = 3), "number" != typeof e.linesAfter && (e.linesAfter = 2); for (var i, n = /\r?\n|\r|\0/g, s = [0], r = [], o = -1; i = n.exec(t.buffer);)r.push(i.index), s.push(i.index + i[0].length), t.position <= i.index && o < 0 && (o = s.length - 2); o < 0 && (o = s.length - 1); var a, h, l = "", u = Math.min(t.line + e.linesAfter, r.length).toString().length, c = e.maxLength - (e.indent + u + 3); for (a = 1; a <= e.linesBefore && !(o - a < 0); a++)h = aC(t.buffer, s[o - a], r[o - a], t.position - (s[o] - s[o - a]), c), l = nC.repeat(" ", e.indent) + hC((t.line - a + 1).toString(), u) + " | " + h.str + "\n" + l; for (h = aC(t.buffer, s[o], r[o], t.position, c), l += nC.repeat(" ", e.indent) + hC((t.line + 1).toString(), u) + " | " + h.str + "\n", l += nC.repeat("-", e.indent + u + 3 + h.pos) + "^\n", a = 1; a <= e.linesAfter && !(o + a >= r.length); a++)h = aC(t.buffer, s[o + a], r[o + a], t.position - (s[o] - s[o + a]), c), l += nC.repeat(" ", e.indent) + hC((t.line + a + 1).toString(), u) + " | " + h.str + "\n"; return l.replace(/\n$/, "") }, uC = ["kind", "multi", "resolve", "construct", "instanceOf", "predicate", "represent", "representName", "defaultStyle", "styleAliases"], cC = ["scalar", "sequence", "mapping"]; var dC = function (e, t) { var i, n; if (t = t || {}, Object.keys(t).forEach(function (t) { if (-1 === uC.indexOf(t)) throw new oC('Unknown option "' + t + '" is met in definition of "' + e + '" YAML type.') }), this.options = t, this.tag = e, this.kind = t.kind || null, this.resolve = t.resolve || function () { return !0 }, this.construct = t.construct || function (t) { return t }, this.instanceOf = t.instanceOf || null, this.predicate = t.predicate || null, this.represent = t.represent || null, this.representName = t.representName || null, this.defaultStyle = t.defaultStyle || null, this.multi = t.multi || !1, this.styleAliases = (i = t.styleAliases || null, n = {}, null !== i && Object.keys(i).forEach(function (e) { i[e].forEach(function (t) { n[String(t)] = e }) }), n), -1 === cC.indexOf(this.kind)) throw new oC('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.') }; function fC(t, e) { var s = []; return t[e].forEach(function (i) { var n = s.length; s.forEach(function (t, e) { t.tag === i.tag && t.kind === i.kind && t.multi === i.multi && (n = e) }), s[n] = i }), s } function pC(t) { return this.extend(t) } pC.prototype.extend = function (t) { var e = [], i = []; if (t instanceof dC) i.push(t); else if (Array.isArray(t)) i = i.concat(t); else { if (!t || !Array.isArray(t.implicit) && !Array.isArray(t.explicit)) throw new oC("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })"); t.implicit && (e = e.concat(t.implicit)), t.explicit && (i = i.concat(t.explicit)) } e.forEach(function (t) { if (!(t instanceof dC)) throw new oC("Specified list of YAML types (or a single Type object) contains a non-Type object."); if (t.loadKind && "scalar" !== t.loadKind) throw new oC("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported."); if (t.multi) throw new oC("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.") }), i.forEach(function (t) { if (!(t instanceof dC)) throw new oC("Specified list of YAML types (or a single Type object) contains a non-Type object.") }); var n = Object.create(pC.prototype); return n.implicit = (this.implicit || []).concat(e), n.explicit = (this.explicit || []).concat(i), n.compiledImplicit = fC(n, "implicit"), n.compiledExplicit = fC(n, "explicit"), n.compiledTypeMap = function () { var t, e, i = { scalar: {}, sequence: {}, mapping: {}, fallback: {}, multi: { scalar: [], sequence: [], mapping: [], fallback: [] } }; function n(t) { t.multi ? (i.multi[t.kind].push(t), i.multi.fallback.push(t)) : i[t.kind][t.tag] = i.fallback[t.tag] = t } for (t = 0, e = arguments.length; t < e; t += 1)arguments[t].forEach(n); return i }(n.compiledImplicit, n.compiledExplicit), n }; var vC = pC, gC = new dC("tag:yaml.org,2002:str", { kind: "scalar", construct: function (t) { return null !== t ? t : "" } }), yC = new dC("tag:yaml.org,2002:seq", { kind: "sequence", construct: function (t) { return null !== t ? t : [] } }), mC = new dC("tag:yaml.org,2002:map", { kind: "mapping", construct: function (t) { return null !== t ? t : {} } }), kC = new vC({ explicit: [gC, yC, mC] }); var bC = new dC("tag:yaml.org,2002:null", { kind: "scalar", resolve: function (t) { if (null === t) return !0; var e = t.length; return 1 === e && "~" === t || 4 === e && ("null" === t || "Null" === t || "NULL" === t) }, construct: function () { return null }, predicate: function (t) { return null === t }, represent: { canonical: function () { return "~" }, lowercase: function () { return "null" }, uppercase: function () { return "NULL" }, camelcase: function () { return "Null" }, empty: function () { return "" } }, defaultStyle: "lowercase" }); var xC = new dC("tag:yaml.org,2002:bool", { kind: "scalar", resolve: function (t) { if (null === t) return !1; var e = t.length; return 4 === e && ("true" === t || "True" === t || "TRUE" === t) || 5 === e && ("false" === t || "False" === t || "FALSE" === t) }, construct: function (t) { return "true" === t || "True" === t || "TRUE" === t }, predicate: function (t) { return "[object Boolean]" === Object.prototype.toString.call(t) }, represent: { lowercase: function (t) { return t ? "true" : "false" }, uppercase: function (t) { return t ? "TRUE" : "FALSE" }, camelcase: function (t) { return t ? "True" : "False" } }, defaultStyle: "lowercase" }); var CC = new dC("tag:yaml.org,2002:int", { kind: "scalar", resolve: function (t) { if (null === t) return !1; var e, i, n, s, r = t.length, o = 0, a = !1; if (!r) return !1; if ("-" !== (e = t[o]) && "+" !== e || (e = t[++o]), "0" === e) { if (o + 1 === r) return !0; if ("b" === (e = t[++o])) { for (o++; o < r; o++)if ("_" !== (e = t[o])) { if ("0" !== e && "1" !== e) return !1; a = !0 } return a && "_" !== e } if ("x" === e) { for (o++; o < r; o++)if ("_" !== (e = t[o])) { if (!(48 <= (n = t.charCodeAt(o)) && n <= 57 || 65 <= n && n <= 70 || 97 <= n && n <= 102)) return !1; a = !0 } return a && "_" !== e } if ("o" === e) { for (o++; o < r; o++)if ("_" !== (e = t[o])) { if (!(48 <= (i = t.charCodeAt(o)) && i <= 55)) return !1; a = !0 } return a && "_" !== e } } if ("_" === e) return !1; for (; o < r; o++)if ("_" !== (e = t[o])) { if (!(48 <= (s = t.charCodeAt(o)) && s <= 57)) return !1; a = !0 } return !(!a || "_" === e) }, construct: function (t) { var e, i = t, n = 1; if (-1 !== i.indexOf("_") && (i = i.replace(/_/g, "")), "-" !== (e = i[0]) && "+" !== e || ("-" === e && (n = -1), e = (i = i.slice(1))[0]), "0" === i) return 0; if ("0" === e) { if ("b" === i[1]) return n * parseInt(i.slice(2), 2); if ("x" === i[1]) return n * parseInt(i.slice(2), 16); if ("o" === i[1]) return n * parseInt(i.slice(2), 8) } return n * parseInt(i, 10) }, predicate: function (t) { return "[object Number]" === Object.prototype.toString.call(t) && t % 1 == 0 && !nC.isNegativeZero(t) }, represent: { binary: function (t) { return 0 <= t ? "0b" + t.toString(2) : "-0b" + t.toString(2).slice(1) }, octal: function (t) { return 0 <= t ? "0o" + t.toString(8) : "-0o" + t.toString(8).slice(1) }, decimal: function (t) { return t.toString(10) }, hexadecimal: function (t) { return 0 <= t ? "0x" + t.toString(16).toUpperCase() : "-0x" + t.toString(16).toUpperCase().slice(1) } }, defaultStyle: "decimal", styleAliases: { binary: [2, "bin"], octal: [8, "oct"], decimal: [10, "dec"], hexadecimal: [16, "hex"] } }), wC = new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"); var SC = /^[-+]?[0-9]+e/; var PC = new dC("tag:yaml.org,2002:float", { kind: "scalar", resolve: function (t) { return null !== t && !(!wC.test(t) || "_" === t[t.length - 1]) }, construct: function (t) { var e, i; return i = "-" === (e = t.replace(/_/g, "").toLowerCase())[0] ? -1 : 1, 0 <= "+-".indexOf(e[0]) && (e = e.slice(1)), ".inf" === e ? 1 == i ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : ".nan" === e ? NaN : i * parseFloat(e, 10) }, predicate: function (t) { return "[object Number]" === Object.prototype.toString.call(t) && (t % 1 != 0 || nC.isNegativeZero(t)) }, represent: function (t, e) { var i; if (isNaN(t)) switch (e) { case "lowercase": return ".nan"; case "uppercase": return ".NAN"; case "camelcase": return ".NaN" } else if (Number.POSITIVE_INFINITY === t) switch (e) { case "lowercase": return ".inf"; case "uppercase": return ".INF"; case "camelcase": return ".Inf" } else if (Number.NEGATIVE_INFINITY === t) switch (e) { case "lowercase": return "-.inf"; case "uppercase": return "-.INF"; case "camelcase": return "-.Inf" } else if (nC.isNegativeZero(t)) return "-0.0"; return i = t.toString(10), SC.test(i) ? i.replace("e", ".e") : i }, defaultStyle: "lowercase" }), TC = kC.extend({ implicit: [bC, xC, CC, PC] }), OC = TC, MC = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"), EC = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"); var _C = new dC("tag:yaml.org,2002:timestamp", { kind: "scalar", resolve: function (t) { return null !== t && (null !== MC.exec(t) || null !== EC.exec(t)) }, construct: function (t) { var e, i, n, s, r, o, a, h, l = 0, u = null; if (null === (e = MC.exec(t)) && (e = EC.exec(t)), null === e) throw new Error("Date resolve error"); if (i = +e[1], n = e[2] - 1, s = +e[3], !e[4]) return new Date(Date.UTC(i, n, s)); if (r = +e[4], o = +e[5], a = +e[6], e[7]) { for (l = e[7].slice(0, 3); l.length < 3;)l += "0"; l = +l } return e[9] && (u = 6e4 * (60 * +e[10] + +(e[11] || 0)), "-" === e[9] && (u = -u)), h = new Date(Date.UTC(i, n, s, r, o, a, l)), u && h.setTime(h.getTime() - u), h }, instanceOf: Date, represent: function (t) { return t.toISOString() } }); var BC = new dC("tag:yaml.org,2002:merge", { kind: "scalar", resolve: function (t) { return "<<" === t || null === t } }), IC = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r"; var RC = new dC("tag:yaml.org,2002:binary", { kind: "scalar", resolve: function (t) { if (null === t) return !1; var e, i, n = 0, s = t.length, r = IC; for (i = 0; i < s; i++)if (!(64 < (e = r.indexOf(t.charAt(i))))) { if (e < 0) return !1; n += 6 } return n % 8 == 0 }, construct: function (t) { var e, i, n = t.replace(/[\r\n=]/g, ""), s = n.length, r = IC, o = 0, a = []; for (e = 0; e < s; e++)e % 4 == 0 && e && (a.push(o >> 16 & 255), a.push(o >> 8 & 255), a.push(255 & o)), o = o << 6 | r.indexOf(n.charAt(e)); return 0 == (i = s % 4 * 6) ? (a.push(o >> 16 & 255), a.push(o >> 8 & 255), a.push(255 & o)) : 18 == i ? (a.push(o >> 10 & 255), a.push(o >> 2 & 255)) : 12 == i && a.push(o >> 4 & 255), new Uint8Array(a) }, predicate: function (t) { return "[object Uint8Array]" === Object.prototype.toString.call(t) }, represent: function (t) { var e, i, n = "", s = 0, r = t.length, o = IC; for (e = 0; e < r; e++)e % 3 == 0 && e && (n += o[s >> 18 & 63], n += o[s >> 12 & 63], n += o[s >> 6 & 63], n += o[63 & s]), s = (s << 8) + t[e]; return 0 == (i = r % 3) ? (n += o[s >> 18 & 63], n += o[s >> 12 & 63], n += o[s >> 6 & 63], n += o[63 & s]) : 2 == i ? (n += o[s >> 10 & 63], n += o[s >> 4 & 63], n += o[s << 2 & 63], n += o[64]) : 1 == i && (n += o[s >> 2 & 63], n += o[s << 4 & 63], n += o[64], n += o[64]), n } }), AC = Object.prototype.hasOwnProperty, DC = Object.prototype.toString; var LC = new dC("tag:yaml.org,2002:omap", { kind: "sequence", resolve: function (t) { if (null === t) return !0; var e, i, n, s, r, o = [], a = t; for (e = 0, i = a.length; e < i; e += 1) { if (n = a[e], r = !1, "[object Object]" !== DC.call(n)) return !1; for (s in n) if (AC.call(n, s)) { if (r) return !1; r = !0 } if (!r) return !1; if (-1 !== o.indexOf(s)) return !1; o.push(s) } return !0 }, construct: function (t) { return null !== t ? t : [] } }), zC = Object.prototype.toString; var jC = new dC("tag:yaml.org,2002:pairs", { kind: "sequence", resolve: function (t) { if (null === t) return !0; var e, i, n, s, r, o = t; for (r = new Array(o.length), e = 0, i = o.length; e < i; e += 1) { if (n = o[e], "[object Object]" !== zC.call(n)) return !1; if (1 !== (s = Object.keys(n)).length) return !1; r[e] = [s[0], n[s[0]]] } return !0 }, construct: function (t) { if (null === t) return []; var e, i, n, s, r, o = t; for (r = new Array(o.length), e = 0, i = o.length; e < i; e += 1)n = o[e], s = Object.keys(n), r[e] = [s[0], n[s[0]]]; return r } }), FC = Object.prototype.hasOwnProperty; var YC = new dC("tag:yaml.org,2002:set", { kind: "mapping", resolve: function (t) { if (null === t) return !0; var e, i = t; for (e in i) if (FC.call(i, e) && null !== i[e]) return !1; return !0 }, construct: function (t) { return null !== t ? t : {} } }), WC = OC.extend({ implicit: [_C, BC], explicit: [RC, LC, jC, YC] }), VC = Object.prototype.hasOwnProperty, XC = 1, GC = 2, UC = 3, HC = 4, NC = 1, JC = 2, KC = 3, qC = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, $C = /[\x85\u2028\u2029]/, ZC = /[,\[\]\{\}]/, QC = /^(?:!|!!|![a-z\-]+!)$/i, tw = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i; function ew(t) { return Object.prototype.toString.call(t) } function iw(t) { return 10 === t || 13 === t } function nw(t) { return 9 === t || 32 === t } function sw(t) { return 9 === t || 32 === t || 10 === t || 13 === t } function rw(t) { return 44 === t || 91 === t || 93 === t || 123 === t || 125 === t } function ow(t) { return 48 === t ? "\0" : 97 === t ? "" : 98 === t ? "\b" : 116 === t || 9 === t ? "\t" : 110 === t ? "\n" : 118 === t ? "\v" : 102 === t ? "\f" : 114 === t ? "\r" : 101 === t ? "" : 32 === t ? " " : 34 === t ? '"' : 47 === t ? "/" : 92 === t ? "\\" : 78 === t ? "" : 95 === t ? " " : 76 === t ? "\u2028" : 80 === t ? "\u2029" : "" } for (var aw = new Array(256), hw = new Array(256), lw = 0; lw < 256; lw++)aw[lw] = ow(lw) ? 1 : 0, hw[lw] = ow(lw); function uw(t, e) { this.input = t, this.filename = e.filename || null, this.schema = e.schema || WC, this.onWarning = e.onWarning || null, this.legacy = e.legacy || !1, this.json = e.json || !1, this.listener = e.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = t.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [] } function cw(t, e) { var i = { name: t.filename, buffer: t.input.slice(0, -1), position: t.position, line: t.line, column: t.position - t.lineStart }; return i.snippet = lC(i), new oC(e, i) } function dw(t, e) { throw cw(t, e) } function fw(t, e) { t.onWarning && t.onWarning.call(null, cw(t, e)) } var pw = { YAML: function (t, e, i) { var n, s, r; null !== t.version && dw(t, "duplication of %YAML directive"), 1 !== i.length && dw(t, "YAML directive accepts exactly one argument"), null === (n = /^([0-9]+)\.([0-9]+)$/.exec(i[0])) && dw(t, "ill-formed argument of the YAML directive"), s = parseInt(n[1], 10), r = parseInt(n[2], 10), 1 !== s && dw(t, "unacceptable YAML version of the document"), t.version = i[0], t.checkLineBreaks = r < 2, 1 !== r && 2 !== r && fw(t, "unsupported YAML version of the document") }, TAG: function (e, t, i) { var n, s; 2 !== i.length && dw(e, "TAG directive accepts exactly two arguments"), n = i[0], s = i[1], QC.test(n) || dw(e, "ill-formed tag handle (first argument) of the TAG directive"), VC.call(e.tagMap, n) && dw(e, 'there is a previously declared suffix for "' + n + '" tag handle'), tw.test(s) || dw(e, "ill-formed tag prefix (second argument) of the TAG directive"); try { s = decodeURIComponent(s) } catch (t) { dw(e, "tag prefix is malformed: " + s) } e.tagMap[n] = s } }; function vw(t, e, i, n) { var s, r, o, a; if (e < i) { if (a = t.input.slice(e, i), n) for (s = 0, r = a.length; s < r; s += 1)9 === (o = a.charCodeAt(s)) || 32 <= o && o <= 1114111 || dw(t, "expected valid JSON character"); else qC.test(a) && dw(t, "the stream contains non-printable characters"); t.result += a } } function gw(t, e, i, n) { var s, r, o, a; for (nC.isObject(i) || dw(t, "cannot merge mappings; the provided source object is unacceptable"), o = 0, a = (s = Object.keys(i)).length; o < a; o += 1)r = s[o], VC.call(e, r) || (e[r] = i[r], n[r] = !0) } function yw(t, e, i, n, s, r, o, a, h) { var l, u; if (Array.isArray(s)) for (l = 0, u = (s = Array.prototype.slice.call(s)).length; l < u; l += 1)Array.isArray(s[l]) && dw(t, "nested arrays are not supported inside keys"), "object" == typeof s && "[object Object]" === ew(s[l]) && (s[l] = "[object Object]"); if ("object" == typeof s && "[object Object]" === ew(s) && (s = "[object Object]"), s = String(s), null === e && (e = {}), "tag:yaml.org,2002:merge" === n) if (Array.isArray(r)) for (l = 0, u = r.length; l < u; l += 1)gw(t, e, r[l], i); else gw(t, e, r, i); else t.json || VC.call(i, s) || !VC.call(e, s) || (t.line = o || t.line, t.lineStart = a || t.lineStart, t.position = h || t.position, dw(t, "duplicated mapping key")), "__proto__" === s ? Object.defineProperty(e, s, { configurable: !0, enumerable: !0, writable: !0, value: r }) : e[s] = r, delete i[s]; return e } function mw(t) { var e; 10 === (e = t.input.charCodeAt(t.position)) ? t.position++ : 13 === e ? (t.position++, 10 === t.input.charCodeAt(t.position) && t.position++) : dw(t, "a line break is expected"), t.line += 1, t.lineStart = t.position, t.firstTabInLine = -1 } function kw(t, e, i) { for (var n = 0, s = t.input.charCodeAt(t.position); 0 !== s;) { for (; nw(s);)9 === s && -1 === t.firstTabInLine && (t.firstTabInLine = t.position), s = t.input.charCodeAt(++t.position); if (e && 35 === s) for (; 10 !== (s = t.input.charCodeAt(++t.position)) && 13 !== s && 0 !== s;); if (!iw(s)) break; for (mw(t), s = t.input.charCodeAt(t.position), n++, t.lineIndent = 0; 32 === s;)t.lineIndent++, s = t.input.charCodeAt(++t.position) } return -1 !== i && 0 !== n && t.lineIndent < i && fw(t, "deficient indentation"), n } function bw(t) { var e, i = t.position; return 45 !== (e = t.input.charCodeAt(i)) && 46 !== e || e !== t.input.charCodeAt(i + 1) || e !== t.input.charCodeAt(i + 2) || (i += 3, 0 !== (e = t.input.charCodeAt(i)) && !sw(e)) ? void 0 : 1 } function xw(t, e) { 1 === e ? t.result += " " : 1 < e && (t.result += nC.repeat("\n", e - 1)) } function Cw(t, e) { var i, n, s = t.tag, r = t.anchor, o = [], a = !1; if (-1 !== t.firstTabInLine) return !1; for (null !== t.anchor && (t.anchorMap[t.anchor] = o), n = t.input.charCodeAt(t.position); 0 !== n && (-1 !== t.firstTabInLine && (t.position = t.firstTabInLine, dw(t, "tab characters must not be used in indentation")), 45 === n) && sw(t.input.charCodeAt(t.position + 1));)if (a = !0, t.position++, kw(t, !0, -1) && t.lineIndent <= e) o.push(null), n = t.input.charCodeAt(t.position); else if (i = t.line, Pw(t, e, UC, !1, !0), o.push(t.result), kw(t, !0, -1), n = t.input.charCodeAt(t.position), (t.line === i || t.lineIndent > e) && 0 !== n) dw(t, "bad indentation of a sequence entry"); else if (t.lineIndent < e) break; return !!a && (t.tag = s, t.anchor = r, t.kind = "sequence", t.result = o, !0) } function ww(e) { var t, i, n, s, r = !1, o = !1; if (33 === (s = e.input.charCodeAt(e.position))) { if (null !== e.tag && dw(e, "duplication of a tag property"), 60 === (s = e.input.charCodeAt(++e.position)) ? (r = !0, s = e.input.charCodeAt(++e.position)) : 33 === s ? (o = !0, i = "!!", s = e.input.charCodeAt(++e.position)) : i = "!", t = e.position, r) { for (; 0 !== (s = e.input.charCodeAt(++e.position)) && 62 !== s;); e.position < e.length ? (n = e.input.slice(t, e.position), s = e.input.charCodeAt(++e.position)) : dw(e, "unexpected end of the stream within a verbatim tag") } else { for (; 0 !== s && !sw(s);)33 === s && (o ? dw(e, "tag suffix cannot contain exclamation marks") : (i = e.input.slice(t - 1, e.position + 1), QC.test(i) || dw(e, "named tag handle cannot contain such characters"), o = !0, t = e.position + 1)), s = e.input.charCodeAt(++e.position); n = e.input.slice(t, e.position), ZC.test(n) && dw(e, "tag suffix cannot contain flow indicator characters") } n && !tw.test(n) && dw(e, "tag name cannot contain such characters: " + n); try { n = decodeURIComponent(n) } catch (t) { dw(e, "tag name is malformed: " + n) } return r ? e.tag = n : VC.call(e.tagMap, i) ? e.tag = e.tagMap[i] + n : "!" === i ? e.tag = "!" + n : "!!" === i ? e.tag = "tag:yaml.org,2002:" + n : dw(e, 'undeclared tag handle "' + i + '"'), 1 } } function Sw(t) { var e, i; if (38 === (i = t.input.charCodeAt(t.position))) { for (null !== t.anchor && dw(t, "duplication of an anchor property"), i = t.input.charCodeAt(++t.position), e = t.position; 0 !== i && !sw(i) && !rw(i);)i = t.input.charCodeAt(++t.position); return t.position === e && dw(t, "name of an anchor node must contain at least one character"), t.anchor = t.input.slice(e, t.position), 1 } } function Pw(t, e, i, n, s) { var r, o, a, h, l, u, c, d, f, p = 1, v = !1, g = !1; if (null !== t.listener && t.listener("open", t), t.tag = null, t.anchor = null, t.kind = null, t.result = null, r = o = a = HC === i || UC === i, n && kw(t, !0, -1) && (v = !0, t.lineIndent > e ? p = 1 : t.lineIndent === e ? p = 0 : t.lineIndent < e && (p = -1)), 1 === p) for (; ww(t) || Sw(t);)kw(t, !0, -1) ? (v = !0, a = r, t.lineIndent > e ? p = 1 : t.lineIndent === e ? p = 0 : t.lineIndent < e && (p = -1)) : a = !1; if (a = a && (v || s), 1 !== p && HC !== i || (d = XC === i || GC === i ? e : e + 1, f = t.position - t.lineStart, 1 === p ? a && (Cw(t, f) || function (t, e, i) { var n, s, r, o, a, h, l, u = t.tag, c = t.anchor, d = {}, f = Object.create(null), p = null, v = null, g = null, y = !1, m = !1; if (-1 === t.firstTabInLine) { for (null !== t.anchor && (t.anchorMap[t.anchor] = d), l = t.input.charCodeAt(t.position); 0 !== l;) { if (y || -1 === t.firstTabInLine || (t.position = t.firstTabInLine, dw(t, "tab characters must not be used in indentation")), n = t.input.charCodeAt(t.position + 1), r = t.line, 63 !== l && 58 !== l || !sw(n)) { if (o = t.line, a = t.lineStart, h = t.position, !Pw(t, i, GC, !1, !0)) break; if (t.line === r) { for (l = t.input.charCodeAt(t.position); nw(l);)l = t.input.charCodeAt(++t.position); if (58 === l) sw(l = t.input.charCodeAt(++t.position)) || dw(t, "a whitespace character is expected after the key-value separator within a block mapping"), y && (yw(t, d, f, p, v, null, o, a, h), p = v = g = null), s = y = !(m = !0), p = t.tag, v = t.result; else { if (!m) return t.tag = u, t.anchor = c, 1; dw(t, "can not read an implicit mapping pair; a colon is missed") } } else { if (!m) return t.tag = u, t.anchor = c, 1; dw(t, "can not read a block mapping entry; a multiline key may not be an implicit key") } } else 63 === l ? (y && (yw(t, d, f, p, v, null, o, a, h), p = v = g = null), s = y = m = !0) : y ? s = !(y = !1) : dw(t, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), t.position += 1, l = n; if ((t.line === r || t.lineIndent > e) && (y && (o = t.line, a = t.lineStart, h = t.position), Pw(t, e, HC, !0, s) && (y ? v = t.result : g = t.result), y || (yw(t, d, f, p, v, g, o, a, h), p = v = g = null), kw(t, !0, -1), l = t.input.charCodeAt(t.position)), (t.line === r || t.lineIndent > e) && 0 !== l) dw(t, "bad indentation of a mapping entry"); else if (t.lineIndent < e) break } return y && yw(t, d, f, p, v, null, o, a, h), m && (t.tag = u, t.anchor = c, t.kind = "mapping", t.result = d), m } }(t, f, d)) || function (t, e) { var i, n, s, r, o, a, h, l, u, c, d, f, p = !0, v = t.tag, g = t.anchor, y = Object.create(null); if (91 === (f = t.input.charCodeAt(t.position))) l = !(o = 93), r = []; else { if (123 !== f) return; o = 125, l = !0, r = {} } for (null !== t.anchor && (t.anchorMap[t.anchor] = r), f = t.input.charCodeAt(++t.position); 0 !== f;) { if (kw(t, !0, e), (f = t.input.charCodeAt(t.position)) === o) return t.position++, t.tag = v, t.anchor = g, t.kind = l ? "mapping" : "sequence", t.result = r, 1; p ? 44 === f && dw(t, "expected the node content, but found ','") : dw(t, "missed comma between flow collection entries"), d = null, a = h = !1, 63 === f && sw(t.input.charCodeAt(t.position + 1)) && (a = h = !0, t.position++, kw(t, !0, e)), i = t.line, n = t.lineStart, s = t.position, Pw(t, e, XC, !1, !0), c = t.tag, u = t.result, kw(t, !0, e), f = t.input.charCodeAt(t.position), !h && t.line !== i || 58 !== f || (a = !0, f = t.input.charCodeAt(++t.position), kw(t, !0, e), Pw(t, e, XC, !1, !0), d = t.result), l ? yw(t, r, y, c, u, d, i, n, s) : a ? r.push(yw(t, null, y, c, u, d, i, n, s)) : r.push(u), kw(t, !0, e), 44 === (f = t.input.charCodeAt(t.position)) ? (p = !0, f = t.input.charCodeAt(++t.position)) : p = !1 } dw(t, "unexpected end of the stream within a flow collection") }(t, d) ? g = !0 : (o && function (t, e) { var i, n, s, r, o, a = NC, h = !1, l = !1, u = e, c = 0, d = !1; if (124 === (r = t.input.charCodeAt(t.position))) n = !1; else { if (62 !== r) return; n = !0 } for (t.kind = "scalar", t.result = ""; 0 !== r;)if (43 === (r = t.input.charCodeAt(++t.position)) || 45 === r) NC === a ? a = 43 === r ? KC : JC : dw(t, "repeat of a chomping mode identifier"); else { if (!(0 <= (s = 48 <= (o = r) && o <= 57 ? o - 48 : -1))) break; 0 == s ? dw(t, "bad explicit indentation width of a block scalar; it cannot be less than one") : l ? dw(t, "repeat of an indentation width identifier") : (u = e + s - 1, l = !0) } if (nw(r)) { for (; nw(r = t.input.charCodeAt(++t.position));); if (35 === r) for (; !iw(r = t.input.charCodeAt(++t.position)) && 0 !== r;); } for (; 0 !== r;) { for (mw(t), t.lineIndent = 0, r = t.input.charCodeAt(t.position); (!l || t.lineIndent < u) && 32 === r;)t.lineIndent++, r = t.input.charCodeAt(++t.position); if (!l && t.lineIndent > u && (u = t.lineIndent), iw(r)) c++; else { if (t.lineIndent < u) { a === KC ? t.result += nC.repeat("\n", h ? 1 + c : c) : a === NC && h && (t.result += "\n"); break } for (n ? nw(r) ? (d = !0, t.result += nC.repeat("\n", h ? 1 + c : c)) : d ? (d = !1, t.result += nC.repeat("\n", c + 1)) : 0 === c ? h && (t.result += " ") : t.result += nC.repeat("\n", c) : t.result += nC.repeat("\n", h ? 1 + c : c), l = h = !0, c = 0, i = t.position; !iw(r) && 0 !== r;)r = t.input.charCodeAt(++t.position); vw(t, i, t.position, !1) } } return 1 }(t, d) || function (t, e) { var i, n, s; if (39 === (i = t.input.charCodeAt(t.position))) { for (t.kind = "scalar", t.result = "", t.position++, n = s = t.position; 0 !== (i = t.input.charCodeAt(t.position));)if (39 === i) { if (vw(t, n, t.position, !0), 39 !== (i = t.input.charCodeAt(++t.position))) return 1; n = t.position, t.position++, s = t.position } else iw(i) ? (vw(t, n, s, !0), xw(t, kw(t, !1, e)), n = s = t.position) : t.position === t.lineStart && bw(t) ? dw(t, "unexpected end of the document within a single quoted scalar") : (t.position++, s = t.position); dw(t, "unexpected end of the stream within a single quoted scalar") } }(t, d) || function (t, e) { var i, n, s, r, o, a; if (34 === (a = t.input.charCodeAt(t.position))) { for (t.kind = "scalar", t.result = "", t.position++, i = n = t.position; 0 !== (a = t.input.charCodeAt(t.position));) { if (34 === a) return vw(t, i, t.position, !0), t.position++, 1; if (92 === a) { if (vw(t, i, t.position, !0), iw(a = t.input.charCodeAt(++t.position))) kw(t, !1, e); else if (a < 256 && aw[a]) t.result += hw[a], t.position++; else if (0 < (o = 120 === (c = a) ? 2 : 117 === c ? 4 : 85 === c ? 8 : 0)) { for (s = o, r = 0; 0 < s; s--)a = t.input.charCodeAt(++t.position), u = void 0, 0 <= (o = 48 <= (l = a) && l <= 57 ? l - 48 : 97 <= (u = 32 | l) && u <= 102 ? u - 97 + 10 : -1) ? r = (r << 4) + o : dw(t, "expected hexadecimal character"); t.result += (h = r) <= 65535 ? String.fromCharCode(h) : String.fromCharCode(55296 + (h - 65536 >> 10), 56320 + (h - 65536 & 1023)), t.position++ } else dw(t, "unknown escape sequence"); i = n = t.position } else iw(a) ? (vw(t, i, n, !0), xw(t, kw(t, !1, e)), i = n = t.position) : t.position === t.lineStart && bw(t) ? dw(t, "unexpected end of the document within a double quoted scalar") : (t.position++, n = t.position) } var h, l, u, c; dw(t, "unexpected end of the stream within a double quoted scalar") } }(t, d) ? g = !0 : !function (t) { var e, i, n; if (42 === (n = t.input.charCodeAt(t.position))) { for (n = t.input.charCodeAt(++t.position), e = t.position; 0 !== n && !sw(n) && !rw(n);)n = t.input.charCodeAt(++t.position); return t.position === e && dw(t, "name of an alias node must contain at least one character"), i = t.input.slice(e, t.position), VC.call(t.anchorMap, i) || dw(t, 'unidentified alias "' + i + '"'), t.result = t.anchorMap[i], kw(t, !0, -1), 1 } }(t) ? function (t, e, i) { var n, s, r, o, a, h, l, u, c = t.kind, d = t.result; if (!sw(u = t.input.charCodeAt(t.position)) && !rw(u) && 35 !== u && 38 !== u && 42 !== u && 33 !== u && 124 !== u && 62 !== u && 39 !== u && 34 !== u && 37 !== u && 64 !== u && 96 !== u && (63 !== u && 45 !== u || !(sw(n = t.input.charCodeAt(t.position + 1)) || i && rw(n)))) { for (t.kind = "scalar", t.result = "", s = r = t.position, o = !1; 0 !== u;) { if (58 === u) { if (sw(n = t.input.charCodeAt(t.position + 1)) || i && rw(n)) break } else if (35 === u) { if (sw(t.input.charCodeAt(t.position - 1))) break } else { if (t.position === t.lineStart && bw(t) || i && rw(u)) break; if (iw(u)) { if (a = t.line, h = t.lineStart, l = t.lineIndent, kw(t, !1, -1), t.lineIndent >= e) { o = !0, u = t.input.charCodeAt(t.position); continue } t.position = r, t.line = a, t.lineStart = h, t.lineIndent = l; break } } o && (vw(t, s, r, !1), xw(t, t.line - a), s = r = t.position, o = !1), nw(u) || (r = t.position + 1), u = t.input.charCodeAt(++t.position) } if (vw(t, s, r, !1), t.result) return 1; t.kind = c, t.result = d } }(t, d, XC === i) && (g = !0, null === t.tag && (t.tag = "?")) : (g = !0, null === t.tag && null === t.anchor || dw(t, "alias node should not have any properties")), null !== t.anchor && (t.anchorMap[t.anchor] = t.result)) : 0 === p && (g = a && Cw(t, f))), null === t.tag) null !== t.anchor && (t.anchorMap[t.anchor] = t.result); else if ("?" === t.tag) { for (null !== t.result && "scalar" !== t.kind && dw(t, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + t.kind + '"'), h = 0, l = t.implicitTypes.length; h < l; h += 1)if ((c = t.implicitTypes[h]).resolve(t.result)) { t.result = c.construct(t.result), t.tag = c.tag, null !== t.anchor && (t.anchorMap[t.anchor] = t.result); break } } else if ("!" !== t.tag) { if (VC.call(t.typeMap[t.kind || "fallback"], t.tag)) c = t.typeMap[t.kind || "fallback"][t.tag]; else for (c = null, h = 0, l = (u = t.typeMap.multi[t.kind || "fallback"]).length; h < l; h += 1)if (t.tag.slice(0, u[h].tag.length) === u[h].tag) { c = u[h]; break } c || dw(t, "unknown tag !<" + t.tag + ">"), null !== t.result && c.kind !== t.kind && dw(t, "unacceptable node kind for !<" + t.tag + '> tag; it should be "' + c.kind + '", not "' + t.kind + '"'), c.resolve(t.result, t.tag) ? (t.result = c.construct(t.result, t.tag), null !== t.anchor && (t.anchorMap[t.anchor] = t.result)) : dw(t, "cannot resolve a node with !<" + t.tag + "> explicit tag") } return null !== t.listener && t.listener("close", t), null !== t.tag || null !== t.anchor || g } function Tw(t) { var e, i, n, s, r = t.position, o = !1; for (t.version = null, t.checkLineBreaks = t.legacy, t.tagMap = Object.create(null), t.anchorMap = Object.create(null); 0 !== (s = t.input.charCodeAt(t.position)) && (kw(t, !0, -1), s = t.input.charCodeAt(t.position), !(0 < t.lineIndent || 37 !== s));) { for (o = !0, s = t.input.charCodeAt(++t.position), e = t.position; 0 !== s && !sw(s);)s = t.input.charCodeAt(++t.position); for (n = [], (i = t.input.slice(e, t.position)).length < 1 && dw(t, "directive name must not be less than one character in length"); 0 !== s;) { for (; nw(s);)s = t.input.charCodeAt(++t.position); if (35 === s) { for (; 0 !== (s = t.input.charCodeAt(++t.position)) && !iw(s);); break } if (iw(s)) break; for (e = t.position; 0 !== s && !sw(s);)s = t.input.charCodeAt(++t.position); n.push(t.input.slice(e, t.position)) } 0 !== s && mw(t), VC.call(pw, i) ? pw[i](t, i, n) : fw(t, 'unknown document directive "' + i + '"') } kw(t, !0, -1), 0 === t.lineIndent && 45 === t.input.charCodeAt(t.position) && 45 === t.input.charCodeAt(t.position + 1) && 45 === t.input.charCodeAt(t.position + 2) ? (t.position += 3, kw(t, !0, -1)) : o && dw(t, "directives end mark is expected"), Pw(t, t.lineIndent - 1, HC, !1, !0), kw(t, !0, -1), t.checkLineBreaks && $C.test(t.input.slice(r, t.position)) && fw(t, "non-ASCII line breaks are interpreted as content"), t.documents.push(t.result), t.position === t.lineStart && bw(t) ? 46 === t.input.charCodeAt(t.position) && (t.position += 3, kw(t, !0, -1)) : t.position < t.length - 1 && dw(t, "end of the stream or a document separator is expected") } function Ow(t, e) { e = e || {}, 0 !== (t = String(t)).length && (10 !== t.charCodeAt(t.length - 1) && 13 !== t.charCodeAt(t.length - 1) && (t += "\n"), 65279 === t.charCodeAt(0) && (t = t.slice(1))); var i = new uw(t, e), n = t.indexOf("\0"); for (-1 !== n && (i.position = n, dw(i, "null byte is not allowed in input")), i.input += "\0"; 32 === i.input.charCodeAt(i.position);)i.lineIndent += 1, i.position += 1; for (; i.position < i.length - 1;)Tw(i); return i.documents } var Mw = { loadAll: function (t, e, i) { null !== e && "object" == typeof e && void 0 === i && (i = e, e = null); var n = Ow(t, i); if ("function" != typeof e) return n; for (var s = 0, r = n.length; s < r; s += 1)e(n[s]) }, load: function (t, e) { var i = Ow(t, e); if (0 !== i.length) { if (1 === i.length) return i[0]; throw new oC("expected a single document in the stream, but found more") } } }, Ew = Object.prototype.toString, _w = Object.prototype.hasOwnProperty, Bw = 65279, Iw = 9, Rw = 10, Aw = 13, Dw = 32, Lw = 33, zw = 34, jw = 35, Fw = 37, Yw = 38, Ww = 39, Vw = 42, Xw = 44, Gw = 45, Uw = 58, Hw = 61, Nw = 62, Jw = 63, Kw = 64, qw = 91, $w = 93, Zw = 96, Qw = 123, tS = 124, eS = 125, iS = { 0: "\\0", 7: "\\a", 8: "\\b", 9: "\\t", 10: "\\n", 11: "\\v", 12: "\\f", 13: "\\r", 27: "\\e", 34: '\\"', 92: "\\\\", 133: "\\N", 160: "\\_", 8232: "\\L", 8233: "\\P" }, nS = ["y", "Y", "yes", "Yes", "YES", "on", "On", "ON", "n", "N", "no", "No", "NO", "off", "Off", "OFF"], sS = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/; function rS(t) { var e, i, n; if (e = t.toString(16).toUpperCase(), t <= 255) i = "x", n = 2; else if (t <= 65535) i = "u", n = 4; else { if (!(t <= 4294967295)) throw new oC("code point within a string may not be greater than 0xFFFFFFFF"); i = "U", n = 8 } return "\\" + i + nC.repeat("0", n - e.length) + e } var oS = 1, aS = 2; function hS(t) { this.schema = t.schema || WC, this.indent = Math.max(1, t.indent || 2), this.noArrayIndent = t.noArrayIndent || !1, this.skipInvalid = t.skipInvalid || !1, this.flowLevel = nC.isNothing(t.flowLevel) ? -1 : t.flowLevel, this.styleMap = function (t, e) { var i, n, s, r, o, a, h; if (null === e) return {}; for (i = {}, s = 0, r = (n = Object.keys(e)).length; s < r; s += 1)o = n[s], a = String(e[o]), "!!" === o.slice(0, 2) && (o = "tag:yaml.org,2002:" + o.slice(2)), (h = t.compiledTypeMap.fallback[o]) && _w.call(h.styleAliases, a) && (a = h.styleAliases[a]), i[o] = a; return i }(this.schema, t.styles || null), this.sortKeys = t.sortKeys || !1, this.lineWidth = t.lineWidth || 80, this.noRefs = t.noRefs || !1, this.noCompatMode = t.noCompatMode || !1, this.condenseFlow = t.condenseFlow || !1, this.quotingType = '"' === t.quotingType ? aS : oS, this.forceQuotes = t.forceQuotes || !1, this.replacer = "function" == typeof t.replacer ? t.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null } function lS(t, e) { for (var i, n = nC.repeat(" ", e), s = 0, r = -1, o = "", a = t.length; s < a;)s = -1 === (r = t.indexOf("\n", s)) ? (i = t.slice(s), a) : (i = t.slice(s, r + 1), r + 1), i.length && "\n" !== i && (o += n), o += i; return o } function uS(t, e) { return "\n" + nC.repeat(" ", t.indent * e) } function cS(t) { return t === Dw || t === Iw } function dS(t) { return 32 <= t && t <= 126 || 161 <= t && t <= 55295 && 8232 !== t && 8233 !== t || 57344 <= t && t <= 65533 && t !== Bw || 65536 <= t && t <= 1114111 } function fS(t) { return dS(t) && t !== Bw && t !== Aw && t !== Rw } function pS(t, e, i) { var n = fS(t), s = n && !cS(t); return (i ? n : n && t !== Xw && t !== qw && t !== $w && t !== Qw && t !== eS) && t !== jw && !(e === Uw && !s) || fS(e) && !cS(e) && t === jw || e === Uw && s } function vS(t, e) { var i, n = t.charCodeAt(e); return 55296 <= n && n <= 56319 && e + 1 < t.length && 56320 <= (i = t.charCodeAt(e + 1)) && i <= 57343 ? 1024 * (n - 55296) + i - 56320 + 65536 : n } function gS(t) { return /^\n* /.test(t) } var yS = 1, mS = 2, kS = 3, bS = 4, xS = 5; function CS(t, e, i, n, s, r, o, a) { var h, l, u, c = 0, d = null, f = !1, p = !1, v = -1 !== n, g = -1, y = dS(u = vS(t, 0)) && u !== Bw && !cS(u) && u !== Gw && u !== Jw && u !== Uw && u !== Xw && u !== qw && u !== $w && u !== Qw && u !== eS && u !== jw && u !== Yw && u !== Vw && u !== Lw && u !== tS && u !== Hw && u !== Nw && u !== Ww && u !== zw && u !== Fw && u !== Kw && u !== Zw && (!cS(l = vS(t, t.length - 1)) && l !== Uw); if (e || o) for (h = 0; h < t.length; 65536 <= c ? h += 2 : h++) { if (!dS(c = vS(t, h))) return xS; y = y && pS(c, d, a), d = c } else { for (h = 0; h < t.length; 65536 <= c ? h += 2 : h++) { if ((c = vS(t, h)) === Rw) f = !0, v && (p = p || n < h - g - 1 && " " !== t[g + 1], g = h); else if (!dS(c)) return xS; y = y && pS(c, d, a), d = c } p = p || v && n < h - g - 1 && " " !== t[g + 1] } return f || p ? 9 < i && gS(t) ? xS : o ? r === aS ? xS : mS : p ? bS : kS : !y || o || s(t) ? r === aS ? xS : mS : yS } function wS(n, s, r, o, a) { n.dump = function () { if (0 === s.length) return n.quotingType === aS ? '""' : "''"; if (!n.noCompatMode && (-1 !== nS.indexOf(s) || sS.test(s))) return n.quotingType === aS ? '"' + s + '"' : "'" + s + "'"; var t = n.indent * Math.max(1, r), e = -1 === n.lineWidth ? -1 : Math.max(Math.min(n.lineWidth, 40), n.lineWidth - t), i = o || -1 < n.flowLevel && r >= n.flowLevel; switch (CS(s, i, n.indent, e, function (t) { return function (t, e) { var i, n; for (i = 0, n = t.implicitTypes.length; i < n; i += 1)if (t.implicitTypes[i].resolve(e)) return !0; return !1 }(n, t) }, n.quotingType, n.forceQuotes && !o, a)) { case yS: return s; case mS: return "'" + s.replace(/'/g, "''") + "'"; case kS: return "|" + SS(s, n.indent) + PS(lS(s, t)); case bS: return ">" + SS(s, n.indent) + PS(lS(function (e, i) { var t, n, s = /(\n+)([^\n]*)/g, r = function () { var t = e.indexOf("\n"); return t = -1 !== t ? t : e.length, s.lastIndex = t, TS(e.slice(0, t), i) }(), o = "\n" === e[0] || " " === e[0]; for (; n = s.exec(e);) { var a = n[1], h = n[2]; t = " " === h[0], r += a + (o || t || "" === h ? "" : "\n") + TS(h, i), o = t } return r }(s, e), t)); case xS: return '"' + function (t) { for (var e, i = "", n = 0, s = 0; s < t.length; 65536 <= n ? s += 2 : s++)n = vS(t, s), !(e = iS[n]) && dS(n) ? (i += t[s], 65536 <= n && (i += t[s + 1])) : i += e || rS(n); return i }(s) + '"'; default: throw new oC("impossible error: invalid scalar style") } }() } function SS(t, e) { var i = gS(t) ? String(e) : "", n = "\n" === t[t.length - 1]; return i + (n && ("\n" === t[t.length - 2] || "\n" === t) ? "+" : n ? "" : "-") + "\n" } function PS(t) { return "\n" === t[t.length - 1] ? t.slice(0, -1) : t } function TS(t, e) { if ("" === t || " " === t[0]) return t; for (var i, n, s = / [^ ]/g, r = 0, o = 0, a = 0, h = ""; i = s.exec(t);)e < (a = i.index) - r && (n = r < o ? o : a, h += "\n" + t.slice(r, n), r = n + 1), o = a; return h += "\n", t.length - r > e && r < o ? h += t.slice(r, o) + "\n" + t.slice(o + 1) : h += t.slice(r), h.slice(1) } function OS(t, e, i, n) { var s, r, o, a = "", h = t.tag; for (s = 0, r = i.length; s < r; s += 1)o = i[s], t.replacer && (o = t.replacer.call(i, String(s), o)), (ES(t, e + 1, o, !0, !0, !1, !0) || void 0 === o && ES(t, e + 1, null, !0, !0, !1, !0)) && (n && "" === a || (a += uS(t, e)), t.dump && Rw === t.dump.charCodeAt(0) ? a += "-" : a += "- ", a += t.dump); t.tag = h, t.dump = a || "[]" } function MS(t, e, i) { var n, s, r, o, a, h; for (r = 0, o = (s = i ? t.explicitTypes : t.implicitTypes).length; r < o; r += 1)if (((a = s[r]).instanceOf || a.predicate) && (!a.instanceOf || "object" == typeof e && e instanceof a.instanceOf) && (!a.predicate || a.predicate(e))) { if (i ? a.multi && a.representName ? t.tag = a.representName(e) : t.tag = a.tag : t.tag = "?", a.represent) { if (h = t.styleMap[a.tag] || a.defaultStyle, "[object Function]" === Ew.call(a.represent)) n = a.represent(e, h); else { if (!_w.call(a.represent, h)) throw new oC("!<" + a.tag + '> tag resolver accepts not "' + h + '" style'); n = a.represent[h](e, h) } t.dump = n } return 1 } } function ES(t, e, i, n, s, r, o) { t.tag = null, t.dump = i, MS(t, i, !1) || MS(t, i, !0); var a, h = Ew.call(t.dump), l = n; n = n && (t.flowLevel < 0 || t.flowLevel > e); var u, c, d = "[object Object]" === h || "[object Array]" === h; if (d && (c = -1 !== (u = t.duplicates.indexOf(i))), (null !== t.tag && "?" !== t.tag || c || 2 !== t.indent && 0 < e) && (s = !1), c && t.usedDuplicates[u]) t.dump = "*ref_" + u; else { if (d && c && !t.usedDuplicates[u] && (t.usedDuplicates[u] = !0), "[object Object]" === h) n && 0 !== Object.keys(t.dump).length ? (function (t, e, i, n) { var s, r, o, a, h, l, u = "", c = t.tag, d = Object.keys(i); if (!0 === t.sortKeys) d.sort(); else if ("function" == typeof t.sortKeys) d.sort(t.sortKeys); else if (t.sortKeys) throw new oC("sortKeys must be a boolean or a function"); for (s = 0, r = d.length; s < r; s += 1)l = "", n && "" === u || (l += uS(t, e)), a = i[o = d[s]], t.replacer && (a = t.replacer.call(i, o, a)), ES(t, e + 1, o, !0, !0, !0) && ((h = null !== t.tag && "?" !== t.tag || t.dump && 1024 < t.dump.length) && (t.dump && Rw === t.dump.charCodeAt(0) ? l += "?" : l += "? "), l += t.dump, h && (l += uS(t, e)), ES(t, e + 1, a, !0, h) && (t.dump && Rw === t.dump.charCodeAt(0) ? l += ":" : l += ": ", u += l += t.dump)); t.tag = c, t.dump = u || "{}" }(t, e, t.dump, s), c && (t.dump = "&ref_" + u + t.dump)) : (function (t, e, i) { var n, s, r, o, a, h = "", l = t.tag, u = Object.keys(i); for (n = 0, s = u.length; n < s; n += 1)(a = "") !== h && (a += ", "), t.condenseFlow && (a += '"'), o = i[r = u[n]], t.replacer && (o = t.replacer.call(i, r, o)), ES(t, e, r, !1, !1) && (1024 < t.dump.length && (a += "? "), a += t.dump + (t.condenseFlow ? '"' : "") + ":" + (t.condenseFlow ? "" : " "), ES(t, e, o, !1, !1) && (h += a += t.dump)); t.tag = l, t.dump = "{" + h + "}" }(t, e, t.dump), c && (t.dump = "&ref_" + u + " " + t.dump)); else if ("[object Array]" === h) n && 0 !== t.dump.length ? (t.noArrayIndent && !o && 0 < e ? OS(t, e - 1, t.dump, s) : OS(t, e, t.dump, s), c && (t.dump = "&ref_" + u + t.dump)) : (function (t, e, i) { var n, s, r, o = "", a = t.tag; for (n = 0, s = i.length; n < s; n += 1)r = i[n], t.replacer && (r = t.replacer.call(i, String(n), r)), (ES(t, e, r, !1, !1) || void 0 === r && ES(t, e, null, !1, !1)) && ("" !== o && (o += "," + (t.condenseFlow ? "" : " ")), o += t.dump); t.tag = a, t.dump = "[" + o + "]" }(t, e, t.dump), c && (t.dump = "&ref_" + u + " " + t.dump)); else { if ("[object String]" !== h) { if ("[object Undefined]" === h) return; if (t.skipInvalid) return; throw new oC("unacceptable kind of an object to dump " + h) } "?" !== t.tag && wS(t, t.dump, e, r, l) } null !== t.tag && "?" !== t.tag && (a = encodeURI("!" === t.tag[0] ? t.tag.slice(1) : t.tag).replace(/!/g, "%21"), a = "!" === t.tag[0] ? "!" + a : "tag:yaml.org,2002:" === a.slice(0, 18) ? "!!" + a.slice(18) : "!<" + a + ">", t.dump = a + " " + t.dump) } return 1 } function _S(t, e) { var i, n, s = [], r = []; for (!function t(e, i, n) { var s, r, o; if (null !== e && "object" == typeof e) if (-1 !== (r = i.indexOf(e))) -1 === n.indexOf(r) && n.push(r); else if (i.push(e), Array.isArray(e)) for (r = 0, o = e.length; r < o; r += 1)t(e[r], i, n); else for (s = Object.keys(e), r = 0, o = s.length; r < o; r += 1)t(e[s[r]], i, n) }(t, s, r), i = 0, n = r.length; i < n; i += 1)e.duplicates.push(s[r[i]]); e.usedDuplicates = new Array(n) } function BS(t, e) { return function () { throw new Error("Function yaml." + t + " is removed in js-yaml 4. Use yaml." + e + " instead, which is now safe by default.") } } function IS(t) { if ("string" == typeof t) try { return XS.load(t) } catch (t) { return void console.log(t) } return t } function RS(t, e) { if (void 0 === e) return t; if (t.hasOwnProperty("name") && GS(t, e["#".concat(t.name)]), t.hasOwnProperty("$class")) for (var i = t.$class.split(" "), n = 0, s = i.length; n < s; n++)GS(t, e[".".concat(i[n])]); return t.hasOwnProperty("$type") && GS(t, e[t.$type]), t } function AS(i, t) { for (var e = 0, n = US.length; e < n; e++) { var s = US[e], r = t[s]; void 0 !== r && (i[s] = r) } return t.cropResize && !i.resize && (i.resize = function (t, e) { return i.setCrop(0, 0, t, e), i }), i } function DS(t, e, i, n, s, r) { var o = new r(t, 0, 0, (e = RS(e, n)).key, e.frame); return void 0 !== e.width && o.setDisplayWidth(e.width), void 0 !== e.height && o.setDisplayHeight(e.height), AS(o, e), t.add.existing(o), o } function LS(t, e, i, n, s, r) { var o, a = e[i]; return a && (o = $S(t, a, n, s, r), e[i] = o) } function zS(t, e, i, n, s) { if (e) { Array.isArray(e) || (e = [e]); for (var r = 0, o = e.length; r < o; r++) { var a = e[r]; a.$child || (a = { $child: a }, e[r] = a), LS(t, a, "$child", i, n, s) } } return e } function jS(t, e, i, n, s, r) { e = RS(e, n); var o = zS(t, e.background, i, n, s), a = zS(t, e.children, i, n, s), h = new r(t, e); if (t.add.existing(h), o) for (var l = 0, u = o.length; l < u; l++) { var c = o[l]; h.addBackground(c.$child, c.padding) } if (a) for (l = 0, u = a.length; l < u; l++) { c = a[l]; h.add(c.$child, c) } return h } function FS(t, e, i, n, s, r) { var o = e[i]; if (o) { if (Array.isArray(o)) for (var a = 0, h = o.length; a < h; a++)(Array.isArray(o[a]) ? FS : LS)(t, o, a, n, s, r); else for (var l in o) LS(t, o, l, n, s, r); return o } } function YS(t, e, i, n, s, r) { e = RS(e, n), LS(t, e, "background", i, n, s), LS(t, e, "icon", i, n, s), LS(t, e, "text", i, n, s), LS(t, e, "action", i, n, s); var o = new r(t, e); return t.add.existing(o), o } function WS(t, e, i, n, s) { return e && (LS(t, e, "background", i, n, s), LS(t, e, "track", i, n, s), LS(t, e, "indicator", i, n, s), LS(t, e, "thumb", i, n, s)), e } function VS(t, e, i, n, s) { if (e = IS(e), Array.isArray(e)) e = e[e.length - 1]; else if (e.$root) { var r = e; if (e = e.$root, delete r.$root, void 0 === n) n = r; else for (var o in r) n[o] || (n[o] = r[o]) } return n = IS(n), $S(t, e, i, n, s) } var XS = { Type: dC, Schema: vC, FAILSAFE_SCHEMA: kC, JSON_SCHEMA: TC, CORE_SCHEMA: OC, DEFAULT_SCHEMA: WC, load: Mw.load, loadAll: Mw.loadAll, dump: { dump: function (t, e) { var i = new hS(e = e || {}); i.noRefs || _S(t, i); var n = t; return i.replacer && (n = i.replacer.call({ "": n }, "", n)), ES(i, 0, n, !0, !0) ? i.dump + "\n" : "" } }.dump, YAMLException: oC, types: { binary: RC, float: PC, map: mC, null: bC, pairs: jC, set: YC, timestamp: _C, bool: xC, int: CC, merge: BC, omap: LC, seq: yC, str: gC }, safeLoad: BS("safeLoad", "load"), safeLoadAll: BS("safeLoadAll", "loadAll"), safeDump: BS("safeDump", "dump") }, GS = function t(e, i) { if (void 0 === i) return e; for (var n in i) if (e.hasOwnProperty(n)) { var s = e[n]; s && "object" === P(s) && t(s, i[n]) } else e[n] = E(i[n]); return e }, US = ["tint", "alpha", "visible", "flipX", "flipY"], HS = Phaser.GameObjects.Image, NS = Phaser.GameObjects.Sprite, JS = Phaser.GameObjects.Video, KS = Phaser.GameObjects.Text, qS = { Image: function (t, e, i, n) { return DS(t, e, 0, n, 0, HS) }, Sprite: function (t, e, i, n) { return DS(t, e, 0, n, 0, NS) }, Video: function (t, e, i, n) { e = RS(e, n); var s = new JS(t, 0, 0, e.key); return void 0 !== e.width && s.setDisplayWidth(e.width), void 0 !== e.height && s.setDisplayHeight(e.height), AS(s, e), t.add.existing(s), s }, Text: function (t, e, i, n) { e = RS(e, n); var s = new KS(t, 0, 0, e.text, e); return AS(s, e), t.add.existing(s), s }, BBCodeText: function (t, e, i, n) { e = RS(e, n); var s = new Xn(t, 0, 0, e.text, e); return AS(s, e), t.add.existing(s), s }, RoundRectangle: function (t, e, i, n) { e = RS(e, n); var s = new Wt(t, e); return t.add.existing(s), s }, Ninepatch: function (t, e, i, n) { e = RS(e, n); var s = new B(t, e); return AS(s, e), t.add.existing(s), s }, Ninepatch2: function (t, e, i, n) { e = RS(e, n); var s = new bt(t, e); return t.add.existing(s), s }, Canvas: function (t, e, i, n) { var s = (e = RS(e, n)).width || 1, r = e.height || 1, o = new $t(t, 0, 0, s, r); return void 0 !== e.fill && o.fill(e.fill), AS(o, e), t.add.existing(o), o }, CircleMaskImage: function (t, e, i, n) { e = RS(e, n); var s = new pr(t, 0, 0, e.key, e.frame, e); return void 0 !== e.width && s.setDisplayWidth(e.width), void 0 !== e.height && s.setDisplayHeight(e.height), AS(s, e), t.add.existing(s), s }, Space: function (t) { return new uv(t) }, Sizer: function (t, e, i, n, s) { return jS(t, e, i, n, s, wv) }, FixWidthSizer: function (t, e, i, n, s) { return jS(t, e, i, n, s, tg) }, GridSizer: function (t, e, o, a, h) { var l = e.createCellContainerCallback; if (l) { var u = l.$child; delete l.$child, e.createCellContainerCallback = function (t, e, i, n) { var s = $S(t, u, o, a, h); for (var r in l) n[r] = l[r]; return s } } return jS(t, e, o, a, h, Fv) }, OverlapSizer: function (t, e, i, n, s) { return jS(t, e, i, n, s, Gf) }, Buttons: function (t, e, i, n, s) { e = RS(e, n), LS(t, e, "background", i, n, s), FS(t, e, "buttons", i, n, s); var r = new Pg(t, e); return t.add.existing(r), r }, FixWidthButtons: function (t, e, i, n, s) { e = RS(e, n), LS(t, e, "background", i, n, s), FS(t, e, "buttons", i, n, s); var r = new Vg(t, e); return t.add.existing(r), r }, GridButtons: function (t, e, o, a, h) { e = RS(e, a), LS(t, e, "background", o, a, h); var i = e.buttons; if (i) for (var n = 0, s = i.length; n < s; n++)FS(t, i, n, o, a, h); var l = e.createCellContainerCallback; if (l) { var u = l.$child; delete l.$child, e.createCellContainerCallback = function (t, e, i, n) { var s = $S(t, u, o, a, h); for (var r in l) n[r] = l[r]; return s } } var r = new Rg(t, e); return t.add.existing(r), r }, Label: function (t, e, i, n, s) { return YS(t, e, i, n, s, sg) }, BadgeLabel: function (t, e, i, n, s) { e = RS(e, n), LS(t, e, "background", i, n, s), LS(t, e, "main", i, n, s), LS(t, e, "leftTop", i, n, s), LS(t, e, "centerTop", i, n, s), LS(t, e, "rightTop", i, n, s), LS(t, e, "leftCenter", i, n, s), LS(t, e, "center", i, n, s), LS(t, e, "rightCenter", i, n, s), LS(t, e, "leftBottom", i, n, s), LS(t, e, "centerBottom", i, n, s), LS(t, e, "rightBottom", i, n, s); var r = new Rk(t, e); return t.add.existing(r), r }, Dialog: function (t, e, i, n, s) { e = RS(e, n), LS(t, e, "background", i, n, s), LS(t, e, "toolbarBackground", i, n, s), LS(t, e, "leftToolbarBackground", i, n, s), LS(t, e, "choicesBackground", i, n, s), LS(t, e, "actionsBackground", i, n, s), LS(t, e, "title", i, n, s), FS(t, e, "toolbar", i, n, s), FS(t, e, "leftToolbar", i, n, s), LS(t, e, "content", i, n, s), LS(t, e, "description", i, n, s), FS(t, e, "choices", i, n, s), FS(t, e, "actions", i, n, s); var r = new Ug(t, e); return t.add.existing(r), r }, TextBox: function (t, e, i, n, s) { return YS(t, e, i, n, s, Ok) }, Slider: function (t, e, i, n, s) { e = RS(e, n), LS(t, e, "background", i, n, s), LS(t, e, "track", i, n, s), LS(t, e, "indicator", i, n, s), LS(t, e, "thumb", i, n, s); var r = new xy(t, e); return t.add.existing(r), r }, NumberBar: function (t, e, i, n, s) { e = RS(e, n), LS(t, e, "background", i, n, s), LS(t, e, "icon", i, n, s), WS(t, e.slider, i, n, s), LS(t, e, "text", i, n, s); var r = new _k(t, e); return t.add.existing(r), r }, ScrollBar: function (t, e, i, n, s) { e = RS(e, n), LS(t, e, "background", i, n, s), WS(t, e.slider, i, n, s); var r = e.buttons; r && (LS(t, r, "top", i, n, s), LS(t, r, "bottom", i, n, s), LS(t, r, "left", i, n, s), LS(t, r, "right", i, n, s)); var o = new My(t, e); return t.add.existing(o), o }, TextArea: function (t, e, i, n, s) { e = RS(e, n), LS(t, e, "background", i, n, s), LS(t, e, "text", i, n, s), WS(t, e.slider, i, n, s), LS(t, e, "header", i, n, s), LS(t, e, "footer", i, n, s); var r = new hb(t, e); return t.add.existing(r), r }, Pages: function (t, e, i, n, s) { return jS(t, e, i, n, s, Yk) }, Toast: function (t, e, i, n, s) { return YS(t, e, i, n, s, Ib) }, Knob: function (t, e, i, n, s) { e = RS(e, n), LS(t, e, "background", i, n, s), LS(t, e, "text", i, n, s); var r = new dp(t, e); return t.add.existing(r), r }, HolyGrail: function (t, e, i, n, s) { e = RS(e, n), LS(t, e, "background", i, n, s), LS(t, e, "content", i, n, s), LS(t, e, "leftSide", i, n, s), LS(t, e, "rightSide", i, n, s), LS(t, e, "header", i, n, s), LS(t, e, "footer", i, n, s); var r = new Jg(t, e); return t.add.existing(r), r }, Menu: function (t, e, o, a, h) { var i = (e = RS(e, a)).background; delete e.background, i && (e.createBackgroundCallback = function (t) { var e = t.scene; return $S(e, E(i), o, a, h) }), e.createButtonCallback = function (t, e, i) { var n = t.scene, s = t.$next; delete t.scene, delete t.$next; var r = $S(n, E(t), o, a, h); return t.scene = n, t.$next = s, r }, e.childrenKey = "$next"; var n = new Hm(t, e); return t.add.existing(n), n } }, $S = function (t, e, i, n, s) { var r = function (t, e) { if (t.hasOwnProperty("$type")) return t.$type; if (t.hasOwnProperty("name") && ((r = e["#".concat(t.name)]) && r.hasOwnProperty("$type"))) return r.$type; if (t.hasOwnProperty("$class")) for (var i = t.$class.split(" "), n = 0, s = i.length; n < s; n++) { var r; if ((r = e[".".concat(i[n])]) && r.hasOwnProperty("$type")) return r.$type } }(e, n); if (r) { var o; if (s && (o = s[r]), o = o || qS[r]) { var a = o(t, e, i, n, s); return e.name && a.setName(e.name), a } console.warn("rexUI.Make: Can't create ".concat(r, " game object.")) } else console.warn("rexUI.Make: Can't get type name in ".concat(JSON.stringify(e))) }, ZS = Phaser.Utils.Objects.IsPlainObject, QS = function () { function n(t, e, i) { z(this, n), this.setScene(t), this.setStyles(e), this.setBuilders(i) } return k(n, [{ key: "setScene", value: function (t) { return this.scene = t, this } }, { key: "setStyles", value: function (t) { return this.styles = IS(t), this } }, { key: "addStyle", value: function (t, e) { if (void 0 === this.styles && (this.styles = {}), "string" == typeof t && void 0 === e && (t = IS(t)), ZS(t)) { var i = t; for (t in i) this.styles[t] = i[t] } else this.styles[t] = IS(e); return this } }, { key: "clearStyles", value: function () { return this.setStyles(), this } }, { key: "setBuilders", value: function (t) { return this.customBuilders = t, this } }, { key: "addBuilder", value: function (t, e) { if (void 0 === this.customBuilders && (this.customBuilders = {}), ZS(t)) { var i = t; for (t in i) this.customBuilders[t] = i[t] } else this.customBuilders[t] = e; return this } }, { key: "clearBuilder", value: function () { return this.setBuilders(), this } }, { key: "make", value: function (t, e) { return VS(this.scene, t, e, this.styles, this.customBuilders) } }]), n }(); c.register("maker", function (t, e) { return new QS(this.scene, t, e) }), R(window, "RexPlugins.UI.Maker", QS); function tP(t, e, i) { if (null == e) return t; if (0 === e) return hP(t, 0, i), t; var n = t.text.length; if (0 === n) return hP(t, e, i), t; for (var s = Math.floor(1.5 * e / n), r = {}, o = aP(t, s, e, i, r), a = 0; a <= 65535 && 0 !== o; a++) { if ((s += o) < 0) { s = 0; break } o = aP(t, s, e, i, r) } return 65535 === a && console.warn("FontSizeResize: Test count exceeds ".concat(65535)), t.setFontSize(s), hP(t, e, i), t } function eP(t, e, i) { return void 0 === i[e] && (t.setFontSize(e), i[e] = { width: t.width, height: t.height }), i[e] } var iP = Phaser.Utils.Objects.GetValue, nP = function (t) { return t.hasOwnProperty("align") ? t.align : t.hasOwnProperty("halign") ? t.halign : "left" }, sP = Phaser.Utils.Objects.GetValue, rP = void 0, oP = function () { w(n, Ta); var i = T(n); function n(t) { var e; return z(this, n), (e = i.call(this, t, { eventEmitter: !1 })).inputText = void 0, e.onClose = void 0, e.delayCall = void 0, e } return k(n, [{ key: "shutdown", value: function (t) { this.isShutdown || (this.close(), rP === this && (rP = void 0), O(C(n.prototype), "shutdown", this).call(this, t)) } }, { key: "open", value: function (t, e) { void 0 !== rP && rP.close(), rP = this, Iu(t) && (e = t, t = void 0), void 0 === e && (e = sP(t, "onClose", void 0)); var i = sP(t, "onOpen", void 0), n = sP(t, "onTextChanged", void 0); return this.inputText = function (t, e) { void 0 === e && (e = {}); var i = t.scene, n = t.style, s = iP(e, "backgroundColor", n.backgroundColor); null === s && (s = "transparent"), e.text = iP(e, "text", t.text), e.fontFamily = iP(e, "fontFamily", n.fontFamily), e.fontSize = iP(e, "fontSize", n.fontSize), e.color = iP(e, "color", n.color), e.backgroundColor = s, e.direction = iP(e, "rtl", n.rtl) ? "rtl" : "ltr", e.align = iP(e, "align", nP(n)), "rtl" === e.direction && rk(t) && (e.align = "right"); var r = new us(i, t.x, t.y, iP(e, "width", t.width), iP(e, "height", t.height), e); return r.setOrigin(t.originX, t.originY), i.add.existing(r), r }(this.parent, t).on("textchange", function (t) { var e = t.text; n ? n(this.parent, e) : this.parent.text = e }, this).setFocus(), this.parent.setVisible(!1), this.onClose = e, sP(t, "enterClose", !0) && this.scene.input.keyboard.once("keydown-ENTER", this.close, this), this.delayCall = this.scene.time.delayedCall(0, function () { this.scene.input.once("pointerdown", this.close, this), i && i(this.parent) }, [], this), this } }, { key: "close", value: function () { return rP = void 0, this.inputText && (this.parent.setVisible(!0), this.inputText.destroy(), this.inputText = void 0, this.delayCall && (this.delayCall.remove(), this.delayCall = void 0), this.scene.input.keyboard.off("keydown-ENTER", this.close, this), this.scene.input.off("pointerdown", this.close, this), this.onClose && this.onClose(this.parent)), this } }, { key: "isOpened", get: function () { return void 0 !== this.inputText } }, { key: "text", get: function () { return this.isOpened ? this.inputText.text : this.parent.text } }]), n }(), aP = function (t, e, i, n, s) { var r = eP(t, e, s), o = eP(t, e + 1, s); if (void 0 !== n) { if (r.height <= n && o.height > n) return 0; if (r.height > n) return -1 } return r.width <= i && o.width > i ? 0 : r.width > i ? -1 : Math.floor(i - r.width) }, hP = function (t, e, i) { var n = t.style; n.fixedWidth = e, n.parent.width = e, void 0 !== i && (n.fixedHeight = i, n.parent.height = i), n.update(!1) }, lP = function (t, e) { yu(t, e) }, uP = function (t, e) { mu(t, e, void 0, void 0, !1) }, cP = function (t, e) { bu(t, e) }, dP = function (t, e) { xu(t, e, !1) }, fP = function () { w(s, Zc); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, e)).parent = t, i.init(), i } return k(s, [{ key: "init", value: function () { this.start("IDLE") } }, { key: "next_IDLE", value: function () { return "TRANS_OPNE" } }, { key: "next_TRANS_OPNE", value: function () { return "OPEN" } }, { key: "enter_TRANS_OPNE", value: function () { var t = this.parent; t.transitionIn(), t.delayCall(t.transitInTime, this.next, this) } }, { key: "exit_TRANS_OPNE", value: function () { this.parent.removeDelayCall() } }, { key: "next_OPEN", value: function () { return "TRANS_CLOSE" } }, { key: "enter_OPEN", value: function () { var t = this.parent, e = t.displayTime; 0 <= e && t.delayCall(e, t.requestClose, t), t.onOpen() } }, { key: "exit_OPEN", value: function () { this.parent.removeDelayCall() } }, { key: "next_TRANS_CLOSE", value: function () { return "CLOSE" } }, { key: "enter_TRANS_CLOSE", value: function () { var t = this.parent; t.transitionOut(), t.delayCall(t.transitOutTime, this.next, this) } }, { key: "exit_TRANS_CLOSE", value: function () { this.parent.removeDelayCall() } }, { key: "next_CLOSE", value: function () { } }, { key: "enter_CLOSE", value: function () { this.parent.onClose() } }, { key: "exit_CLOSE", value: function () { } }]), s }(), pP = Phaser.Utils.Objects.GetValue; Phaser.Time.TimerEvent; function vP(e, t) { var i = new gP(e, t); return i.on("open", function () { e.emit("modal.open", i) }), i.on("close", function (t) { e.emit("modal.close", t, i) }), e.on("modal.requestClose", i.requestClose, i), i.on("close", function () { e.off("modal.requestClose", i.requestClose, i) }), i } var gP = function () { w(l, Ta); var h = T(l); function l(t, e) { var i; z(this, l), i = h.call(this, t, e); var n, s, r, o, a = pP(e, "cover"); (i.cover = !1 !== a ? (s = a, r = (n = t).scene, o = new sv(r, s), r.add.existing(o), n.isRexContainerLite ? n.moveDepthBelow(o) : r.children.moveBelow(o, n), o) : void 0, pP(e, "manualClose", !0)) ? i.setDisplayTime(-1) : (i.setDisplayTime(pP(e, "duration.hold", 2e3)), pP(e, "anyTouchClose", !0) && i.anyTouchClose()); return i.setTransitInTime(pP(e, "duration.in", 200)), i.setTransitOutTime(pP(e, "duration.out", 200)), i.setTransitInCallback(pP(e, "transitIn", yP.popUp)), i.setTransitOutCallback(pP(e, "transitOut", yP.scaleDown)), i.destroyParent = pP(e, "destroy", !0), i.timer = void 0, i._state = new fP(j(i), { eventEmitter: !1 }), i.closeEventData = void 0, i._state.next(), i } return k(l, [{ key: "state", get: function () { return this._state.state } }, { key: "shutdown", value: function (t) { this.isShutdown || (this.cover || this.scene.input.off("pointerup", this.requestClose, this), this.cover && !t && (this.cover.destroy(), this.cover = void 0), this.transitInCallback = void 0, this.transitOutCallback = void 0, this.closeEventData = void 0, this.removeDelayCall(), O(C(l.prototype), "shutdown", this).call(this, t)) } }, { key: "anyTouchClose", value: function () { return this.cover ? this.cover.once("pointerup", this.requestClose, this) : this.scene.input.once("pointerup", this.requestClose, this), this } }, { key: "transitionIn", value: function () { var t = this.transitInTime; this.transitInCallback(this.parent, t); var e = this.cover; return e && bu(e, t, e.alpha), this } }, { key: "transitionOut", value: function () { var t = this.transitOutTime; this.transitOutCallback(this.parent, t); var e = this.cover; return e && xu(e, t, !1), this } }, { key: "onOpen", value: function () { this.emit("open", this.parent, this) } }, { key: "onClose", value: function () { this.emit("close", this.closeEventData), this.destroyParent ? this.parent.destroy() : this.destroy() } }, { key: "delayCall", value: function (t, e, i) { return this.timer = Ym(this, t, e, i), this } }, { key: "removeDelayCall", value: function () { return this.timer && (this.timer.remove(!1), this.timer = void 0), this } }, { key: "setTransitInTime", value: function (t) { return this.transitInTime = t, this } }, { key: "setDisplayTime", value: function (t) { return this.displayTime = t, this } }, { key: "setTransitOutTime", value: function (t) { return this.transitOutTime = t, this } }, { key: "setTransitInCallback", value: function (t) { switch ("string" == typeof t && (t = yP[t]), t) { case yP.popUp: t = lP; break; case yP.fadeIn: t = cP }return t = t || _, this.transitInCallback = t, this } }, { key: "setTransitOutCallback", value: function (t) { switch ("string" == typeof t && (t = yP[t]), t) { case yP.scaleDown: t = uP; break; case yP.fadeOut: t = dP }return null == t && (t = _), this.transitOutCallback = t, this } }, { key: "requestClose", value: function (t) { return "OPEN" === this._state.state && (this.closeEventData = 0 < arguments.length ? t : this.parent, this._state.next()), this } }]), l }(), yP = { popUp: 0, fadeIn: 1, scaleDown: 0, fadeOut: 1 }, mP = function () { w(s, Phaser.Plugins.ScenePlugin); var n = T(s); function s(t, e) { var i; return z(this, s), (i = n.call(this, t, e)).add = new c(t), i } return k(s, [{ key: "start", value: function () { this.scene.events.on("destroy", this.destroy, this) } }, { key: "isInTouching", value: function (t, e, i, n) { return !!t.visible && Bu(t, e, i, n) } }, { key: "viewport", get: function () { return Bl(this.scene, this.scene.cameras.main, !0) } }, { key: "make", value: function (t, e, i, n) { return VS(this.scene, t, e, i, n) } }, { key: "maker", get: function () { return this._maker || (this._maker = new QS(this.scene)), this._maker } }]), s }(), kP = { getParentSizer: Ts, getTopmostSizer: Os, hide: Mu, show: Ou, isShown: Eu, edit: function (t, e, i) { return t._edit || (t._edit = new oP(t)), t._edit.open(e, i), t._edit }, wrapExpandText: function (t, e) { var s, i, n; return void 0 === e && (e = 0), t._minWidth = e, t.runWidthWrap = t instanceof so ? (n = t, function (t) { return n.setFixedSize(t, 0).runWordWrap(), n }) : ok(t) ? (i = t, function (t) { return i.setMaxWidth(t), i }) : (s = t, function (t) { var e = s.padding, i = t - e.left - e.right, n = s.style; return rk(s) ? n.wordWrapWidth = i : (0 === n.wrapMode && (n.wrapMode = 1), n.wrapWidth = i), n.maxLines = 0, s.setFixedSize(t, 0), s }), t }, fontSizeExpandText: function (i, t) { return void 0 === t && (t = 0), i._minWidth = t, i.runWidthWrap = function (t, e) { return tP(i, t, e), i }, i.resize = function (t, e) { return i.width === t && i.height === e || i.setFixedSize(t, e), i }, i }, fontSizeResize: tP, waitEvent: Eo, waitComplete: _o, delayPromise: function (i, n) { return void 0 === i && (i = 0), new Promise(function (t, e) { setTimeout(function () { t(n) }, i) }) }, setChildrenInteractive: yf, fadeIn: bu, fadeOutDestroy: xu, easeMoveTo: Su, easeMoveFrom: Pu, modal: vP, modalPromise: function (t, e) { var i = vP(t, e); return new Promise(function (e, t) { i.once("close", function (t) { e(t) }) }) }, modalClose: function (t, e) { t.emit("modal.requestClose", e) }, requestDrag: Hb, yaml: XS }; return Object.assign(mP.prototype, kP), mP });
